<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>Volley 源码解析之缓存机制 | 哆啦A梦Doraemon | So we beat on, boats against the current, borne back ceaselessly into the past.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#1FA67A">
    
    
    <meta name="keywords" content="Volley">
    <meta name="description" content="一、前言前面我们分析了12#### 二、 源码分析我们首先看看```Cache```这个缓存接口： public interface Cache {    //通过key获取指定请求的缓存实体    Entry get(String key); //存入指定的缓存实体 void put(String key, Entry entry);  //初始化缓存 void initialize();  /">
<meta name="keywords" content="Volley">
<meta property="og:type" content="article">
<meta property="og:title" content="Volley 源码解析之缓存机制">
<meta property="og:url" content="https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/index.html">
<meta property="og:site_name" content="哆啦A梦Doraemon">
<meta property="og:description" content="一、前言前面我们分析了12#### 二、 源码分析我们首先看看```Cache```这个缓存接口： public interface Cache {    //通过key获取指定请求的缓存实体    Entry get(String key); //存入指定的缓存实体 void put(String key, Entry entry);  //初始化缓存 void initialize();  /">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-03-05T15:47:29.763Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Volley 源码解析之缓存机制">
<meta name="twitter:description" content="一、前言前面我们分析了12#### 二、 源码分析我们首先看看```Cache```这个缓存接口： public interface Cache {    //通过key获取指定请求的缓存实体    Entry get(String key); //存入指定的缓存实体 void put(String key, Entry entry);  //初始化缓存 void initialize();  /">
    
        <link rel="alternate" type="application/atom+xml" title="哆啦A梦Doraemon" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">哆啦A梦Doraemon</h5>
          <a href="mailto:wvisible@outlook.com" title="wvisible@outlook.com" class="mail">wvisible@outlook.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/wvisible" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://juejin.im/user/5853e9e98d6d8100659a8e7a" target="_blank" >
                <i class="icon icon-lg icon-link"></i>
                掘金
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Volley 源码解析之缓存机制</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Volley 源码解析之缓存机制</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-03-05T15:45:42.000Z" itemprop="datePublished" class="page-time">
  2020-03-05
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/源码解析/">源码解析</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#一、前言"><span class="post-toc-number">1.</span> <span class="post-toc-text">一、前言</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#四、-总结"><span class="post-toc-number">2.</span> <span class="post-toc-text">四、 总结</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#参考链接"><span class="post-toc-number">3.</span> <span class="post-toc-text">参考链接</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-Volley-源码解析之缓存机制"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Volley 源码解析之缓存机制</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-03-05 23:45:42" datetime="2020-03-05T15:45:42.000Z"  itemprop="datePublished">2020-03-05</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/源码解析/">源码解析</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>前面我们分析了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 二、 源码分析</span><br><span class="line">我们首先看看```Cache```这个缓存接口：</span><br></pre></td></tr></table></figure></p>
<p>public interface Cache {<br>    //通过key获取指定请求的缓存实体<br>    Entry get(String key);</p>
<pre><code>//存入指定的缓存实体
void put(String key, Entry entry);

//初始化缓存
void initialize();

//使缓存中的指定请求实体过期
void invalidate(String key, boolean fullExpire);

//移除指定的请求缓存实体
void remove(String key);

//清空缓存
void clear();


class Entry {
    //请求返回的数据
    public byte[] data;

    //用于缓存验证的http请求头Etag
    public String etag;

    //Http 请求响应产生的时间
    public long serverDate;

    //最后修改时间
    public long lastModified;

    //过期时间
    public long ttl;

    //新鲜度时间
    public long softTtl;

    public Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();

    public List&lt;Header&gt; allResponseHeaders;

    //返回true则过期
    public boolean isExpired() {
        return this.ttl &lt; System.currentTimeMillis();
    }

    //需要从原始数据源刷新，则为true
    public boolean refreshNeeded() {
        return this.softTtl &lt; System.currentTimeMillis();
    }
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存储的实体就是响应，以字节数组作为数据的请求URL为键的缓存接口。  </span><br><span class="line">接下来我们看看```HttpHeaderParser```中用于解析```http```头的方法：</span><br></pre></td></tr></table></figure>
<p>public static Cache.Entry parseCacheHeaders(NetworkResponse response) {<br>        long now = System.currentTimeMillis();</p>
<pre><code>    Map&lt;String, String&gt; headers = response.headers;

    long serverDate = 0;
    long lastModified = 0;
    long serverExpires = 0;
    long softExpire = 0;
    long finalExpire = 0;
    long maxAge = 0;
    long staleWhileRevalidate = 0;
    boolean hasCacheControl = false;
    boolean mustRevalidate = false;

    String serverEtag = null;
    String headerValue;
    //表示收到响应的时间
    headerValue = headers.get(&quot;Date&quot;);
    if (headerValue != null) {
        serverDate = parseDateAsEpoch(headerValue);
    }
    //Cache-Control用于定义资源的缓存策略，在HTTP/1.1中，Cache-Control是
    最重要的规则，取代了 Expires
    headerValue = headers.get(&quot;Cache-Control&quot;);
    if (headerValue != null) {
        hasCacheControl = true;
        String[] tokens = headerValue.split(&quot;,&quot;, 0);
        for (int i = 0; i &lt; tokens.length; i++) {
            String token = tokens[i].trim();
            //no-cache：客户端缓存内容，每次都要向服务器重新验证资源是否
            被更改，但是是否使用缓存则需要经过协商缓存来验证决定，
            no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
            这两种情况不缓存返回null
            if (token.equals(&quot;no-cache&quot;) || token.equals(&quot;no-store&quot;)) {
                return null;
            //max-age：设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)
            } else if (token.startsWith(&quot;max-age=&quot;)) {
                try {
                    maxAge = Long.parseLong(token.substring(8));
                } catch (Exception e) {
                }
            //stale-while-revalidate：表明客户端愿意接受陈旧的响应，同时
            在后台异步检查新的响应。秒值指示客户愿意接受陈旧响应的时间长度
            } else if (token.startsWith(&quot;stale-while-revalidate=&quot;)) {
                try {
                    staleWhileRevalidate = Long.parseLong(token.substring(23));
                } catch (Exception e) {
                }
            //must-revalidate：缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。
            并不是说「每次都要验证」，它意味着某个资源在本地已缓存时长短于 max-age 指定时
            长时，可以直接使用，否则就要发起验证
            proxy-revalidate：与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。
            } else if (token.equals(&quot;must-revalidate&quot;) || token.equals(&quot;proxy-revalidate&quot;)) {
                mustRevalidate = true;
            }
        }
    }
    //Expires 是 HTTP/1.0的控制手段，其值为服务器返回该请求结果
    缓存的到期时间
    headerValue = headers.get(&quot;Expires&quot;);
    if (headerValue != null) {
        serverExpires = parseDateAsEpoch(headerValue);
    }

    // Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间
    headerValue = headers.get(&quot;Last-Modified&quot;);
    if (headerValue != null) {
        lastModified = parseDateAsEpoch(headerValue);
    }
    //Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)
    serverEtag = headers.get(&quot;ETag&quot;);

    // Cache-Control 优先 Expires 字段,请求头包含 Cache-Control，计算缓存的ttl和softTtl
    if (hasCacheControl) {
        //新鲜度时间只跟maxAge有关
        softExpire = now + maxAge * 1000;
        // 最终过期时间分两种情况：如果mustRevalidate为true，即需要验证新鲜度，
        那么直接跟新鲜度时间一样的，另一种情况是新鲜度时间 + 陈旧的响应时间 * 1000
        finalExpire = mustRevalidate ? softExpire : softExpire + staleWhileRevalidate * 1000;
    // 如果不包含Cache-Control头
    } else if (serverDate &gt; 0 &amp;&amp; serverExpires &gt;= serverDate) {
        // 缓存失效时间的计算
        softExpire = now + (serverExpires - serverDate);
        // 最终过期时间跟新鲜度时间一致
        finalExpire = softExpire;
    }

    Cache.Entry entry = new Cache.Entry();
    entry.data = response.data;
    entry.etag = serverEtag;
    entry.softTtl = softExpire;
    entry.ttl = finalExpire;
    entry.serverDate = serverDate;
    entry.lastModified = lastModified;
    entry.responseHeaders = headers;
    entry.allResponseHeaders = response.allHeaders;

    return entry;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这里主要是对请求头的缓存字段进行解析，并对缓存的相关字段赋值，特别是过期时间的计算要考虑到不同缓存头部的区别，以及每个缓存请求头的含义；  </span><br><span class="line">上面讲到的```stale-while-revalidate```这个字段举个例子：</span><br><span class="line">&gt;Cache-Control: max-age=600, stale-while-revalidate=30  </span><br><span class="line"></span><br><span class="line">这个响应表明当前响应内容新鲜时间为 600 秒，以及额外的 30 秒可以用来容忍过期缓存，服务器会将 max-age 和 stale-while-revalidate 的时间加在一起作为潜在最长可容忍的新鲜度时间，所有的响应都由缓存提供;不过在容忍过期缓存时间内,先直接从缓存中获取响应返回给调用者，然后在静默的在后台向原始服务器发起一次异步请求,然后在后台静默的更新缓存内容。</span><br><span class="line"></span><br><span class="line">这部分代码都是关于HTTP缓存的相关知识，我下面给出一些我参考引用的链接，大家可以去学习相关知识。  </span><br><span class="line"></span><br><span class="line">我们接下来继续看缓存的实现类```DiskBasedCache```，将缓存文件直接缓存到指定目录下的硬盘上，我们首先看看构造方法：</span><br></pre></td></tr></table></figure>
<p>public DiskBasedCache(File rootDirectory, int maxCacheSizeInBytes) {<br>        mRootDirectory = rootDirectory;<br>        mMaxCacheSizeInBytes = maxCacheSizeInBytes;<br>    }</p>
<p>public DiskBasedCache(File rootDirectory) {<br>    this(rootDirectory, DEFAULT_DISK_USAGE_BYTES);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">构造方法做了两件事，指定硬盘缓存的文件夹以及缓存的大小，默认5M。  </span><br><span class="line">我们首先看看初始化方法：</span><br></pre></td></tr></table></figure></p>
<p>public synchronized void initialize() {<br>        //如果缓存文件夹不存在则创建文件夹<br>        if (!mRootDirectory.exists()) {<br>            if (!mRootDirectory.mkdirs()) {<br>                VolleyLog.e(“Unable to create cache dir %s”, mRootDirectory.getAbsolutePath());<br>            }<br>            return;<br>        }<br>        File[] files = mRootDirectory.listFiles();<br>        if (files == null) {<br>            return;<br>        }<br>        for (File file : files) {<br>            try {<br>                long entrySize = file.length();<br>                CountingInputStream cis =<br>                        new CountingInputStream(<br>                                new BufferedInputStream(createInputStream(file)), entrySize);<br>                try {<br>                    CacheHeader entry = CacheHeader.readHeader(cis);<br>                    // 初始化的时候更新缓存大小为文件大小<br>                    entry.size = entrySize;<br>                    // 将已经存在的缓存存入到映射表中<br>                    putEntry(entry.key, entry);<br>                } finally {<br>                    // Any IOException thrown here is handled by the below catch block by design.<br>                    //noinspection ThrowFromFinallyBlock<br>                    cis.close();<br>                }<br>            } catch (IOException e) {<br>                //noinspection ResultOfMethodCallIgnored<br>                file.delete();<br>            }<br>        }<br>    }<br>//将 key 和 CacheHeader 存入到 map 对象当中，然后更新当前字节数<br>private void putEntry(String key, CacheHeader entry) {<br>    if (!mEntries.containsKey(key)) {<br>        mTotalSize += entry.size;<br>    } else {<br>        CacheHeader oldEntry = mEntries.get(key);<br>        mTotalSize += (entry.size - oldEntry.size);<br>    }<br>    mEntries.put(key, entry);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始化这里首先判断了缓存文件夹是否存在，不存在就要新建文件夹，这个很好理解。如果存在了就会将原来的已经存在的文件夹依次读取并存入一个缓存映射表中，方便后续判断有无缓存，不用直接从磁盘缓存中去查找文件名判断有无缓存。一般每个请求都会有一个```CacheHeader```，然后将存在的缓存头里的```size```重新赋值，初始化时大小为文件大小，存入数据为数据的大小。这里提一下```CacheHeader```是一个静态内部类，跟```Cache```的```Entry```有点像，少了一个```byte[] data```数组，其中维护了缓存头部的相关字段，这样设计的原因是方便快速读取，合理利用内存空间，因为缓存的相关信息需要频繁读取，内存占用小，可以缓存到内存中，但是网络请求的响应数据是非常占地方的，很容易就占满空间了，需要单独存储到硬盘中。   </span><br><span class="line">我们看下存入的方法：</span><br></pre></td></tr></table></figure></p>
<p>@Override<br>public synchronized void put(String key, Entry entry) {<br>    //首先进行缓存剩余空间的大小判断<br>    pruneIfNeeded(entry.data.length);<br>    File file = getFileForKey(key);<br>    try {<br>        BufferedOutputStream fos = new BufferedOutputStream(createOutputStream(file));<br>        CacheHeader e = new CacheHeader(key, entry);<br>        //CacheHeader 写入到磁盘<br>        boolean success = e.writeHeader(fos);<br>        if (!success) {<br>            fos.close();<br>            VolleyLog.d(“Failed to write header for %s”, file.getAbsolutePath());<br>            throw new IOException();<br>        }<br>        //网络请求的响应数据写入到磁盘<br>        fos.write(entry.data);<br>        fos.close();<br>        //头部信息等存储到到映射表<br>        putEntry(key, e);<br>        return;<br>    } catch (IOException e) {<br>    }<br>    boolean deleted = file.delete();<br>    if (!deleted) {<br>        VolleyLog.d(“Could not clean up file %s”, file.getAbsolutePath());<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个方法比较简单就是将响应数据以及缓存的头部信息写入到磁盘并且将头部缓存到内存中，我们看下当缓存空间不足，是怎么考虑缓存替换的：</span><br></pre></td></tr></table></figure></p>
<p> private void pruneIfNeeded(int neededSpace) {<br>    //缓存当前已经使用的空间总字节数 + 待存入的文件字节数是否大于缓存的最大大小，<br>    默认为5M，也可以自己指定，如果大于就要进行删除以前的缓存<br>    if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes) {<br>        return;<br>    }</p>
<pre><code>long before = mTotalSize;
// 删除的文件数量
int prunedFiles = 0;
long startTime = SystemClock.elapsedRealtime();

Iterator&lt;Map.Entry&lt;String, CacheHeader&gt;&gt; iterator = mEntries.entrySet().iterator();
//遍历mEntries中所有的缓存
while (iterator.hasNext()) {
    Map.Entry&lt;String, CacheHeader&gt; entry = iterator.next();
    CacheHeader e = entry.getValue();
    //因为mEntries是一个访问有序的LinkedHashMap，经常访问的会被移动到末尾，
    所以这里的思想就是 LRU 缓存算法
    boolean deleted = getFileForKey(e.key).delete();
    if (deleted) {
        //删除成功过后减少当前空间的总字节数
        mTotalSize -= e.size;
    } else {
        VolleyLog.d(
                &quot;Could not delete cache entry for key=%s, filename=%s&quot;,
                e.key, getFilenameForKey(e.key));
    }
    iterator.remove();
    prunedFiles++;
    //最后判断当前的空间是否满足新存入申请的空间大小，满足就跳出循环
    if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) {
        break;
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里的缓存替换策略也很好理解，如果不加以限制，那么岂不是一直写入数据到磁盘，有很多不用的数据很快就把磁盘写满了，所以使用了```LRU```缓存替换算法。 </span><br><span class="line">接下来我们看看存储的```key```，即缓存文件名生成方法：</span><br></pre></td></tr></table></figure></p>
<p>private String getFilenameForKey(String key) {<br>    int firstHalfLength = key.length() / 2;<br>    String localFilename = String.valueOf(key.substring(0, firstHalfLength).hashCode());<br>    localFilename += String.valueOf(key.substring(firstHalfLength).hashCode());<br>    return localFilename;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先将请求的```url```分成两部分，然后两部分分别求```hashCode```，最后拼接起来。如果我们使用```volley```来请求数据，那么通常是同一个地址中后面的不一样，很多字符一样，那么这样做可以避免```hashCode```重复造成文件名重复，创造更多的差异，因为```hash```在```Java```中不是那么可靠,关于这个问题我们可以在这篇文章中找到解答[面试后的总结](https://www.kymjs.com/code/2016/03/08/01/)   </span><br><span class="line">然后我们看下```get```方法：</span><br></pre></td></tr></table></figure></p>
<p>@Override<br>    public synchronized Entry get(String key) {<br>        CacheHeader entry = mEntries.get(key);<br>        // 如果entry不存在，则返回null<br>        if (entry == null) {<br>            return null;<br>        }<br>        //获取缓存的文件<br>        File file = getFileForKey(key);<br>        try {<br>            //这个类的作用是通过bytesRead记录已经读取的字节数<br>            CountingInputStream cis =<br>                    new CountingInputStream(<br>                            new BufferedInputStream(createInputStream(file)), file.length());<br>            try {<br>                //从磁盘获取缓存的CacheHeader<br>                CacheHeader entryOnDisk = CacheHeader.readHeader(cis);<br>                //如果传递进来的key和磁盘缓存中CacheHeader的key不相等，那么从内存缓存中<br>                移除这个缓存<br>                if (!TextUtils.equals(key, entryOnDisk.key)) {<br>                    removeEntry(key);<br>                    return null;<br>                }<br>                //读取缓存文件中的http响应体内容，然后创建一个entry返回<br>                byte[] data = streamToBytes(cis, cis.bytesRemaining());<br>                return entry.toCacheEntry(data);<br>            } finally {<br>                cis.close();<br>            }<br>        } catch (IOException e) {<br>            remove(key);<br>            return null;<br>        }<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">取数据首先从内存缓存中取出```CacheHeader```，如果为```null```那么直接返回，接下来如果取到了缓存，那么直接从磁盘里读取```CacheHeader```，如果存在两个```key```映射一个文件，那么就从内存缓存中移除这个缓存，最后将读取的文件组装成一个```entry```返回。这里有个疑问就是什么时候存在两个```key```映射一个文件呢？我们知道每个内存缓存中的```key```是我们请求的```url```，而磁盘缓存的文件名则是根据```key```的```hash```值计算得出，那么个人猜测有可能算出的文件名重复了，那么就会出现两个```key```对应一个文件，那么为了避免这种情况，需要先判断，出现了先从内存缓存移除，一般来说这种情况很少。   </span><br><span class="line"></span><br><span class="line">我们看看从```CountingInputStream```读取字节的方法</span><br></pre></td></tr></table></figure></p>
<p> static byte[] streamToBytes(CountingInputStream cis, long length) throws IOException {<br>        long maxLength = cis.bytesRemaining();<br>        // 读取的字节数不能为负数，不能大于当前剩余的字节数，还有不能整型溢出<br>        if (length &lt; 0 || length &gt; maxLength || (int) length != length) {<br>            throw new IOException(“streamToBytes length=” + length + “, maxLength=” + maxLength);<br>        }<br>        byte[] bytes = new byte[(int) length];<br>        new DataInputStream(cis).readFully(bytes);<br>        return bytes;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个方法是从```CountingInputStream```读取响应头还有响应体，怎么实现分开读取的呢，因为文件缓存首先是缓存的```CacheHeader```，接下来会从总的字节数减去已经读取的字节数，那么剩下的字节数就是响应体了。读取响应头是依次读取的，首先会先读取魔数判断是否是写入的缓存，然后依次读取各个```CacheHeader```字段，最后剩下的就是响应体了，读取和写入的顺序要一致。</span><br><span class="line"></span><br><span class="line">看一看缓存的清除方法：</span><br></pre></td></tr></table></figure></p>
<p>@Override<br>public synchronized void clear() {<br>    File[] files = mRootDirectory.listFiles();<br>    if (files != null) {<br>        for (File file : files) {<br>            file.delete();<br>        }<br>    }<br>    mEntries.clear();<br>    mTotalSize = 0;<br>    VolleyLog.d(“Cache cleared.”);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">遍历磁盘的每一个缓存文件并删除，清除内存缓存，更新使```size```为0。   </span><br><span class="line">接下来看看使某一个缓存```key```无效的方法</span><br></pre></td></tr></table></figure></p>
<p>@Override<br>public synchronized void invalidate(String key, boolean fullExpire) {<br>    Entry entry = get(key);<br>    if (entry != null) {<br>        entry.softTtl = 0;<br>        if (fullExpire) {<br>            entry.ttl = 0;<br>        }<br>        put(key, entry);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里主要对传入的```key```使缓存新鲜度无效，然后根据传入的第二个值是否为```true```，如果为```true```那么所有缓存都过期，否则只是缓存新鲜度过期，这里对```softTtl```和```ttl```值置为0，判断缓存过期的时候自然就小于当前时间返回```true```，达到了过期的目的，最后存入内存缓存和磁盘缓存当中。</span><br><span class="line"></span><br><span class="line">接下来我们看看一个特殊的类```NoCache```：</span><br></pre></td></tr></table></figure></p>
<p>public class NoCache implements Cache {<br>    @Override<br>    public void clear() {}</p>
<pre><code>@Override
public Entry get(String key) {
    return null;
}

@Override
public void put(String key, Entry entry) {}

@Override
public void invalidate(String key, boolean fullExpire) {}

@Override
public void remove(String key) {}

@Override
public void initialize() {}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实现 Cache 接口，不做任何操作的缓存实现类，可将它作为```RequestQueue```的参数实现一个默认不缓存的请求队列，后续取到的缓存都为```null```。</span><br><span class="line">#### 三、缓存的使用</span><br><span class="line">我们梳理下整个流程，看这几个方法的调用时期：</span><br></pre></td></tr></table></figure></p>
<p>private static RequestQueue newRequestQueue(Context context, Network network) {<br>    File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);<br>    RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);<br>    queue.start();<br>    return queue;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先这里调用了```DiskBasedCache```的构造方法，缓存默认大小是5M，缓存文件夹为```volley```。</span><br><span class="line">然后在```CacheDispatcher```的```run```方法里面实现了调用：</span><br></pre></td></tr></table></figure></p>
<p> @Override<br>public void run() {<br>    if (DEBUG) VolleyLog.v(“start new dispatcher”);<br>    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</p>
<pre><code>// Make a blocking call to initialize the cache.
mCache.initialize();

while (true) {
    try {
        processRequest();
    } catch (InterruptedException e) {
        // We may have been interrupted because it was time to quit.
        if (mQuit) {
            Thread.currentThread().interrupt();
            return;
        }
        VolleyLog.e(
                &quot;Ignoring spurious interrupt of CacheDispatcher thread; &quot;
                        + &quot;use quit() to terminate it&quot;);
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个类前面我们分析过，发起网络请求的时候会启动五个线程，一个缓存请求线程，四个网络请求分发的线程。首先在缓存线程里执行了缓存的初始化，如果关闭了应用那么重新发起请求的时候原来的缓存会重新缓存到到内存中。</span><br><span class="line"></span><br><span class="line">然后在```CacheDispatcher```里发起请求之前首先会从磁盘缓存获取缓存的内容：</span><br></pre></td></tr></table></figure></p>
<p>Cache.Entry entry = mCache.get(request.getCacheKey());<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后在```NetworkDispatcher```的请求到数据并缓存到根据```url```生成的缓存键的磁盘缓存中，缓存键默认是```url```。</span><br></pre></td></tr></table></figure></p>
<p>if (request.shouldCache() &amp;&amp; response.cacheEntry != null) {<br>    mCache.put(request.getCacheKey(), response.cacheEntry);<br>    request.addMarker(“network-cache-written”);<br>}<br><code>`</code></p>
<h4 id="四、-总结"><a href="#四、-总结" class="headerlink" title="四、 总结"></a>四、 总结</h4><p><code>volley</code> 的缓存机制分析完毕了，可以看出<code>volley</code>缓存设计考虑了很多细节，对各种缓存头的解析，将请求的响应和缓存头的相关信息缓存到磁盘缓存，缓存头的信息也缓存到内存缓存，将二者很好的联系起来，便于读取和查找缓存等一系列操作。缓存命中率、缓存的替换算法、缓存文件名的计算、使用接口抽象等设计都值得我们认真学习。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://github.com/wangzhengyi/Volley/blob/master/VOLLEY_CACHE.md" target="_blank" rel="noopener">Volley的缓存机制</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">Cache-Control
</a><br><a href="https://www.zcfy.cc/article/caching-best-practices-amp-max-age-gotchas-jakearchibald-com" target="_blank" rel="noopener">缓存最佳实践及 max-age 注意事项</a><br><a href="https://xesam.github.io/computer/2017/05/08/http-cache-control-extensions-for-stale.html" target="_blank" rel="noopener">Cache-Control扩展</a><br><a href="https://www.kymjs.com/code/2016/03/08/01/" target="_blank" rel="noopener">面试后的总结</a></p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-03-05T15:47:29.763Z" itemprop="dateUpdated">2020-03-05 23:47:29</time>
</span><br>


        
        如需转发请注明出处：<a href="/2020/03/05/Volley-源码解析之缓存机制/" target="_blank" rel="external">https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/</a>
        
    </div>
    <footer>
        <a href="https://wvisible.github.io">
            <img src="/img/avatar.jpg" alt="哆啦A梦Doraemon">
            哆啦A梦Doraemon
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volley/">Volley</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/&title=《Volley 源码解析之缓存机制》 — 哆啦A梦Doraemon&pic=https://wvisible.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/&title=《Volley 源码解析之缓存机制》 — 哆啦A梦Doraemon&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Volley 源码解析之缓存机制》 — 哆啦A梦Doraemon&url=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/&via=https://wvisible.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/03/05/Volley-源码解析之图片请求/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Volley 源码解析之图片请求</h4>
      </a>
    </div>
  
</nav>



    











</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>哆啦A梦Doraemon &copy; 2015 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/&title=《Volley 源码解析之缓存机制》 — 哆啦A梦Doraemon&pic=https://wvisible.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/&title=《Volley 源码解析之缓存机制》 — 哆啦A梦Doraemon&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Volley 源码解析之缓存机制》 — 哆啦A梦Doraemon&url=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/&via=https://wvisible.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACvUlEQVR42u3a0WrjQAwF0P7/T3dhnwpdp/dKM2ELx0/BOPYcB0aKpI+P+Pj8e3z9/PXM9/NP1zxd+fqa72s4fODh4eGNlv56cU+YBNx+K7kyWTMeHh7ebV7ygDwM5I9Ptv48SODh4eH9b7yWtEnQX+Px8PDwfguvTcRnVQI8PDy838LbbPo5LCe9TqOv1Frw8PDwtvt2ndq+8/P1/h4eHh7eqKveBowk+Z6VPGarxcPDw7vBaxPizYhVfj4f7YoCBh4eHt41XjLe9HpxbQiZjQ7UyTceHh7eUV7+t78de5ql5pvA85hM4+Hh4V3gtS2odolty+rU0/Hw8PBu8/L0d5ZM52EmT75/+BYeHh7eNV6yiZ8tKCRFjU15NypG4OHh4c3z5OgWeQk16UPl+3YLiNp4eHh4eAvefhBqP2g1ex310AAeHh7eUV6yKc9mmTbLzVPzx/vg4eHhXeDNyqOzUNGGhLaUXBRz8fDw8Na8TfF0U6LdD2blK8TDw8M7xctb+AmsbaHNkvIiEcfDw8O7xpuVX9sXMWtizVLwf0xG4OHh4R3iteFhk2rnQ6unxmHx8PDw3sObpdHRJFdcUNg0zB4LuHh4eHiHeHlRddPKSsoQq9+nHRrAw8PDW/Nmzac9vn0p+U+Ch4eHd4/Xprb55t6WGPIUf/YsPDw8vBu8U0NXLa8NCfnd8PDw8O7xZgMBbUOrXXo+QPBDrMPDw8O7zMvDxqmhgbykm/Mea9V4eHh4a95neSRLz8sNbfiph67w8PDwLvA2Tak8d20Hs/LWV/u68fDw8E7x9qMDbfpb5PtxIo6Hh4f3fl4bDNrhgHZ+4XqtBQ8PD++NvDxgzJa1CUsHAgMeHh7eUV4SAPbNsHaw4Ic14OHh4V3j5Q/Yt7Lasmx7Nzw8PLzbvFkDrE2482JEO8SwabPh4eHhlbw/BSiSlyITCQ0AAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '哆啦A梦Doraemon';
            clearTimeout(titleTime);
        } else {
            document.title = '哆啦A梦Doraemon';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
