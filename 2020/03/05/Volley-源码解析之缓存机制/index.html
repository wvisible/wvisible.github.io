<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>Volley 源码解析之缓存机制 | 哆啦A梦Doraemon | So we beat on, boats against the current, borne back ceaselessly into the past.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#1FA67A">
    
    
    <meta name="keywords" content="Volley">
    <meta name="description" content="一、前言前面我们分析了 Volley 的网络请求的相关流程以及图片加载的源码，如果没有看过的话可以阅读一下，接下来我们分析 Volley 的缓存，看看是怎么处理缓存超时、缓存更新以及缓存的整个流程，掌握 Volley 的缓存设计，对整个 Volley 的源码以及细节一个比较完整的认识。 二、 源码分析我们首先看看 Cache 这个缓存接口：12345678910111213141516171819">
<meta name="keywords" content="Volley">
<meta property="og:type" content="article">
<meta property="og:title" content="Volley 源码解析之缓存机制">
<meta property="og:url" content="https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/index.html">
<meta property="og:site_name" content="哆啦A梦Doraemon">
<meta property="og:description" content="一、前言前面我们分析了 Volley 的网络请求的相关流程以及图片加载的源码，如果没有看过的话可以阅读一下，接下来我们分析 Volley 的缓存，看看是怎么处理缓存超时、缓存更新以及缓存的整个流程，掌握 Volley 的缓存设计，对整个 Volley 的源码以及细节一个比较完整的认识。 二、 源码分析我们首先看看 Cache 这个缓存接口：12345678910111213141516171819">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-03-06T08:48:58.860Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Volley 源码解析之缓存机制">
<meta name="twitter:description" content="一、前言前面我们分析了 Volley 的网络请求的相关流程以及图片加载的源码，如果没有看过的话可以阅读一下，接下来我们分析 Volley 的缓存，看看是怎么处理缓存超时、缓存更新以及缓存的整个流程，掌握 Volley 的缓存设计，对整个 Volley 的源码以及细节一个比较完整的认识。 二、 源码分析我们首先看看 Cache 这个缓存接口：12345678910111213141516171819">
    
        <link rel="alternate" type="application/atom+xml" title="哆啦A梦Doraemon" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">哆啦A梦Doraemon</h5>
          <a href="mailto:wvisible@outlook.com" title="wvisible@outlook.com" class="mail">wvisible@outlook.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/source/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/source/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/wvisible" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://juejin.im/user/5853e9e98d6d8100659a8e7a" target="_blank" >
                <i class="icon icon-lg icon-link"></i>
                掘金
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Volley 源码解析之缓存机制</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Volley 源码解析之缓存机制</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-03-05T15:45:42.000Z" itemprop="datePublished" class="page-time">
  2020-03-05
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/源码解析/">源码解析</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#一、前言"><span class="post-toc-number">1.</span> <span class="post-toc-text">一、前言</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#二、-源码分析"><span class="post-toc-number">2.</span> <span class="post-toc-text">二、 源码分析</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#三、缓存的使用"><span class="post-toc-number">3.</span> <span class="post-toc-text">三、缓存的使用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#四、-总结"><span class="post-toc-number">4.</span> <span class="post-toc-text">四、 总结</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#参考链接"><span class="post-toc-number">5.</span> <span class="post-toc-text">参考链接</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-Volley-源码解析之缓存机制"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Volley 源码解析之缓存机制</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-03-05 23:45:42" datetime="2020-03-05T15:45:42.000Z"  itemprop="datePublished">2020-03-05</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/源码解析/">源码解析</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>前面我们分析了 <code>Volley</code> 的网络请求的相关流程以及图片加载的源码，如果没有看过的话可以阅读一下，接下来我们分析 <code>Volley</code> 的缓存，看看是怎么处理缓存超时、缓存更新以及缓存的整个流程，掌握 <code>Volley</code> 的缓存设计，对整个 <code>Volley</code> 的源码以及细节一个比较完整的认识。</p>
<h4 id="二、-源码分析"><a href="#二、-源码分析" class="headerlink" title="二、 源码分析"></a>二、 源码分析</h4><p>我们首先看看 <code>Cache</code> 这个缓存接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public interface Cache &#123;</span><br><span class="line">    //通过key获取指定请求的缓存实体</span><br><span class="line">    Entry get(String key);</span><br><span class="line"></span><br><span class="line">    //存入指定的缓存实体</span><br><span class="line">    void put(String key, Entry entry);</span><br><span class="line"></span><br><span class="line">    //初始化缓存</span><br><span class="line">    void initialize();</span><br><span class="line"></span><br><span class="line">    //使缓存中的指定请求实体过期</span><br><span class="line">    void invalidate(String key, boolean fullExpire);</span><br><span class="line"></span><br><span class="line">    //移除指定的请求缓存实体</span><br><span class="line">    void remove(String key);</span><br><span class="line"></span><br><span class="line">    //清空缓存</span><br><span class="line">    void clear();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    class Entry &#123;</span><br><span class="line">        //请求返回的数据</span><br><span class="line">        public byte[] data;</span><br><span class="line"></span><br><span class="line">        //用于缓存验证的http请求头Etag</span><br><span class="line">        public String etag;</span><br><span class="line"></span><br><span class="line">        //Http 请求响应产生的时间</span><br><span class="line">        public long serverDate;</span><br><span class="line"></span><br><span class="line">        //最后修改时间</span><br><span class="line">        public long lastModified;</span><br><span class="line"></span><br><span class="line">        //过期时间</span><br><span class="line">        public long ttl;</span><br><span class="line"></span><br><span class="line">        //新鲜度时间</span><br><span class="line">        public long softTtl;</span><br><span class="line">        </span><br><span class="line">        public Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</span><br><span class="line">        </span><br><span class="line">        public List&lt;Header&gt; allResponseHeaders;</span><br><span class="line"></span><br><span class="line">        //返回true则过期</span><br><span class="line">        public boolean isExpired() &#123;</span><br><span class="line">            return this.ttl &lt; System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //需要从原始数据源刷新，则为true</span><br><span class="line">        public boolean refreshNeeded() &#123;</span><br><span class="line">            return this.softTtl &lt; System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>存储的实体就是响应，以字节数组作为数据的请求URL为键的缓存接口。<br>接下来我们看看 <code>HttpHeaderParser</code> 中用于解析 <code>http</code> 头的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">public static Cache.Entry parseCacheHeaders(NetworkResponse response) &#123;</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; headers = response.headers;</span><br><span class="line"></span><br><span class="line">        long serverDate = 0;</span><br><span class="line">        long lastModified = 0;</span><br><span class="line">        long serverExpires = 0;</span><br><span class="line">        long softExpire = 0;</span><br><span class="line">        long finalExpire = 0;</span><br><span class="line">        long maxAge = 0;</span><br><span class="line">        long staleWhileRevalidate = 0;</span><br><span class="line">        boolean hasCacheControl = false;</span><br><span class="line">        boolean mustRevalidate = false;</span><br><span class="line"></span><br><span class="line">        String serverEtag = null;</span><br><span class="line">        String headerValue;</span><br><span class="line">        //表示收到响应的时间</span><br><span class="line">        headerValue = headers.get(&quot;Date&quot;);</span><br><span class="line">        if (headerValue != null) &#123;</span><br><span class="line">            serverDate = parseDateAsEpoch(headerValue);</span><br><span class="line">        &#125;</span><br><span class="line">        //Cache-Control用于定义资源的缓存策略，在HTTP/1.1中，Cache-Control是</span><br><span class="line">        最重要的规则，取代了 Expires</span><br><span class="line">        headerValue = headers.get(&quot;Cache-Control&quot;);</span><br><span class="line">        if (headerValue != null) &#123;</span><br><span class="line">            hasCacheControl = true;</span><br><span class="line">            String[] tokens = headerValue.split(&quot;,&quot;, 0);</span><br><span class="line">            for (int i = 0; i &lt; tokens.length; i++) &#123;</span><br><span class="line">                String token = tokens[i].trim();</span><br><span class="line">                //no-cache：客户端缓存内容，每次都要向服务器重新验证资源是否</span><br><span class="line">                被更改，但是是否使用缓存则需要经过协商缓存来验证决定，</span><br><span class="line">                no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</span><br><span class="line">                这两种情况不缓存返回null</span><br><span class="line">                if (token.equals(&quot;no-cache&quot;) || token.equals(&quot;no-store&quot;)) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                //max-age：设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)</span><br><span class="line">                &#125; else if (token.startsWith(&quot;max-age=&quot;)) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        maxAge = Long.parseLong(token.substring(8));</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                //stale-while-revalidate：表明客户端愿意接受陈旧的响应，同时</span><br><span class="line">                在后台异步检查新的响应。秒值指示客户愿意接受陈旧响应的时间长度</span><br><span class="line">                &#125; else if (token.startsWith(&quot;stale-while-revalidate=&quot;)) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        staleWhileRevalidate = Long.parseLong(token.substring(23));</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                //must-revalidate：缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。</span><br><span class="line">                并不是说「每次都要验证」，它意味着某个资源在本地已缓存时长短于 max-age 指定时</span><br><span class="line">                长时，可以直接使用，否则就要发起验证</span><br><span class="line">                proxy-revalidate：与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。</span><br><span class="line">                &#125; else if (token.equals(&quot;must-revalidate&quot;) || token.equals(&quot;proxy-revalidate&quot;)) &#123;</span><br><span class="line">                    mustRevalidate = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //Expires 是 HTTP/1.0的控制手段，其值为服务器返回该请求结果</span><br><span class="line">        缓存的到期时间</span><br><span class="line">        headerValue = headers.get(&quot;Expires&quot;);</span><br><span class="line">        if (headerValue != null) &#123;</span><br><span class="line">            serverExpires = parseDateAsEpoch(headerValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间</span><br><span class="line">        headerValue = headers.get(&quot;Last-Modified&quot;);</span><br><span class="line">        if (headerValue != null) &#123;</span><br><span class="line">            lastModified = parseDateAsEpoch(headerValue);</span><br><span class="line">        &#125;</span><br><span class="line">        //Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</span><br><span class="line">        serverEtag = headers.get(&quot;ETag&quot;);</span><br><span class="line"></span><br><span class="line">        // Cache-Control 优先 Expires 字段,请求头包含 Cache-Control，计算缓存的ttl和softTtl</span><br><span class="line">        if (hasCacheControl) &#123;</span><br><span class="line">            //新鲜度时间只跟maxAge有关</span><br><span class="line">            softExpire = now + maxAge * 1000;</span><br><span class="line">            // 最终过期时间分两种情况：如果mustRevalidate为true，即需要验证新鲜度，</span><br><span class="line">            那么直接跟新鲜度时间一样的，另一种情况是新鲜度时间 + 陈旧的响应时间 * 1000</span><br><span class="line">            finalExpire = mustRevalidate ? softExpire : softExpire + staleWhileRevalidate * 1000;</span><br><span class="line">        // 如果不包含Cache-Control头</span><br><span class="line">        &#125; else if (serverDate &gt; 0 &amp;&amp; serverExpires &gt;= serverDate) &#123;</span><br><span class="line">            // 缓存失效时间的计算</span><br><span class="line">            softExpire = now + (serverExpires - serverDate);</span><br><span class="line">            // 最终过期时间跟新鲜度时间一致</span><br><span class="line">            finalExpire = softExpire;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Cache.Entry entry = new Cache.Entry();</span><br><span class="line">        entry.data = response.data;</span><br><span class="line">        entry.etag = serverEtag;</span><br><span class="line">        entry.softTtl = softExpire;</span><br><span class="line">        entry.ttl = finalExpire;</span><br><span class="line">        entry.serverDate = serverDate;</span><br><span class="line">        entry.lastModified = lastModified;</span><br><span class="line">        entry.responseHeaders = headers;</span><br><span class="line">        entry.allResponseHeaders = response.allHeaders;</span><br><span class="line"></span><br><span class="line">        return entry;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里主要是对请求头的缓存字段进行解析，并对缓存的相关字段赋值，特别是过期时间的计算要考虑到不同缓存头部的区别，以及每个缓存请求头的含义；<br>上面讲到的 <code>stale-while-revalidate</code> 这个字段举个例子：</p>
<blockquote>
<p>Cache-Control: max-age=600, stale-while-revalidate=30  </p>
</blockquote>
<p>这个响应表明当前响应内容新鲜时间为 600 秒，以及额外的 30 秒可以用来容忍过期缓存，服务器会将 <code>max-age</code> 和 <code>stale-while-revalidate</code> 的时间加在一起作为潜在最长可容忍的新鲜度时间，所有的响应都由缓存提供;不过在容忍过期缓存时间内,先直接从缓存中获取响应返回给调用者，然后在静默的在后台向原始服务器发起一次异步请求,然后在后台静默的更新缓存内容。</p>
<p>这部分代码都是关于HTTP缓存的相关知识，我下面给出一些我参考引用的链接，大家可以去学习相关知识。  </p>
<p>我们接下来继续看缓存的实现类 <code>DiskBasedCache</code>，将缓存文件直接缓存到指定目录下的硬盘上，我们首先看看构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public DiskBasedCache(File rootDirectory, int maxCacheSizeInBytes) &#123;</span><br><span class="line">        mRootDirectory = rootDirectory;</span><br><span class="line">        mMaxCacheSizeInBytes = maxCacheSizeInBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public DiskBasedCache(File rootDirectory) &#123;</span><br><span class="line">    this(rootDirectory, DEFAULT_DISK_USAGE_BYTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造方法做了两件事，指定硬盘缓存的文件夹以及缓存的大小，默认5M。<br>我们首先看看初始化方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void initialize() &#123;</span><br><span class="line">        //如果缓存文件夹不存在则创建文件夹</span><br><span class="line">        if (!mRootDirectory.exists()) &#123;</span><br><span class="line">            if (!mRootDirectory.mkdirs()) &#123;</span><br><span class="line">                VolleyLog.e(&quot;Unable to create cache dir %s&quot;, mRootDirectory.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        File[] files = mRootDirectory.listFiles();</span><br><span class="line">        if (files == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (File file : files) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                long entrySize = file.length();</span><br><span class="line">                CountingInputStream cis =</span><br><span class="line">                        new CountingInputStream(</span><br><span class="line">                                new BufferedInputStream(createInputStream(file)), entrySize);</span><br><span class="line">                try &#123;</span><br><span class="line">                    CacheHeader entry = CacheHeader.readHeader(cis);</span><br><span class="line">                    // 初始化的时候更新缓存大小为文件大小</span><br><span class="line">                    entry.size = entrySize;</span><br><span class="line">                    // 将已经存在的缓存存入到映射表中</span><br><span class="line">                    putEntry(entry.key, entry);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    // Any IOException thrown here is handled by the below catch block by design.</span><br><span class="line">                    //noinspection ThrowFromFinallyBlock</span><br><span class="line">                    cis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                //noinspection ResultOfMethodCallIgnored</span><br><span class="line">                file.delete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//将 key 和 CacheHeader 存入到 map 对象当中，然后更新当前字节数</span><br><span class="line">private void putEntry(String key, CacheHeader entry) &#123;</span><br><span class="line">    if (!mEntries.containsKey(key)) &#123;</span><br><span class="line">        mTotalSize += entry.size;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        CacheHeader oldEntry = mEntries.get(key);</span><br><span class="line">        mTotalSize += (entry.size - oldEntry.size);</span><br><span class="line">    &#125;</span><br><span class="line">    mEntries.put(key, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化这里首先判断了缓存文件夹是否存在，不存在就要新建文件夹，这个很好理解。如果存在了就会将原来的已经存在的文件夹依次读取并存入一个缓存映射表中，方便后续判断有无缓存，不用直接从磁盘缓存中去查找文件名判断有无缓存。一般每个请求都会有一个 <code>CacheHeader</code>，然后将存在的缓存头里的 <code>size</code> 重新赋值，初始化时大小为文件大小，存入数据为数据的大小。这里提一下 <code>CacheHeader</code> 是一个静态内部类，跟 <code>Cache</code> 的 <code>Entry</code> 有点像，少了一个 <code>byte[] data</code> 数组，其中维护了缓存头部的相关字段，这样设计的原因是方便快速读取，合理利用内存空间，因为缓存的相关信息需要频繁读取，内存占用小，可以缓存到内存中，但是网络请求的响应数据是非常占地方的，很容易就占满空间了，需要单独存储到硬盘中。<br>我们看下存入的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized void put(String key, Entry entry) &#123;</span><br><span class="line">    //首先进行缓存剩余空间的大小判断</span><br><span class="line">    pruneIfNeeded(entry.data.length);</span><br><span class="line">    File file = getFileForKey(key);</span><br><span class="line">    try &#123;</span><br><span class="line">        BufferedOutputStream fos = new BufferedOutputStream(createOutputStream(file));</span><br><span class="line">        CacheHeader e = new CacheHeader(key, entry);</span><br><span class="line">        //CacheHeader 写入到磁盘</span><br><span class="line">        boolean success = e.writeHeader(fos);</span><br><span class="line">        if (!success) &#123;</span><br><span class="line">            fos.close();</span><br><span class="line">            VolleyLog.d(&quot;Failed to write header for %s&quot;, file.getAbsolutePath());</span><br><span class="line">            throw new IOException();</span><br><span class="line">        &#125;</span><br><span class="line">        //网络请求的响应数据写入到磁盘</span><br><span class="line">        fos.write(entry.data);</span><br><span class="line">        fos.close();</span><br><span class="line">        //头部信息等存储到到映射表</span><br><span class="line">        putEntry(key, e);</span><br><span class="line">        return;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean deleted = file.delete();</span><br><span class="line">    if (!deleted) &#123;</span><br><span class="line">        VolleyLog.d(&quot;Could not clean up file %s&quot;, file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法比较简单就是将响应数据以及缓存的头部信息写入到磁盘并且将头部缓存到内存中，我们看下当缓存空间不足，是怎么考虑缓存替换的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> private void pruneIfNeeded(int neededSpace) &#123;</span><br><span class="line">    //缓存当前已经使用的空间总字节数 + 待存入的文件字节数是否大于缓存的最大大小，</span><br><span class="line">    默认为5M，也可以自己指定，如果大于就要进行删除以前的缓存</span><br><span class="line">    if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long before = mTotalSize;</span><br><span class="line">    // 删除的文件数量</span><br><span class="line">    int prunedFiles = 0;</span><br><span class="line">    long startTime = SystemClock.elapsedRealtime();</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, CacheHeader&gt;&gt; iterator = mEntries.entrySet().iterator();</span><br><span class="line">    //遍历mEntries中所有的缓存</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, CacheHeader&gt; entry = iterator.next();</span><br><span class="line">        CacheHeader e = entry.getValue();</span><br><span class="line">        //因为mEntries是一个访问有序的LinkedHashMap，经常访问的会被移动到末尾，</span><br><span class="line">        所以这里的思想就是 LRU 缓存算法</span><br><span class="line">        boolean deleted = getFileForKey(e.key).delete();</span><br><span class="line">        if (deleted) &#123;</span><br><span class="line">            //删除成功过后减少当前空间的总字节数</span><br><span class="line">            mTotalSize -= e.size;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            VolleyLog.d(</span><br><span class="line">                    &quot;Could not delete cache entry for key=%s, filename=%s&quot;,</span><br><span class="line">                    e.key, getFilenameForKey(e.key));</span><br><span class="line">        &#125;</span><br><span class="line">        iterator.remove();</span><br><span class="line">        prunedFiles++;</span><br><span class="line">        //最后判断当前的空间是否满足新存入申请的空间大小，满足就跳出循环</span><br><span class="line">        if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的缓存替换策略也很好理解，如果不加以限制，那么岂不是一直写入数据到磁盘，有很多不用的数据很快就把磁盘写满了，所以使用了 <code>LRU</code> 缓存替换算法。<br>接下来我们看看存储的 <code>key</code>，即缓存文件名生成方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private String getFilenameForKey(String key) &#123;</span><br><span class="line">    int firstHalfLength = key.length() / 2;</span><br><span class="line">    String localFilename = String.valueOf(key.substring(0, firstHalfLength).hashCode());</span><br><span class="line">    localFilename += String.valueOf(key.substring(firstHalfLength).hashCode());</span><br><span class="line">    return localFilename;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先将请求的 <code>url</code> 分成两部分，然后两部分分别求 <code>hashCode</code>，最后拼接起来。如果我们使用 <code>volley</code> 来请求数据，那么通常是同一个地址中后面的不一样，很多字符一样，那么这样做可以避免 <code>hashCode</code> 重复造成文件名重复，创造更多的差异，因为<code>hash</code> 在 <code>Java</code> 中不是那么可靠,关于这个问题我们可以在这篇文章中找到解答<a href="https://www.kymjs.com/code/2016/03/08/01/" target="_blank" rel="noopener">面试后的总结</a><br>然后我们看下 <code>get</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public synchronized Entry get(String key) &#123;</span><br><span class="line">        CacheHeader entry = mEntries.get(key);</span><br><span class="line">        // 如果entry不存在，则返回null</span><br><span class="line">        if (entry == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //获取缓存的文件</span><br><span class="line">        File file = getFileForKey(key);</span><br><span class="line">        try &#123;</span><br><span class="line">            //这个类的作用是通过bytesRead记录已经读取的字节数</span><br><span class="line">            CountingInputStream cis =</span><br><span class="line">                    new CountingInputStream(</span><br><span class="line">                            new BufferedInputStream(createInputStream(file)), file.length());</span><br><span class="line">            try &#123;</span><br><span class="line">                //从磁盘获取缓存的CacheHeader</span><br><span class="line">                CacheHeader entryOnDisk = CacheHeader.readHeader(cis);</span><br><span class="line">                //如果传递进来的key和磁盘缓存中CacheHeader的key不相等，那么从内存缓存中</span><br><span class="line">                移除这个缓存</span><br><span class="line">                if (!TextUtils.equals(key, entryOnDisk.key)) &#123;</span><br><span class="line">                    removeEntry(key);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                //读取缓存文件中的http响应体内容，然后创建一个entry返回</span><br><span class="line">                byte[] data = streamToBytes(cis, cis.bytesRemaining());</span><br><span class="line">                return entry.toCacheEntry(data);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                cis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            remove(key);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>取数据首先从内存缓存中取出 <code>CacheHeader</code>，如果为 <code>null</code> 那么直接返回，接下来如果取到了缓存，那么直接从磁盘里读取 <code>CacheHeader</code>，如果存在两个 <code>key</code> 映射一个文件，那么就从内存缓存中移除这个缓存，最后将读取的文件组装成一个<code>entry</code> 返回。这里有个疑问就是什么时候存在两个 <code>key</code> 映射一个文件呢？我们知道每个内存缓存中的 <code>key</code> 是我们请求的 <code>url</code>，而磁盘缓存的文件名则是根据 <code>key</code> 的 <code>hash</code> 值计算得出，那么个人猜测有可能算出的文件名重复了，那么就会出现两个 <code>key</code> 对应一个文件，那么为了避免这种情况，需要先判断，出现了先从内存缓存移除，一般来说这种情况很少。   </p>
<p>我们看看从 <code>CountingInputStream</code> 读取字节的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static byte[] streamToBytes(CountingInputStream cis, long length) throws IOException &#123;</span><br><span class="line">       long maxLength = cis.bytesRemaining();</span><br><span class="line">       // 读取的字节数不能为负数，不能大于当前剩余的字节数，还有不能整型溢出</span><br><span class="line">       if (length &lt; 0 || length &gt; maxLength || (int) length != length) &#123;</span><br><span class="line">           throw new IOException(&quot;streamToBytes length=&quot; + length + &quot;, maxLength=&quot; + maxLength);</span><br><span class="line">       &#125;</span><br><span class="line">       byte[] bytes = new byte[(int) length];</span><br><span class="line">       new DataInputStream(cis).readFully(bytes);</span><br><span class="line">       return bytes;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法是从 <code>CountingInputStream</code> 读取响应头还有响应体，怎么实现分开读取的呢，因为文件缓存首先是缓存的<code>CacheHeader</code>，接下来会从总的字节数减去已经读取的字节数，那么剩下的字节数就是响应体了。读取响应头是依次读取的，首先会先读取魔数判断是否是写入的缓存，然后依次读取各个 <code>CacheHeader</code> 字段，最后剩下的就是响应体了，读取和写入的顺序要一致。</p>
<p>看一看缓存的清除方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized void clear() &#123;</span><br><span class="line">    File[] files = mRootDirectory.listFiles();</span><br><span class="line">    if (files != null) &#123;</span><br><span class="line">        for (File file : files) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mEntries.clear();</span><br><span class="line">    mTotalSize = 0;</span><br><span class="line">    VolleyLog.d(&quot;Cache cleared.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>遍历磁盘的每一个缓存文件并删除，清除内存缓存，更新使 <code>size</code> 为0。<br>接下来看看使某一个缓存 <code>key</code> 无效的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized void invalidate(String key, boolean fullExpire) &#123;</span><br><span class="line">    Entry entry = get(key);</span><br><span class="line">    if (entry != null) &#123;</span><br><span class="line">        entry.softTtl = 0;</span><br><span class="line">        if (fullExpire) &#123;</span><br><span class="line">            entry.ttl = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        put(key, entry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里主要对传入的 <code>key</code> 使缓存新鲜度无效，然后根据传入的第二个值是否为 <code>true</code>，如果为 <code>true</code> 那么所有缓存都过期，否则只是缓存新鲜度过期，这里对 <code>softTtl</code> 和 <code>ttl</code> 值置为0，判断缓存过期的时候自然就小于当前时间返回 <code>true</code>，达到了过期的目的，最后存入内存缓存和磁盘缓存当中。</p>
<p>接下来我们看看一个特殊的类 <code>NoCache</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class NoCache implements Cache &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void clear() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Entry get(String key) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void put(String key, Entry entry) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void invalidate(String key, boolean fullExpire) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void remove(String key) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void initialize() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现 Cache 接口，不做任何操作的缓存实现类，可将它作为 <code>RequestQueue</code> 的参数实现一个默认不缓存的请求队列，后续取到的缓存都为 <code>null</code>。</p>
<h4 id="三、缓存的使用"><a href="#三、缓存的使用" class="headerlink" title="三、缓存的使用"></a>三、缓存的使用</h4><p>我们梳理下整个流程，看这几个方法的调用时期：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static RequestQueue newRequestQueue(Context context, Network network) &#123;</span><br><span class="line">    File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">    RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);</span><br><span class="line">    queue.start();</span><br><span class="line">    return queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先这里调用了 <code>DiskBasedCache</code> 的构造方法，缓存默认大小是5M，缓存文件夹为 <code>volley</code>。<br>然后在 <code>CacheDispatcher</code> 的 <code>run</code> 方法里面实现了调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);</span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line"></span><br><span class="line">    // Make a blocking call to initialize the cache.</span><br><span class="line">    mCache.initialize();</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            processRequest();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            // We may have been interrupted because it was time to quit.</span><br><span class="line">            if (mQuit) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            VolleyLog.e(</span><br><span class="line">                    &quot;Ignoring spurious interrupt of CacheDispatcher thread; &quot;</span><br><span class="line">                            + &quot;use quit() to terminate it&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个类前面我们分析过，发起网络请求的时候会启动五个线程，一个缓存请求线程，四个网络请求分发的线程。首先在缓存线程里执行了缓存的初始化，如果关闭了应用那么重新发起请求的时候原来的缓存会重新缓存到到内存中。</p>
<p>然后在 <code>CacheDispatcher</code> 里发起请求之前首先会从磁盘缓存获取缓存的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache.Entry entry = mCache.get(request.getCacheKey());</span><br></pre></td></tr></table></figure></p>
<p>然后在 <code>NetworkDispatcher</code> 的请求到数据并缓存到根据 <code>url</code> 生成的缓存键的磁盘缓存中，缓存键默认是 <code>url</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</span><br><span class="line">    mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">    request.addMarker(&quot;network-cache-written&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="四、-总结"><a href="#四、-总结" class="headerlink" title="四、 总结"></a>四、 总结</h4><p><code>Volley</code> 的缓存机制分析完毕了，可以看出 <code>Volley</code> 缓存设计考虑了很多细节，对各种缓存头的解析，将请求的响应和缓存头的相关信息缓存到磁盘缓存，缓存头的信息也缓存到内存缓存，将二者很好的联系起来，便于读取和查找缓存等一系列操作。缓存命中率、缓存的替换算法、缓存文件名的计算、使用接口抽象等设计都值得我们认真学习。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://github.com/wangzhengyi/Volley/blob/master/VOLLEY_CACHE.md" target="_blank" rel="noopener">Volley的缓存机制</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">Cache-Control
</a><br><a href="https://www.zcfy.cc/article/caching-best-practices-amp-max-age-gotchas-jakearchibald-com" target="_blank" rel="noopener">缓存最佳实践及 max-age 注意事项</a><br><a href="https://xesam.github.io/computer/2017/05/08/http-cache-control-extensions-for-stale.html" target="_blank" rel="noopener">Cache-Control扩展</a><br><a href="https://www.kymjs.com/code/2016/03/08/01/" target="_blank" rel="noopener">面试后的总结</a></p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-03-06T08:48:58.860Z" itemprop="dateUpdated">2020-03-06 16:48:58</time>
</span><br>


        
        如需转发请注明出处：<a href="/2020/03/05/Volley-源码解析之缓存机制/" target="_blank" rel="external">https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/</a>
        
    </div>
    <footer>
        <a href="https://wvisible.github.io">
            <img src="/img/avatar.jpg" alt="哆啦A梦Doraemon">
            哆啦A梦Doraemon
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volley/">Volley</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/&title=《Volley 源码解析之缓存机制》 — 哆啦A梦Doraemon&pic=https://wvisible.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/&title=《Volley 源码解析之缓存机制》 — 哆啦A梦Doraemon&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Volley 源码解析之缓存机制》 — 哆啦A梦Doraemon&url=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/&via=https://wvisible.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/03/05/Volley-源码解析之图片请求/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Volley 源码解析之图片请求</h4>
      </a>
    </div>
  
</nav>



    











</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>哆啦A梦Doraemon &copy; 2015 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/&title=《Volley 源码解析之缓存机制》 — 哆啦A梦Doraemon&pic=https://wvisible.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/&title=《Volley 源码解析之缓存机制》 — 哆啦A梦Doraemon&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Volley 源码解析之缓存机制》 — 哆啦A梦Doraemon&url=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/&via=https://wvisible.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACvUlEQVR42u3a0WrjQAwF0P7/T3dhnwpdp/dKM2ELx0/BOPYcB0aKpI+P+Pj8e3z9/PXM9/NP1zxd+fqa72s4fODh4eGNlv56cU+YBNx+K7kyWTMeHh7ebV7ygDwM5I9Ptv48SODh4eH9b7yWtEnQX+Px8PDwfguvTcRnVQI8PDy838LbbPo5LCe9TqOv1Frw8PDwtvt2ndq+8/P1/h4eHh7eqKveBowk+Z6VPGarxcPDw7vBaxPizYhVfj4f7YoCBh4eHt41XjLe9HpxbQiZjQ7UyTceHh7eUV7+t78de5ql5pvA85hM4+Hh4V3gtS2odolty+rU0/Hw8PBu8/L0d5ZM52EmT75/+BYeHh7eNV6yiZ8tKCRFjU15NypG4OHh4c3z5OgWeQk16UPl+3YLiNp4eHh4eAvefhBqP2g1ex310AAeHh7eUV6yKc9mmTbLzVPzx/vg4eHhXeDNyqOzUNGGhLaUXBRz8fDw8Na8TfF0U6LdD2blK8TDw8M7xctb+AmsbaHNkvIiEcfDw8O7xpuVX9sXMWtizVLwf0xG4OHh4R3iteFhk2rnQ6unxmHx8PDw3sObpdHRJFdcUNg0zB4LuHh4eHiHeHlRddPKSsoQq9+nHRrAw8PDW/Nmzac9vn0p+U+Ch4eHd4/Xprb55t6WGPIUf/YsPDw8vBu8U0NXLa8NCfnd8PDw8O7xZgMBbUOrXXo+QPBDrMPDw8O7zMvDxqmhgbykm/Mea9V4eHh4a95neSRLz8sNbfiph67w8PDwLvA2Tak8d20Hs/LWV/u68fDw8E7x9qMDbfpb5PtxIo6Hh4f3fl4bDNrhgHZ+4XqtBQ8PD++NvDxgzJa1CUsHAgMeHh7eUV4SAPbNsHaw4Ic14OHh4V3j5Q/Yt7Lasmx7Nzw8PLzbvFkDrE2482JEO8SwabPh4eHhlbw/BSiSlyITCQ0AAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '哆啦A梦Doraemon';
            clearTimeout(titleTime);
        } else {
            document.title = '哆啦A梦Doraemon';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
