<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>Volley 源码解析之图片请求 | 哆啦A梦Doraemon | So we beat on, boats against the current, borne back ceaselessly into the past.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#1FA67A">
    
    
    <meta name="keywords" content="Volley">
    <meta name="description" content="一、前言上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章Volley 源码解析之网络请求。Volley 不仅仅对请求网络数据作了良好的封装，还封装了对图片的加载等操作，虽然比不上，不过可以满足我们的日常使用，从学习者的角度看看是怎么封装的。123#### 二、简单使用1. 使用```ImageRequest```加载图片，用法跟请求网络的用法差不多，只是">
<meta name="keywords" content="Volley">
<meta property="og:type" content="article">
<meta property="og:title" content="Volley 源码解析之图片请求">
<meta property="og:url" content="https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/index.html">
<meta property="og:site_name" content="哆啦A梦Doraemon">
<meta property="og:description" content="一、前言上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章Volley 源码解析之网络请求。Volley 不仅仅对请求网络数据作了良好的封装，还封装了对图片的加载等操作，虽然比不上，不过可以满足我们的日常使用，从学习者的角度看看是怎么封装的。123#### 二、简单使用1. 使用```ImageRequest```加载图片，用法跟请求网络的用法差不多，只是">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-03-05T15:46:57.778Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Volley 源码解析之图片请求">
<meta name="twitter:description" content="一、前言上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章Volley 源码解析之网络请求。Volley 不仅仅对请求网络数据作了良好的封装，还封装了对图片的加载等操作，虽然比不上，不过可以满足我们的日常使用，从学习者的角度看看是怎么封装的。123#### 二、简单使用1. 使用```ImageRequest```加载图片，用法跟请求网络的用法差不多，只是">
    
        <link rel="alternate" type="application/atom+xml" title="哆啦A梦Doraemon" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">哆啦A梦Doraemon</h5>
          <a href="mailto:wvisible@outlook.com" title="wvisible@outlook.com" class="mail">wvisible@outlook.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/wvisible" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://juejin.im/user/5853e9e98d6d8100659a8e7a" target="_blank" >
                <i class="icon icon-lg icon-link"></i>
                掘金
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Volley 源码解析之图片请求</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Volley 源码解析之图片请求</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-03-05T15:45:28.000Z" itemprop="datePublished" class="page-time">
  2020-03-05
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/源码解析/">源码解析</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#一、前言"><span class="post-toc-number">1.</span> <span class="post-toc-text">一、前言</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#四、总结"><span class="post-toc-number">2.</span> <span class="post-toc-text">四、总结</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#参考"><span class="post-toc-number">3.</span> <span class="post-toc-text">参考</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-Volley-源码解析之图片请求"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Volley 源码解析之图片请求</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-03-05 23:45:28" datetime="2020-03-05T15:45:28.000Z"  itemprop="datePublished">2020-03-05</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/源码解析/">源码解析</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章<a href="https://juejin.im/post/5c1c58b35188251f1f320e70" target="_blank" rel="noopener">Volley 源码解析之网络请求</a>。Volley 不仅仅对请求网络数据作了良好的封装，还封装了对图片的加载等操作，虽然比不上<figure class="highlight plain"><figcaption><span>，不过可以满足我们的日常使用，从学习者的角度看看是怎么封装的。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 二、简单使用</span><br><span class="line">1. 使用```ImageRequest```加载图片，用法跟请求网络的用法差不多，只是构造request的参数不太一样：</span><br></pre></td></tr></table></figure></p>
<pre><code> String imageUrl = &quot;https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;;
 RequestQueue queue = Volley.newRequestQueue(this);
 ImageRequest imageRequest = new ImageRequest(imageUrl,
                    response -&gt; imageView.setImageBitmap(response),
                    0, 0, ImageView.ScaleType.CENTER_CROP, Bitmap.Config.ARGB_8888,
                    error -&gt; {});
 queue.add(imageRequest);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    - 第一个参数是图片地址没啥说的</span><br><span class="line">    - 第二个参数是成功的回调，返回一个bitmap</span><br><span class="line">    - 第三和第四个参数则是图片的最大的高度和宽度，0为默认图片大小，如果填写的图片最大的高度和宽度小于图片的实际尺寸则会进行压缩</span><br><span class="line">    - 第五个值就是对图片进行边界缩放</span><br><span class="line">    - 第六个参数是图片的格式，常用的就是```RGB_565```和```ARGB_8888```，前者每个像素占2个字节，后者每个像素占4个字节，后者成像质量高，有alpha通道，如果使用的是jpg，不需要alpha通道则可以使用前者； 还有个```ARGB_4444```，不过已经废弃了，在4.4以后默认转成```ARGB_8888```， ```ALPHA_8```只有透明度，没有颜色值，一般很少使用</span><br><span class="line">    - 最后个参数就是错误的回调</span><br><span class="line">2. 使用```ImageLoader```加载图片</span><br></pre></td></tr></table></figure>
</code></pre><p>   String imageUrl = “<a href="https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;" target="_blank" rel="noopener">https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;</a>;<br>   RequestQueue queue = Volley.newRequestQueue(this);<br>   ImageLoader imageLoader = new ImageLoader(queue, new BitmapCache());<br>   ImageLoader.ImageListener imageListener = ImageLoader.getImageListener(imageView,<br>        R.mipmap.ic_launcher, R.mipmap.ic_launcher_round);<br>   imageLoader.get(imageUrl,<br>        imageListener, 0, 0);<br>   private class BitmapCache implements ImageLoader.ImageCache{<br>        private LruCache&lt;String, Bitmap&gt; lruCache;</p>
<pre><code>public BitmapCache() {
    int maxSize = 10 * 1024 * 1024;
    lruCache = new LruCache&lt;String, Bitmap&gt;(maxSize) {
        @Override
        protected int sizeOf(String key, Bitmap bitmap) {
            return bitmap.getRowBytes() * bitmap.getHeight();
        }
    };
}

@Override
public Bitmap getBitmap(String url) {
    return lruCache.get(url);
}

@Override
public void putBitmap(String url, Bitmap bitmap) {
    lruCache.put(url, bitmap);
}
</code></pre><p>   }<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 使用```NetworkImageView```加载图片</span><br></pre></td></tr></table></figure></p>
<p>   &lt;?xml version=”1.0” encoding=”utf-8”?&gt;<br>   &lt;android.support.constraint.ConstraintLayout<br>    xmlns:android=”<a href="http://schemas.android.com/apk/res/android&quot;" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android&quot;</a><br>    xmlns:tools=”<a href="http://schemas.android.com/tools&quot;" target="_blank" rel="noopener">http://schemas.android.com/tools&quot;</a><br>    xmlns:app=”<a href="http://schemas.android.com/apk/res-auto&quot;" target="_blank" rel="noopener">http://schemas.android.com/apk/res-auto&quot;</a><br>    android:layout_width=”match_parent”<br>    android:layout_height=”match_parent”<br>    tools:context=”.MainActivity”&gt;</p>
<pre><code>&lt;Button
    android:id=&quot;@+id/button&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_marginStart=&quot;8dp&quot;
    android:layout_marginTop=&quot;88dp&quot;
    android:layout_marginEnd=&quot;8dp&quot;
    android:text=&quot;Button&quot;
    app:layout_constraintEnd_toEndOf=&quot;parent&quot;
    app:layout_constraintStart_toStartOf=&quot;parent&quot;
    app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;

&lt;com.android.volley.toolbox.NetworkImageView
    android:id=&quot;@+id/imageView&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_marginStart=&quot;8dp&quot;
    android:layout_marginTop=&quot;32dp&quot;
    android:layout_marginEnd=&quot;8dp&quot;
    app:layout_constraintEnd_toEndOf=&quot;parent&quot;
    app:layout_constraintStart_toStartOf=&quot;parent&quot;
    app:layout_constraintTop_toBottomOf=&quot;@+id/textView&quot;
    tools:srcCompat=&quot;@tools:sample/avatars&quot; /&gt;
</code></pre><p>   &lt;/android.support.constraint.ConstraintLayout&gt;<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></p>
<pre><code>String imageUrl = &quot;https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;;
NetworkImageView networkImageView = findViewById(R.id.imageView);
networkImageView.setDefaultImageResId(R.mipmap.ic_launcher);
networkImageView.setErrorImageResId(R.mipmap.ic_launcher_round);
networkImageView.setImageUrl(imageUrl, imageLoader);
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#### 三、源码分析</span><br><span class="line">##### 一、 ImageRequest 分析</span><br><span class="line">首先我们分析```ImageRequest```，直接分析这个类，代码不多，直接继承```Request```，那么不用说跟上一篇我们分析的网络请求的```request```大体相同，不同的是这个是请求图片，如果我们需要自定义大小那么这里就对图片进行了裁剪以满足我们的大小：</span><br></pre></td></tr></table></figure>
<p>public class ImageRequest extends Request<bitmap> {<br>    //图片请求的超时时间，单位毫秒<br>    public static final int DEFAULT_IMAGE_TIMEOUT_MS = 1000;</bitmap></p>
<pre><code>//图片请求的默认重试次数
public static final int DEFAULT_IMAGE_MAX_RETRIES = 2;

//发生冲突时的默认重传延迟增加数，和TCP协议有关系，退避算法，短时间的重复请求失败还会是失败
public static final float DEFAULT_IMAGE_BACKOFF_MULT = 2f;

//对mListener加锁，保证线程安全，避免取消的时候同时执行分发
private final Object mLock = new Object();

@GuardedBy(&quot;mLock&quot;)
@Nullable
private Response.Listener&lt;Bitmap&gt; mListener;

private final Config mDecodeConfig;
private final int mMaxWidth;
private final int mMaxHeight;
private final ScaleType mScaleType;

//Bitmap 的同步解析锁，保证一个时间内只有一个Bitmap被加载到内存进行解析，避免多个同时解析oom
private static final Object sDecodeLock = new Object();


public ImageRequest(
        String url,
        Response.Listener&lt;Bitmap&gt; listener,
        int maxWidth,
        int maxHeight,
        ScaleType scaleType,
        Config decodeConfig,
        @Nullable Response.ErrorListener errorListener) {
    super(Method.GET, url, errorListener);
    setRetryPolicy(
            new DefaultRetryPolicy(
                    DEFAULT_IMAGE_TIMEOUT_MS,
                    DEFAULT_IMAGE_MAX_RETRIES,
                    DEFAULT_IMAGE_BACKOFF_MULT));
    mListener = listener;
    mDecodeConfig = decodeConfig;
    mMaxWidth = maxWidth;
    mMaxHeight = maxHeight;
    mScaleType = scaleType;
}

@Deprecated
public ImageRequest(
        String url,
        Response.Listener&lt;Bitmap&gt; listener,
        int maxWidth,
        int maxHeight,
        Config decodeConfig,
        Response.ErrorListener errorListener) {
    this(
            url,
            listener,
            maxWidth,
            maxHeight,
            ScaleType.CENTER_INSIDE,
            decodeConfig,
            errorListener);
}

@Override
public Priority getPriority() {
    return Priority.LOW;
}

//根据ScaleType设置图片大小
private static int getResizedDimension(
        int maxPrimary,
        int maxSecondary,
        int actualPrimary,
        int actualSecondary,
        ScaleType scaleType) {

    // 如果主要值和次要的值为0，就返回实际值，如果我们计算宽度的期望值，
    那么主要值就是宽度，高度就是次要值，反之亦然
    if ((maxPrimary == 0) &amp;&amp; (maxSecondary == 0)) {
        return actualPrimary;
    }

    // 如果为ScaleType.FIT_XY，填充整个矩形，忽略比值；
    即如果主要的值为0则返回实际值，否则返回传入的值
    if (scaleType == ScaleType.FIT_XY) {
        if (maxPrimary == 0) {
            return actualPrimary;
        }
        return maxPrimary;
    }

    // 如果主要的值为0，则通过比例值计算出主要的值返回
    if (maxPrimary == 0) {
        double ratio = (double) maxSecondary / (double) actualSecondary;
        return (int) (actualPrimary * ratio);
    }

    // 次要的值为0，下面的比例调整就是多余的，那么直接返回主要的值，
    if (maxSecondary == 0) {
        return maxPrimary;
    }

    // 图片真实尺寸大小的比例，通过这个比例我们可以计算出次要的最大值，通
    过计算出的值和我们传递进来的值做比较
    double ratio = (double) actualSecondary / (double) actualPrimary;
    int resized = maxPrimary;

    // 如果是ScaleType.CENTER_CROP，填充整个矩形，保持长宽比，这里的宽高值相等或者大于传入的宽高尺寸
    if (scaleType == ScaleType.CENTER_CROP) {
        // 小于传入的次要最大值，则返回通过比例计算的最大值，这里相当于把resized 值增大
        if ((resized * ratio) &lt; maxSecondary) {
            resized = (int) (maxSecondary / ratio);
        }
        return resized;
    }
    //  其它scaleType值，如果计算的值大于次要值，那么resized 值减小
    if ((resized * ratio) &gt; maxSecondary) {
        resized = (int) (maxSecondary / ratio);
    }
    return resized;
}

//解析response
@Override
protected Response&lt;Bitmap&gt; parseNetworkResponse(NetworkResponse response) {
    synchronized (sDecodeLock) {
        try {
            return doParse(response);
        } catch (OutOfMemoryError e) {
            VolleyLog.e(&quot;Caught OOM for %d byte image, url=%s&quot;, response.data.length, getUrl());
            return Response.error(new ParseError(e));
        }
    }
}

//解析的地方
private Response&lt;Bitmap&gt; doParse(NetworkResponse response) {
    byte[] data = response.data;
    BitmapFactory.Options decodeOptions = new BitmapFactory.Options();
    Bitmap bitmap = null;
    //如果最大宽度和最大高度都传入的为0，直接解析成一个bitmap
    if (mMaxWidth == 0 &amp;&amp; mMaxHeight == 0) {
        decodeOptions.inPreferredConfig = mDecodeConfig;
        bitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);
    } else {
        //如果要调整图片的大小，首先获取图片真实的尺寸大小，首先设置inJustDecodeBounds为true，不加载到内存但是可以获取图像的宽高
        decodeOptions.inJustDecodeBounds = true;
        BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);
        int actualWidth = decodeOptions.outWidth;
        int actualHeight = decodeOptions.outHeight;

        // 计算我们想要的尺寸
        int desiredWidth =
                getResizedDimension(
                        mMaxWidth, mMaxHeight, actualWidth, actualHeight, mScaleType);
        int desiredHeight =
                getResizedDimension(
                        mMaxHeight, mMaxWidth, actualHeight, actualWidth, mScaleType);

        // 计算出采样值，2的倍数
        decodeOptions.inJustDecodeBounds = false;
        decodeOptions.inSampleSize =
                findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight);
        Bitmap tempBitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);

        // 如果采样率计算出的值为1的话，那么就没有尺寸压缩，tempBitmap的宽高值就是图片的
        真实值，那么这里就需要缩放到满足我们上面计算出来的值
        if (tempBitmap != null
                &amp;&amp; (tempBitmap.getWidth() &gt; desiredWidth
                        || tempBitmap.getHeight() &gt; desiredHeight)) {
            bitmap = Bitmap.createScaledBitmap(tempBitmap, desiredWidth, desiredHeight, true);
            tempBitmap.recycle();
        } else {
            bitmap = tempBitmap;
        }
    }

    //回调给用户
    if (bitmap == null) {
        return Response.error(new ParseError(response));
    } else {
        return Response.success(bitmap, HttpHeaderParser.parseCacheHeaders(response));
    }
}

@Override
public void cancel() {
    super.cancel();
    synchronized (mLock) {
        mListener = null;
    }
}

@Override
protected void deliverResponse(Bitmap response) {
    Response.Listener&lt;Bitmap&gt; listener;
    synchronized (mLock) {
        listener = mListener;
    }
    if (listener != null) {
        listener.onResponse(response);
    }
}

//计算合适的采样率
@VisibleForTesting
static int findBestSampleSize(
        int actualWidth, int actualHeight, int desiredWidth, int desiredHeight) {
    double wr = (double) actualWidth / desiredWidth;
    double hr = (double) actualHeight / desiredHeight;
    double ratio = Math.min(wr, hr);
    float n = 1.0f;
    while ((n * 2) &lt;= ratio) {
        n *= 2;
    }

    return (int) n;
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关键部分我都写了注释，下面我们看主要流程，对 ```Bitmap```的高效加载。首先我们获取到返回的```response```进行解析，然后根据传递的期望宽高以及图片格式生成```Bitmap```返回，对于我们传入的宽高会按比例裁剪，不是直接使用裁剪到合适的值，不然会有拉伸，最后再回调给用户。</span><br><span class="line">##### 二、ImageLoader 分析</span><br><span class="line">我们直接先看构造方法，看所有的关键地方，不重要的就不分析了</span><br></pre></td></tr></table></figure>
<p>public ImageLoader(RequestQueue queue, ImageCache imageCache) {<br>        mRequestQueue = queue;<br>        mCache = imageCache;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">没啥说的，就是赋值，一个是请求队列，一个是图片缓存的自己实现，这个是在内部把请求添加到请求队列，所以直接传递进去，第二个参数缓存，我们可以自己实现，一般使用```LruCache```实现。</span><br><span class="line">接下来我们接着看```getImageListener```:</span><br></pre></td></tr></table></figure></p>
<p>public static ImageListener getImageListener(<br>            final ImageView view, final int defaultImageResId, final int errorImageResId) {<br>        return new ImageListener() {<br>            @Override<br>            public void onErrorResponse(VolleyError error) {<br>                if (errorImageResId != 0) {<br>                    view.setImageResource(errorImageResId);<br>                }<br>            }</p>
<pre><code>    @Override
    public void onResponse(ImageContainer response, boolean isImmediate) {
        if (response.getBitmap() != null) {
            view.setImageBitmap(response.getBitmap());
        } else if (defaultImageResId != 0) {
            view.setImageResource(defaultImageResId);
        }
    }
};
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个方法比较简单，就是传入我们的```image view```进行设置图像，然后分别提供一个默认和请求失败的占位图，刚开始设置的时候还没有请求到```Bitmap```,所以最开始设置的事默认图。  </span><br><span class="line">首先看两个变量，后面需要用到：</span><br></pre></td></tr></table></figure></p>
<p>//相同URL正在请求中存储的map<br>private final HashMap&lt;String, BatchedImageRequest&gt; mInFlightRequests = new HashMap&lt;&gt;();<br>//相同URL请求结果存储的map<br>private final HashMap&lt;String, BatchedImageRequest&gt; mBatchedResponses = new HashMap&lt;&gt;();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来我们看看关键的一步</span><br></pre></td></tr></table></figure></p>
<pre><code>@MainThread
public ImageContainer get(
        String requestUrl,
        ImageListener imageListener,
        int maxWidth,
        int maxHeight,
        ScaleType scaleType) {

    // 检查当前线程是否在主线程，只满足从主线程发起的请求
    Threads.throwIfNotOnMainThread();

    //根据url、width、height、scaleType拼接的缓存key
    final String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight, scaleType);

    // 从缓存中查找bitmap
    Bitmap cachedBitmap = mCache.getBitmap(cacheKey);
    if (cachedBitmap != null) {
        // 有相应的缓存那么则返回一个ImageContainer，包括其中的bitmap
        ImageContainer container =
                new ImageContainer(
                        cachedBitmap, requestUrl, /* cacheKey= */ null, /* listener= */ null);
        // 直接调用onResponse，把bitmap设置给imageView
        imageListener.onResponse(container, true);
        return container;
    }

    // 缓存中没有查找到，那么我们直接获取，首先new一个ImageContainer
    ImageContainer imageContainer =
            new ImageContainer(null, requestUrl, cacheKey, imageListener);

    // 更新调用的地方，使用默认的图片先设置
    imageListener.onResponse(imageContainer, true);
    //检查是否有相同的cacheKey请求正在运行
    BatchedImageRequest request = mInFlightRequests.get(cacheKey);
    if (request != null) {
        // 如果相同的请求正在运行，那么不需要重复请求，只需要将这个实例化
        的imageContainer添加到BatchedImageRequest的mContainers中，然后请
        求结束后对所有添加到集合中的imageContainer依次回调
        request.addContainer(imageContainer);
        return imageContainer;
    }

    // 如果这个请求尚未执行，发送一个新的请求到网络上，这里才是执行请求的地方
    Request&lt;Bitmap&gt; newRequest =
            makeImageRequest(requestUrl, maxWidth, maxHeight, scaleType, cacheKey);
    //添加到请求队列
    mRequestQueue.add(newRequest);
    //添加到正在请求的集合中
    mInFlightRequests.put(cacheKey, new BatchedImageRequest(newRequest, imageContainer));
    return imageContainer;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个方法是一个重点，主要流程是首先看看缓存里面有没有缓存的```Bitmap```,来源于我们自己实现的缓存策略，我们使用的是内存缓存的话这里就是一级缓存；如果有直接调用```onResponse```方法设置图片，如果没有，首先实例化``ImageContainer``，涉及到了几个类，接下来就看是否有相同的请求，如果有则添加到一个集合中，请求下来统一处理；如果没有那么则构造一个```Request```，通过```RequestQueue```去获取网络图片，可能是网络请求也有可能是磁盘缓存的，这里就是二级缓存，然后添加到正在请求的集合中。  </span><br><span class="line">接下来看一看```ImageContainer```这个类,这个类就是图像请求的一个容器对象</span><br></pre></td></tr></table></figure></p>
<p>public class ImageContainer {<br>        //imageview加载的Bitmap<br>        private Bitmap mBitmap;</p>
<pre><code>    //图片加载成功和失败的监听
    private final ImageListener mListener;

    //缓存的key
    private final String mCacheKey;

    //请求指定的URL
    private final String mRequestUrl;

    public ImageContainer(
            Bitmap bitmap, String requestUrl, String cacheKey, ImageListener listener) {
        mBitmap = bitmap;
        mRequestUrl = requestUrl;
        mCacheKey = cacheKey;
        mListener = listener;
    }

    //取消请求
    @MainThread
    public void cancelRequest() {
        Threads.throwIfNotOnMainThread();

        if (mListener == null) {
            return;
        }
        //从正在请求的集合获取一个批处理request
        BatchedImageRequest request = mInFlightRequests.get(mCacheKey);
        if (request != null) {
            //如果取到request，那么首先从mContainers移除当前的这个ImageContainer，
            如果移除后集合为空一个ImageContainer也没有了，那么则取消掉这个请求并返回 true
            boolean canceled = request.removeContainerAndCancelIfNecessary(this);
            if (canceled) {
                //取消了请求则从正在请求的集合中移除BatchedImageRequest
                mInFlightRequests.remove(mCacheKey);
            }
        } else {
            // 如果已经请求完成添加到批处理中准备处理分发
            request = mBatchedResponses.get(mCacheKey);
            if (request != null) {
                //首先从mContainers移除当前的这个ImageContainer
                request.removeContainerAndCancelIfNecessary(this);
                if (request.mContainers.size() == 0) {
                    //如果集合中一个ImageContainer都没有，则从等待处理的
                    response中移除掉这个BatchedImageRequest
                    mBatchedResponses.remove(mCacheKey);
                }
            }
        }
    }

    public Bitmap getBitmap() {
        return mBitmap;
    }

    /** Returns the requested URL for this container. */
    public String getRequestUrl() {
        return mRequestUrl;
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个类主要包含是一个图片的容器对象，里面包括了bitmap、监听器、缓存的key以及请求的URL，每个请求都会先组装这个类，然后添加到一个BatchedImageRequest的mContainers中  </span><br><span class="line">接下来我们看看真正发起请求的地方：</span><br></pre></td></tr></table></figure>
<p>protected Request<bitmap> makeImageRequest(<br>            String requestUrl,<br>            int maxWidth,<br>            int maxHeight,<br>            ScaleType scaleType,<br>            final String cacheKey) {<br>        return new ImageRequest(<br>                requestUrl,<br>                new Listener<bitmap>() {<br>                    @Override<br>                    public void onResponse(Bitmap response) {<br>                        onGetImageSuccess(cacheKey, response);<br>                    }<br>                },<br>                maxWidth,<br>                maxHeight,<br>                scaleType,<br>                Config.RGB_565,<br>                new ErrorListener() {<br>                    @Override<br>                    public void onErrorResponse(VolleyError error) {<br>                        onGetImageError(cacheKey, error);<br>                    }<br>                });<br>    }</bitmap></bitmap></p>
<pre><code>//图片请求成功
protected void onGetImageSuccess(String cacheKey, Bitmap response) {
    // 添加到以及缓存中
    mCache.putBitmap(cacheKey, response);

    // 从正在运行的请求列表中删除这个请求
    BatchedImageRequest request = mInFlightRequests.remove(cacheKey);

    if (request != null) {
        //更新BatchedImageRequest的bitmap
        request.mResponseBitmap = response;
        //发送一个批处理请求，将多个相同的请求进行分发
        batchResponse(cacheKey, request);
    }
}

//图片请求失败，跟上面成功处理大致类似
protected void onGetImageError(String cacheKey, VolleyError error) {
    BatchedImageRequest request = mInFlightRequests.remove(cacheKey);

    if (request != null) {
        //设置这个请求的错误
        request.setError(error);

        batchResponse(cacheKey, request);
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里执行网络请求还是调用我们上面分析的```ImageRequest```方法，而且在回调中分别对成功和失败在进行了一次处理。  </span><br><span class="line">接下来我们看看这个批量处理图片的```batchResponse```方法：</span><br></pre></td></tr></table></figure>
<p>private void batchResponse(String cacheKey, BatchedImageRequest request) {<br>        //首先添加到这个map中，表明现在进入了批处理中<br>        mBatchedResponses.put(cacheKey, request);<br>        // 如果还没有进行处理，那么我们则开始一个新的任务<br>        if (mRunnable == null) {<br>            mRunnable =<br>                    new Runnable() {<br>                        @Override<br>                        public void run() {<br>                            //循环mBatchedResponses的所有值<br>                            for (BatchedImageRequest bir : mBatchedResponses.values()) {<br>                                //循环BatchedImageRequest的mContainers的值<br>                                for (ImageContainer container : bir.mContainers) {<br>                                    //如果有的请求取消了，在收到请求的<br>                                    响应后还没有分发之前那么跳过循环下一个<br>                                    if (container.mListener == null) {<br>                                        continue;<br>                                    }<br>                                    // 如果不是请求错误则调用onResponse<br>                                    if (bir.getError() == null) {<br>                                        container.mBitmap = bir.mResponseBitmap;<br>                                        container.mListener.onResponse(container, false);<br>                                    } else {<br>                                       //请求报错则调用onErrorResponse设置一个错误的图片展示 container.mListener.onErrorResponse(bir.getError());<br>                                    }<br>                                }<br>                            }<br>                            //清除所有响应的BatchedImageRequest<br>                            mBatchedResponses.clear();<br>                            //置为null，通过是否为null判断当前是否正在处理<br>                            mRunnable = null;<br>                        }<br>                    };<br>            // 将这个post投递到主线程去执行<br>            mHandler.postDelayed(mRunnable, mBatchResponseDelayMs);<br>        }<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这段代码也很简单，不过有个地方有个比较奇怪的地方，为啥是使用双层循环，为啥不直接使用内层的循环；个人认为有可能是这样，首先这个```mBatchedResponses```刚开始进来添加了相同的key的请求的```BatchedImageRequest```，那么存在正在分发的时候又有不同的key的请求进来了，因为正在处理的时候```runnable```不为```null```，则后续添加的有可能不能分发，所以要遍历这个map中所有的请求。</span><br><span class="line">##### 三、 NetworkImageView 分析</span><br><span class="line">这是一个继承```ImageView```的自定义```view```：</span><br></pre></td></tr></table></figure></p>
<p>public class NetworkImageView extends ImageView {<br>    private String mUrl;<br>    //设置默认的图片<br>    private int mDefaultImageId;<br>    //设置请求错误的时候显示的图片<br>    private int mErrorImageId;</p>
<pre><code>private ImageLoader mImageLoader;
private ImageContainer mImageContainer;

public NetworkImageView(Context context) {
    this(context, null);
}

public NetworkImageView(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public NetworkImageView(Context context, AttributeSet attrs, int defStyle) {
    super(context, attrs, defStyle);
}

//这个方法就是设置我们的url
@MainThread
public void setImageUrl(String url, ImageLoader imageLoader) {
    Threads.throwIfNotOnMainThread();
    mUrl = url;
    mImageLoader = imageLoader;
    // 我们的url可能已经更改，那么我们则需要判断是否需要加载
    loadImageIfNecessary(/* isInLayoutPass= */ false);
}

public void setDefaultImageResId(int defaultImage) {
    mDefaultImageId = defaultImage;
}

public void setErrorImageResId(int errorImage) {
    mErrorImageId = errorImage;
}

//如果视图尚未加载图像，那么我们则去加载它
void loadImageIfNecessary(final boolean isInLayoutPass) {
    int width = getWidth();
    int height = getHeight();
    ScaleType scaleType = getScaleType();

    boolean wrapWidth = false, wrapHeight = false;
    if (getLayoutParams() != null) {
        wrapWidth = getLayoutParams().width == LayoutParams.WRAP_CONTENT;
        wrapHeight = getLayoutParams().height == LayoutParams.WRAP_CONTENT;
    }

    //如果不知道视图的大小并且不是WRAP_CONTENT就暂停加载
    boolean isFullyWrapContent = wrapWidth &amp;&amp; wrapHeight;
    if (width == 0 &amp;&amp; height == 0 &amp;&amp; !isFullyWrapContent) {
        return;
    }

    // 如果url为空的话则请取消所有的请求，包括以前的请求，假如请求两次
    最后次的url为null，这时候还没请求完成，肯定以最后次为准
    if (TextUtils.isEmpty(mUrl)) {
        if (mImageContainer != null) {
            mImageContainer.cancelRequest();
            mImageContainer = null;
        }
        //设置默认的图片
        setDefaultImageOrNull();
        return;
    }

    // 检查是否取消以前的请求
    if (mImageContainer != null &amp;&amp; mImageContainer.getRequestUrl() != null) {
        if (mImageContainer.getRequestUrl().equals(mUrl)) {
            // 如果请求和以前相同则没必要再次请求
            return;
        } else {
            // 如果存在正在请求的url并且请求url不同，那么取消正在请求的url
            mImageContainer.cancelRequest();
            setDefaultImageOrNull();
        }
    }

    // 计算最大宽高，如果设置WRAP_CONTENT那么则图片是多大就是多大，其它
    情况则直接使用布局的宽高，如果设置了具体的值就有可能裁剪
    int maxWidth = wrapWidth ? 0 : width;
    int maxHeight = wrapHeight ? 0 : height;

    // 使用ImageLoader来请求图像，上面已经分析了，最终返回一个ImageContainer
    mImageContainer =
            mImageLoader.get(
                    mUrl,
                    new ImageListener() {
                        @Override
                        public void onErrorResponse(VolleyError error) {
                            if (mErrorImageId != 0) {
                                setImageResource(mErrorImageId);
                            }
                        }

                        @Override
                        public void onResponse(
                                final ImageContainer response, boolean isImmediate) {
                            //isImmediate：在网络请求过程中调用的时候为true，可以用来
                            区分是否是取的缓存图像还是网络图像加载
                            isInLayoutPass：如果通过onLayout调用此函数，
                            则为true，否则为false
                            这个if的意思就是，如果是缓存图像并且是在布局中调用那么则发送
                            到主线程并延迟设置图像，因为可能多次调用
                            if (isImmediate &amp;&amp; isInLayoutPass) {
                                post(
                                        new Runnable() {
                                            @Override
                                            public void run() {
                                                onResponse(response, /* isImmediate= */ false);
                                            }
                                        });
                                return;
                            }
                            //请求成功加载图片
                            if (response.getBitmap() != null) {
                                setImageBitmap(response.getBitmap());
                            } else if (mDefaultImageId != 0) {
                                setImageResource(mDefaultImageId);
                            }
                        }
                    },
                    maxWidth,
                    maxHeight,
                    scaleType);
}

private void setDefaultImageOrNull() {
    if (mDefaultImageId != 0) {
        setImageResource(mDefaultImageId);
    } else {
        setImageBitmap(null);
    }
}

@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    super.onLayout(changed, left, top, right, bottom);
    loadImageIfNecessary(/* isInLayoutPass= */ true);
}

//当imageview销毁的时候，取消请求并且清除ImageContainer以便重新加载图像
@Override
protected void onDetachedFromWindow() {
    if (mImageContainer != null) {
        // If the view was bound to an image request, cancel it and clear
        // out the image from the view.
        mImageContainer.cancelRequest();
        setImageBitmap(null);
        // also clear out the container so we can reload the image if necessary.
        mImageContainer = null;
    }
    super.onDetachedFromWindow();
}

@Override
protected void drawableStateChanged() {
    super.drawableStateChanged();
    invalidate();
}
</code></pre><p>}</p>
<p><code>这个类没啥好分析的，就是利用前两个类来完成请求，只不过方便的是直接在xml中使用，使用</code>ImageLoader<code>请求的</code>Bitmap<code>设置给</code>NetworkImageView<code>`</code>。</p>
<h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>三种不同的方式都可以完成图片的加载，不过后面的方式都比较依赖前面的<code>ImageRequest</code>，毕竟还是要这个类去完成网络请求操作；在使用中，根据不同的场景选择不同的方式使用。不过我建议使用<code>ImageLoader</code>来加载图片，可以自己设置缓存，两级缓存，一级内存缓存，一级<code>volley</code>请求时候的磁盘缓存。总体来讲封装的很不错，对一些细节处理的比较好，比如相同的请求、图片的裁剪等，值得我们学习的地方很多。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/guolin_blog/article/details/17482165" target="_blank" rel="noopener">Android Volley完全解析(二)，使用Volley加载网络图片</a><br><a href="https://github.com/wangzhengyi/Volley/blob/master/README.md" target="_blank" rel="noopener">Volley 源码解析</a></p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-03-05T15:46:57.778Z" itemprop="dateUpdated">2020-03-05 23:46:57</time>
</span><br>


        
        如需转发请注明出处：<a href="/2020/03/05/Volley-源码解析之图片请求/" target="_blank" rel="external">https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/</a>
        
    </div>
    <footer>
        <a href="https://wvisible.github.io">
            <img src="/img/avatar.jpg" alt="哆啦A梦Doraemon">
            哆啦A梦Doraemon
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volley/">Volley</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/&title=《Volley 源码解析之图片请求》 — 哆啦A梦Doraemon&pic=https://wvisible.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/&title=《Volley 源码解析之图片请求》 — 哆啦A梦Doraemon&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Volley 源码解析之图片请求》 — 哆啦A梦Doraemon&url=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/&via=https://wvisible.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/03/05/Volley-源码解析之缓存机制/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Volley 源码解析之缓存机制</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/03/05/Volley-源码解析之网络请求/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Volley 源码解析之网络请求</h4>
      </a>
    </div>
  
</nav>



    











</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>哆啦A梦Doraemon &copy; 2015 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/&title=《Volley 源码解析之图片请求》 — 哆啦A梦Doraemon&pic=https://wvisible.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/&title=《Volley 源码解析之图片请求》 — 哆啦A梦Doraemon&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Volley 源码解析之图片请求》 — 哆啦A梦Doraemon&url=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/&via=https://wvisible.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACrklEQVR42u3aSU4DMRAF0Nz/0rBGKPGvwSFIr1co6cGvkezKLz8e8fEVHK+vffb372ufnfP6KaMDDw8Pb3Xor8/pDejZtfndCi8aDw8P7xqvOohkcp8vHpNz8PDw8D6Tl0zoyfnVu+Hh4eH9R16OSZaNKgkPDw/vE3h53JAHu0mIkMOuZy14eHh4nV5VoVz+27+v9Pfw8PDwljYEVIPaySSexBOF0eLh4eFd4FUj2l5Q29t01SuX8fDw8N7Jy8Pc3Wm92vRKnouHh4d3jzcPUicLST7QZMvXobOHh4eHt8pLBjqPd5PiuNoeO7wyPDw8vGu8HiMPeXsFev6Ky107PDw8vPGmgXwKrpbC1SVk/oIOKTUeHh7eBV4+x1Y/TwrlyRISJS54eHh4S7xkkp0MdFIoL8Dw8PDwVnnVQnke4/baaXkB/eMTPDw8vAu8arO/V2r3wo5q0+vwsvDw8PBWeT1YL1bII9rkzKh8x8PDw1vlJcOas2+U5tELwsPDw7vG6229mkS61e1W1Y0IP7IWPDw8vFVeNXKtHtX5Ob9P4bXi4eHhXeDlTa/e3oRqdJtvPqi26/Dw8PB2ecngtoaeLCeTPBYPDw/vHq+3+SkJDnrU3uJxKKDx8PDwVnlzcN6UKjSuWk+J1kA8PDy8Jd5WaZsX0PPIeGG9wsPDw1vi9VpN+TnVTVq9WBkPDw/v/bzXgWlyVTKJL0z6yX3w8PDwVnmTTVT3tiDkjMO3eHh4eBd4k1/01YI4jyTyu82bdnh4eHg9XnUxqIazkzZb8oIOz8XDw8O7xuu1u/Kgtlqg56vZIUbBw8PD+2Be7/NeA+wPFgY8PDy88SCqEWq+MOSRR/QPwMPDw7vGyyOG5Nt8KNW4oRzp4uHh4V3gVX/wF8rZVuurWTrP+3t4eHh4Z94352Z9gmmqauoAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '哆啦A梦Doraemon';
            clearTimeout(titleTime);
        } else {
            document.title = '哆啦A梦Doraemon';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
