<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>Volley 源码解析之图片请求 | 哆啦A梦Doraemon | So we beat on, boats against the current, borne back ceaselessly into the past.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#1FA67A">
    
    
    <meta name="keywords" content="Volley">
    <meta name="description" content="一、前言上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章Volley 源码解析之网络请求。Volley 不仅仅对请求网络数据作了良好的封装，还封装了对图片的加载等操作，虽然比不上 Glide、Fresco，不过可以满足我们的日常使用，从学习者的角度看看是怎么封装的。上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文">
<meta name="keywords" content="Volley">
<meta property="og:type" content="article">
<meta property="og:title" content="Volley 源码解析之图片请求">
<meta property="og:url" content="https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/index.html">
<meta property="og:site_name" content="哆啦A梦Doraemon">
<meta property="og:description" content="一、前言上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章Volley 源码解析之网络请求。Volley 不仅仅对请求网络数据作了良好的封装，还封装了对图片的加载等操作，虽然比不上 Glide、Fresco，不过可以满足我们的日常使用，从学习者的角度看看是怎么封装的。上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-03-06T08:42:03.273Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Volley 源码解析之图片请求">
<meta name="twitter:description" content="一、前言上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章Volley 源码解析之网络请求。Volley 不仅仅对请求网络数据作了良好的封装，还封装了对图片的加载等操作，虽然比不上 Glide、Fresco，不过可以满足我们的日常使用，从学习者的角度看看是怎么封装的。上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文">
    
        <link rel="alternate" type="application/atom+xml" title="哆啦A梦Doraemon" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">哆啦A梦Doraemon</h5>
          <a href="mailto:wvisible@outlook.com" title="wvisible@outlook.com" class="mail">wvisible@outlook.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/source/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/source/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/wvisible" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://juejin.im/user/5853e9e98d6d8100659a8e7a" target="_blank" >
                <i class="icon icon-lg icon-link"></i>
                掘金
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Volley 源码解析之图片请求</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Volley 源码解析之图片请求</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-03-05T15:45:28.000Z" itemprop="datePublished" class="page-time">
  2020-03-05
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/源码解析/">源码解析</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#一、前言"><span class="post-toc-number">1.</span> <span class="post-toc-text">一、前言</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#二、简单使用"><span class="post-toc-number">2.</span> <span class="post-toc-text">二、简单使用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#三、源码分析"><span class="post-toc-number">3.</span> <span class="post-toc-text">三、源码分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#一、-ImageRequest-分析"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">一、 ImageRequest 分析</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#二、ImageLoader-分析"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">二、ImageLoader 分析</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#三、-NetworkImageView-分析"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">三、 NetworkImageView 分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#四、总结"><span class="post-toc-number">4.</span> <span class="post-toc-text">四、总结</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#参考"><span class="post-toc-number">5.</span> <span class="post-toc-text">参考</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-Volley-源码解析之图片请求"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Volley 源码解析之图片请求</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-03-05 23:45:28" datetime="2020-03-05T15:45:28.000Z"  itemprop="datePublished">2020-03-05</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/源码解析/">源码解析</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章<a href="https://juejin.im/post/5c1c58b35188251f1f320e70" target="_blank" rel="noopener">Volley 源码解析之网络请求</a>。Volley 不仅仅对请求网络数据作了良好的封装，还封装了对图片的加载等操作，虽然比不上 <code>Glide</code>、<code>Fresco</code>，不过可以满足我们的日常使用，从学习者的角度看看是怎么封装的。<br>上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章<a href="https://juejin.im/post/5c1c58b35188251f1f320e70" target="_blank" rel="noopener">Volley 源码解析之网络请求</a>。Volley 不仅仅对请求网络数据作了良好的封装，还封装了对图片的加载等操作，虽然比不上 <code>Glide</code>、<code>Fresco</code>，不过可以满足我们的日常使用，从学习者的角度看看是怎么封装的。</p>
<h4 id="二、简单使用"><a href="#二、简单使用" class="headerlink" title="二、简单使用"></a>二、简单使用</h4><ol>
<li><p>使用 <code>ImageRequest</code> 加载图片，用法跟请求网络的用法差不多，只是构造request的参数不太一样：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String imageUrl = &quot;https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;;</span><br><span class="line">RequestQueue queue = Volley.newRequestQueue(this);</span><br><span class="line">ImageRequest imageRequest = new ImageRequest(imageUrl,</span><br><span class="line">                   response -&gt; imageView.setImageBitmap(response),</span><br><span class="line">                   0, 0, ImageView.ScaleType.CENTER_CROP, Bitmap.Config.ARGB_8888,</span><br><span class="line">                   error -&gt; &#123;&#125;);</span><br><span class="line">queue.add(imageRequest);</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数是图片地址没啥说的</li>
<li>第二个参数是成功的回调，返回一个bitmap</li>
<li>第三和第四个参数则是图片的最大的高度和宽度，0为默认图片大小，如果填写的图片最大的高度和宽度小于图片的实际尺寸则会进行压缩</li>
<li>第五个值就是对图片进行边界缩放</li>
<li>第六个参数是图片的格式，常用的就是 <code>RGB_565</code> 和 <code>ARGB_8888</code>，前者每个像素占2个字节，后者每个像素占4个字节，后者成像质量高，有alpha通道，如果使用的是jpg，不需要alpha通道则可以使用前者； 还有个 <code>ARGB_4444</code>，不过已经废弃了，在4.4以后默认转成 <code>ARGB_8888</code>， <code>ALPHA_8</code> 只有透明度，没有颜色值，一般很少使用</li>
<li>最后个参数就是错误的回调</li>
</ul>
</li>
<li><p>使用 <code>ImageLoader</code> 加载图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">String imageUrl = &quot;https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;;</span><br><span class="line">RequestQueue queue = Volley.newRequestQueue(this);</span><br><span class="line">ImageLoader imageLoader = new ImageLoader(queue, new BitmapCache());</span><br><span class="line">ImageLoader.ImageListener imageListener = ImageLoader.getImageListener(imageView, </span><br><span class="line">     R.mipmap.ic_launcher, R.mipmap.ic_launcher_round);</span><br><span class="line">imageLoader.get(imageUrl,</span><br><span class="line">     imageListener, 0, 0);</span><br><span class="line">private class BitmapCache implements ImageLoader.ImageCache&#123;</span><br><span class="line">     private LruCache&lt;String, Bitmap&gt; lruCache;</span><br><span class="line"></span><br><span class="line">     public BitmapCache() &#123;</span><br><span class="line">         int maxSize = 10 * 1024 * 1024;</span><br><span class="line">         lruCache = new LruCache&lt;String, Bitmap&gt;(maxSize) &#123;</span><br><span class="line">             @Override</span><br><span class="line">             protected int sizeOf(String key, Bitmap bitmap) &#123;</span><br><span class="line">                 return bitmap.getRowBytes() * bitmap.getHeight();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public Bitmap getBitmap(String url) &#123;</span><br><span class="line">         return lruCache.get(url);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void putBitmap(String url, Bitmap bitmap) &#123;</span><br><span class="line">         lruCache.put(url, bitmap);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>NetworkImageView</code> 加载图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout</span><br><span class="line"> xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line"> xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line"> xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line"> android:layout_width=&quot;match_parent&quot;</span><br><span class="line"> android:layout_height=&quot;match_parent&quot;</span><br><span class="line"> tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line"> &lt;Button</span><br><span class="line">     android:id=&quot;@+id/button&quot;</span><br><span class="line">     android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_marginStart=&quot;8dp&quot;</span><br><span class="line">     android:layout_marginTop=&quot;88dp&quot;</span><br><span class="line">     android:layout_marginEnd=&quot;8dp&quot;</span><br><span class="line">     android:text=&quot;Button&quot;</span><br><span class="line">     app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">     app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">     app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line"> &lt;com.android.volley.toolbox.NetworkImageView</span><br><span class="line">     android:id=&quot;@+id/imageView&quot;</span><br><span class="line">     android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_marginStart=&quot;8dp&quot;</span><br><span class="line">     android:layout_marginTop=&quot;32dp&quot;</span><br><span class="line">     android:layout_marginEnd=&quot;8dp&quot;</span><br><span class="line">     app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">     app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">     app:layout_constraintTop_toBottomOf=&quot;@+id/textView&quot;</span><br><span class="line">     tools:srcCompat=&quot;@tools:sample/avatars&quot; /&gt;</span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String imageUrl = &quot;https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;;</span><br><span class="line">NetworkImageView networkImageView = findViewById(R.id.imageView);</span><br><span class="line">networkImageView.setDefaultImageResId(R.mipmap.ic_launcher);</span><br><span class="line">networkImageView.setErrorImageResId(R.mipmap.ic_launcher_round);</span><br><span class="line">networkImageView.setImageUrl(imageUrl, imageLoader);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h4><h5 id="一、-ImageRequest-分析"><a href="#一、-ImageRequest-分析" class="headerlink" title="一、 ImageRequest 分析"></a>一、 ImageRequest 分析</h5><p>首先我们分析 <code>ImageRequest</code>，直接分析这个类，代码不多，直接继承 <code>Request</code>，那么不用说跟上一篇我们分析的网络请求的<code>request</code> 大体相同，不同的是这个是请求图片，如果我们需要自定义大小那么这里就对图片进行了裁剪以满足我们的大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line">public class ImageRequest extends Request&lt;Bitmap&gt; &#123;</span><br><span class="line">    //图片请求的超时时间，单位毫秒</span><br><span class="line">    public static final int DEFAULT_IMAGE_TIMEOUT_MS = 1000;</span><br><span class="line"></span><br><span class="line">    //图片请求的默认重试次数</span><br><span class="line">    public static final int DEFAULT_IMAGE_MAX_RETRIES = 2;</span><br><span class="line"></span><br><span class="line">    //发生冲突时的默认重传延迟增加数，和TCP协议有关系，退避算法，短时间的重复请求失败还会是失败</span><br><span class="line">    public static final float DEFAULT_IMAGE_BACKOFF_MULT = 2f;</span><br><span class="line"></span><br><span class="line">    //对mListener加锁，保证线程安全，避免取消的时候同时执行分发</span><br><span class="line">    private final Object mLock = new Object();</span><br><span class="line"></span><br><span class="line">    @GuardedBy(&quot;mLock&quot;)</span><br><span class="line">    @Nullable</span><br><span class="line">    private Response.Listener&lt;Bitmap&gt; mListener;</span><br><span class="line"></span><br><span class="line">    private final Config mDecodeConfig;</span><br><span class="line">    private final int mMaxWidth;</span><br><span class="line">    private final int mMaxHeight;</span><br><span class="line">    private final ScaleType mScaleType;</span><br><span class="line"></span><br><span class="line">    //Bitmap 的同步解析锁，保证一个时间内只有一个Bitmap被加载到内存进行解析，避免多个同时解析oom</span><br><span class="line">    private static final Object sDecodeLock = new Object();</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    public ImageRequest(</span><br><span class="line">            String url,</span><br><span class="line">            Response.Listener&lt;Bitmap&gt; listener,</span><br><span class="line">            int maxWidth,</span><br><span class="line">            int maxHeight,</span><br><span class="line">            ScaleType scaleType,</span><br><span class="line">            Config decodeConfig,</span><br><span class="line">            @Nullable Response.ErrorListener errorListener) &#123;</span><br><span class="line">        super(Method.GET, url, errorListener);</span><br><span class="line">        setRetryPolicy(</span><br><span class="line">                new DefaultRetryPolicy(</span><br><span class="line">                        DEFAULT_IMAGE_TIMEOUT_MS,</span><br><span class="line">                        DEFAULT_IMAGE_MAX_RETRIES,</span><br><span class="line">                        DEFAULT_IMAGE_BACKOFF_MULT));</span><br><span class="line">        mListener = listener;</span><br><span class="line">        mDecodeConfig = decodeConfig;</span><br><span class="line">        mMaxWidth = maxWidth;</span><br><span class="line">        mMaxHeight = maxHeight;</span><br><span class="line">        mScaleType = scaleType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Deprecated</span><br><span class="line">    public ImageRequest(</span><br><span class="line">            String url,</span><br><span class="line">            Response.Listener&lt;Bitmap&gt; listener,</span><br><span class="line">            int maxWidth,</span><br><span class="line">            int maxHeight,</span><br><span class="line">            Config decodeConfig,</span><br><span class="line">            Response.ErrorListener errorListener) &#123;</span><br><span class="line">        this(</span><br><span class="line">                url,</span><br><span class="line">                listener,</span><br><span class="line">                maxWidth,</span><br><span class="line">                maxHeight,</span><br><span class="line">                ScaleType.CENTER_INSIDE,</span><br><span class="line">                decodeConfig,</span><br><span class="line">                errorListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Priority getPriority() &#123;</span><br><span class="line">        return Priority.LOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据ScaleType设置图片大小</span><br><span class="line">    private static int getResizedDimension(</span><br><span class="line">            int maxPrimary,</span><br><span class="line">            int maxSecondary,</span><br><span class="line">            int actualPrimary,</span><br><span class="line">            int actualSecondary,</span><br><span class="line">            ScaleType scaleType) &#123;</span><br><span class="line"></span><br><span class="line">        // 如果主要值和次要的值为0，就返回实际值，如果我们计算宽度的期望值，</span><br><span class="line">        那么主要值就是宽度，高度就是次要值，反之亦然</span><br><span class="line">        if ((maxPrimary == 0) &amp;&amp; (maxSecondary == 0)) &#123;</span><br><span class="line">            return actualPrimary;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果为ScaleType.FIT_XY，填充整个矩形，忽略比值；</span><br><span class="line">        即如果主要的值为0则返回实际值，否则返回传入的值</span><br><span class="line">        if (scaleType == ScaleType.FIT_XY) &#123;</span><br><span class="line">            if (maxPrimary == 0) &#123;</span><br><span class="line">                return actualPrimary;</span><br><span class="line">            &#125;</span><br><span class="line">            return maxPrimary;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果主要的值为0，则通过比例值计算出主要的值返回</span><br><span class="line">        if (maxPrimary == 0) &#123;</span><br><span class="line">            double ratio = (double) maxSecondary / (double) actualSecondary;</span><br><span class="line">            return (int) (actualPrimary * ratio);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 次要的值为0，下面的比例调整就是多余的，那么直接返回主要的值，</span><br><span class="line">        if (maxSecondary == 0) &#123;</span><br><span class="line">            return maxPrimary;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 图片真实尺寸大小的比例，通过这个比例我们可以计算出次要的最大值，通</span><br><span class="line">        过计算出的值和我们传递进来的值做比较</span><br><span class="line">        double ratio = (double) actualSecondary / (double) actualPrimary;</span><br><span class="line">        int resized = maxPrimary;</span><br><span class="line"></span><br><span class="line">        // 如果是ScaleType.CENTER_CROP，填充整个矩形，保持长宽比，这里的宽高值相等或者大于传入的宽高尺寸</span><br><span class="line">        if (scaleType == ScaleType.CENTER_CROP) &#123;</span><br><span class="line">            // 小于传入的次要最大值，则返回通过比例计算的最大值，这里相当于把resized 值增大</span><br><span class="line">            if ((resized * ratio) &lt; maxSecondary) &#123;</span><br><span class="line">                resized = (int) (maxSecondary / ratio);</span><br><span class="line">            &#125;</span><br><span class="line">            return resized;</span><br><span class="line">        &#125;</span><br><span class="line">        //  其它scaleType值，如果计算的值大于次要值，那么resized 值减小</span><br><span class="line">        if ((resized * ratio) &gt; maxSecondary) &#123;</span><br><span class="line">            resized = (int) (maxSecondary / ratio);</span><br><span class="line">        &#125;</span><br><span class="line">        return resized;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //解析response</span><br><span class="line">    @Override</span><br><span class="line">    protected Response&lt;Bitmap&gt; parseNetworkResponse(NetworkResponse response) &#123;</span><br><span class="line">        synchronized (sDecodeLock) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return doParse(response);</span><br><span class="line">            &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">                VolleyLog.e(&quot;Caught OOM for %d byte image, url=%s&quot;, response.data.length, getUrl());</span><br><span class="line">                return Response.error(new ParseError(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //解析的地方</span><br><span class="line">    private Response&lt;Bitmap&gt; doParse(NetworkResponse response) &#123;</span><br><span class="line">        byte[] data = response.data;</span><br><span class="line">        BitmapFactory.Options decodeOptions = new BitmapFactory.Options();</span><br><span class="line">        Bitmap bitmap = null;</span><br><span class="line">        //如果最大宽度和最大高度都传入的为0，直接解析成一个bitmap</span><br><span class="line">        if (mMaxWidth == 0 &amp;&amp; mMaxHeight == 0) &#123;</span><br><span class="line">            decodeOptions.inPreferredConfig = mDecodeConfig;</span><br><span class="line">            bitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果要调整图片的大小，首先获取图片真实的尺寸大小，首先设置inJustDecodeBounds为true，不加载到内存但是可以获取图像的宽高</span><br><span class="line">            decodeOptions.inJustDecodeBounds = true;</span><br><span class="line">            BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);</span><br><span class="line">            int actualWidth = decodeOptions.outWidth;</span><br><span class="line">            int actualHeight = decodeOptions.outHeight;</span><br><span class="line"></span><br><span class="line">            // 计算我们想要的尺寸</span><br><span class="line">            int desiredWidth =</span><br><span class="line">                    getResizedDimension(</span><br><span class="line">                            mMaxWidth, mMaxHeight, actualWidth, actualHeight, mScaleType);</span><br><span class="line">            int desiredHeight =</span><br><span class="line">                    getResizedDimension(</span><br><span class="line">                            mMaxHeight, mMaxWidth, actualHeight, actualWidth, mScaleType);</span><br><span class="line"></span><br><span class="line">            // 计算出采样值，2的倍数</span><br><span class="line">            decodeOptions.inJustDecodeBounds = false;</span><br><span class="line">            decodeOptions.inSampleSize =</span><br><span class="line">                    findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight);</span><br><span class="line">            Bitmap tempBitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);</span><br><span class="line"></span><br><span class="line">            // 如果采样率计算出的值为1的话，那么就没有尺寸压缩，tempBitmap的宽高值就是图片的</span><br><span class="line">            真实值，那么这里就需要缩放到满足我们上面计算出来的值</span><br><span class="line">            if (tempBitmap != null</span><br><span class="line">                    &amp;&amp; (tempBitmap.getWidth() &gt; desiredWidth</span><br><span class="line">                            || tempBitmap.getHeight() &gt; desiredHeight)) &#123;</span><br><span class="line">                bitmap = Bitmap.createScaledBitmap(tempBitmap, desiredWidth, desiredHeight, true);</span><br><span class="line">                tempBitmap.recycle();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                bitmap = tempBitmap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //回调给用户</span><br><span class="line">        if (bitmap == null) &#123;</span><br><span class="line">            return Response.error(new ParseError(response));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Response.success(bitmap, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void cancel() &#123;</span><br><span class="line">        super.cancel();</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            mListener = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void deliverResponse(Bitmap response) &#123;</span><br><span class="line">        Response.Listener&lt;Bitmap&gt; listener;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            listener = mListener;</span><br><span class="line">        &#125;</span><br><span class="line">        if (listener != null) &#123;</span><br><span class="line">            listener.onResponse(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算合适的采样率</span><br><span class="line">    @VisibleForTesting</span><br><span class="line">    static int findBestSampleSize(</span><br><span class="line">            int actualWidth, int actualHeight, int desiredWidth, int desiredHeight) &#123;</span><br><span class="line">        double wr = (double) actualWidth / desiredWidth;</span><br><span class="line">        double hr = (double) actualHeight / desiredHeight;</span><br><span class="line">        double ratio = Math.min(wr, hr);</span><br><span class="line">        float n = 1.0f;</span><br><span class="line">        while ((n * 2) &lt;= ratio) &#123;</span><br><span class="line">            n *= 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (int) n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键部分我都写了注释，下面我们看主要流程，对 <code>Bitmap</code> 的高效加载。首先我们获取到返回的 <code>response</code> 进行解析，然后根据传递的期望宽高以及图片格式生成 <code>Bitmap</code> 返回，对于我们传入的宽高会按比例裁剪，不是直接使用裁剪到合适的值，不然会有拉伸，最后再回调给用户。</p>
<h5 id="二、ImageLoader-分析"><a href="#二、ImageLoader-分析" class="headerlink" title="二、ImageLoader 分析"></a>二、ImageLoader 分析</h5><p>我们直接先看构造方法，看所有的关键地方，不重要的就不分析了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ImageLoader(RequestQueue queue, ImageCache imageCache) &#123;</span><br><span class="line">        mRequestQueue = queue;</span><br><span class="line">        mCache = imageCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>没啥说的，就是赋值，一个是请求队列，一个是图片缓存的自己实现，这个是在内部把请求添加到请求队列，所以直接传递进去，第二个参数缓存，我们可以自己实现，一般使用 <code>LruCache</code> 实现。<br>接下来我们接着看 <code>getImageListener</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static ImageListener getImageListener(</span><br><span class="line">            final ImageView view, final int defaultImageResId, final int errorImageResId) &#123;</span><br><span class="line">        return new ImageListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onErrorResponse(VolleyError error) &#123;</span><br><span class="line">                if (errorImageResId != 0) &#123;</span><br><span class="line">                    view.setImageResource(errorImageResId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(ImageContainer response, boolean isImmediate) &#123;</span><br><span class="line">                if (response.getBitmap() != null) &#123;</span><br><span class="line">                    view.setImageBitmap(response.getBitmap());</span><br><span class="line">                &#125; else if (defaultImageResId != 0) &#123;</span><br><span class="line">                    view.setImageResource(defaultImageResId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法比较简单，就是传入我们的 <code>ImageView</code> 进行设置图像，然后分别提供一个默认和请求失败的占位图，刚开始设置的时候还没有请求到 <code>Bitmap</code>,所以最开始设置的事默认图。<br>首先看两个变量，后面需要用到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//相同URL正在请求中存储的map</span><br><span class="line">private final HashMap&lt;String, BatchedImageRequest&gt; mInFlightRequests = new HashMap&lt;&gt;();</span><br><span class="line">//相同URL请求结果存储的map</span><br><span class="line">private final HashMap&lt;String, BatchedImageRequest&gt; mBatchedResponses = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>接下来我们看看关键的一步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    @MainThread</span><br><span class="line">    public ImageContainer get(</span><br><span class="line">            String requestUrl,</span><br><span class="line">            ImageListener imageListener,</span><br><span class="line">            int maxWidth,</span><br><span class="line">            int maxHeight,</span><br><span class="line">            ScaleType scaleType) &#123;</span><br><span class="line"></span><br><span class="line">        // 检查当前线程是否在主线程，只满足从主线程发起的请求</span><br><span class="line">        Threads.throwIfNotOnMainThread();</span><br><span class="line"></span><br><span class="line">        //根据url、width、height、scaleType拼接的缓存key</span><br><span class="line">        final String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight, scaleType);</span><br><span class="line"></span><br><span class="line">        // 从缓存中查找bitmap</span><br><span class="line">        Bitmap cachedBitmap = mCache.getBitmap(cacheKey);</span><br><span class="line">        if (cachedBitmap != null) &#123;</span><br><span class="line">            // 有相应的缓存那么则返回一个ImageContainer，包括其中的bitmap</span><br><span class="line">            ImageContainer container =</span><br><span class="line">                    new ImageContainer(</span><br><span class="line">                            cachedBitmap, requestUrl, /* cacheKey= */ null, /* listener= */ null);</span><br><span class="line">            // 直接调用onResponse，把bitmap设置给imageView</span><br><span class="line">            imageListener.onResponse(container, true);</span><br><span class="line">            return container;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 缓存中没有查找到，那么我们直接获取，首先new一个ImageContainer</span><br><span class="line">        ImageContainer imageContainer =</span><br><span class="line">                new ImageContainer(null, requestUrl, cacheKey, imageListener);</span><br><span class="line"></span><br><span class="line">        // 更新调用的地方，使用默认的图片先设置</span><br><span class="line">        imageListener.onResponse(imageContainer, true);</span><br><span class="line">        //检查是否有相同的cacheKey请求正在运行</span><br><span class="line">        BatchedImageRequest request = mInFlightRequests.get(cacheKey);</span><br><span class="line">        if (request != null) &#123;</span><br><span class="line">            // 如果相同的请求正在运行，那么不需要重复请求，只需要将这个实例化</span><br><span class="line">            的imageContainer添加到BatchedImageRequest的mContainers中，然后请</span><br><span class="line">            求结束后对所有添加到集合中的imageContainer依次回调</span><br><span class="line">            request.addContainer(imageContainer);</span><br><span class="line">            return imageContainer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果这个请求尚未执行，发送一个新的请求到网络上，这里才是执行请求的地方</span><br><span class="line">        Request&lt;Bitmap&gt; newRequest =</span><br><span class="line">                makeImageRequest(requestUrl, maxWidth, maxHeight, scaleType, cacheKey);</span><br><span class="line">        //添加到请求队列</span><br><span class="line">        mRequestQueue.add(newRequest);</span><br><span class="line">        //添加到正在请求的集合中</span><br><span class="line">        mInFlightRequests.put(cacheKey, new BatchedImageRequest(newRequest, imageContainer));</span><br><span class="line">        return imageContainer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法是一个重点，主要流程是首先看看缓存里面有没有缓存的 <code>Bitmap</code>,来源于我们自己实现的缓存策略，我们使用的是内存缓存的话这里就是一级缓存；如果有直接调用 <code>onResponse</code> 方法设置图片，如果没有，首先实例化 <code>ImageContainer</code>，涉及到了几个类，接下来就看是否有相同的请求，如果有则添加到一个集合中，请求下来统一处理；如果没有那么则构造一个 <code>Request</code>，通过 <code>RequestQueue</code> 去获取网络图片，可能是网络请求也有可能是磁盘缓存的，这里就是二级缓存，然后添加到正在请求的集合中。<br>接下来看一看 <code>ImageContainer</code> 这个类,这个类就是图像请求的一个容器对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class ImageContainer &#123;</span><br><span class="line">        //imageview加载的Bitmap</span><br><span class="line">        private Bitmap mBitmap;</span><br><span class="line">        </span><br><span class="line">        //图片加载成功和失败的监听</span><br><span class="line">        private final ImageListener mListener;</span><br><span class="line"></span><br><span class="line">        //缓存的key</span><br><span class="line">        private final String mCacheKey;</span><br><span class="line"></span><br><span class="line">        //请求指定的URL</span><br><span class="line">        private final String mRequestUrl;</span><br><span class="line"></span><br><span class="line">        public ImageContainer(</span><br><span class="line">                Bitmap bitmap, String requestUrl, String cacheKey, ImageListener listener) &#123;</span><br><span class="line">            mBitmap = bitmap;</span><br><span class="line">            mRequestUrl = requestUrl;</span><br><span class="line">            mCacheKey = cacheKey;</span><br><span class="line">            mListener = listener;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //取消请求</span><br><span class="line">        @MainThread</span><br><span class="line">        public void cancelRequest() &#123;</span><br><span class="line">            Threads.throwIfNotOnMainThread();</span><br><span class="line"></span><br><span class="line">            if (mListener == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //从正在请求的集合获取一个批处理request</span><br><span class="line">            BatchedImageRequest request = mInFlightRequests.get(mCacheKey);</span><br><span class="line">            if (request != null) &#123;</span><br><span class="line">                //如果取到request，那么首先从mContainers移除当前的这个ImageContainer，</span><br><span class="line">                如果移除后集合为空一个ImageContainer也没有了，那么则取消掉这个请求并返回 true</span><br><span class="line">                boolean canceled = request.removeContainerAndCancelIfNecessary(this);</span><br><span class="line">                if (canceled) &#123;</span><br><span class="line">                    //取消了请求则从正在请求的集合中移除BatchedImageRequest</span><br><span class="line">                    mInFlightRequests.remove(mCacheKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果已经请求完成添加到批处理中准备处理分发</span><br><span class="line">                request = mBatchedResponses.get(mCacheKey);</span><br><span class="line">                if (request != null) &#123;</span><br><span class="line">                    //首先从mContainers移除当前的这个ImageContainer</span><br><span class="line">                    request.removeContainerAndCancelIfNecessary(this);</span><br><span class="line">                    if (request.mContainers.size() == 0) &#123;</span><br><span class="line">                        //如果集合中一个ImageContainer都没有，则从等待处理的</span><br><span class="line">                        response中移除掉这个BatchedImageRequest</span><br><span class="line">                        mBatchedResponses.remove(mCacheKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Bitmap getBitmap() &#123;</span><br><span class="line">            return mBitmap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /** Returns the requested URL for this container. */</span><br><span class="line">        public String getRequestUrl() &#123;</span><br><span class="line">            return mRequestUrl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个类主要包含是一个图片的容器对象，里面包括了 <code>bitmap</code>、监听器、缓存的key以及请求的 <code>URL</code>，每个请求都会先组装这个类，然后添加到一个 <code>BatchedImageRequest的mContainers</code> 中</p>
<p>接下来我们看看真正发起请求的地方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">protected Request&lt;Bitmap&gt; makeImageRequest(</span><br><span class="line">            String requestUrl,</span><br><span class="line">            int maxWidth,</span><br><span class="line">            int maxHeight,</span><br><span class="line">            ScaleType scaleType,</span><br><span class="line">            final String cacheKey) &#123;</span><br><span class="line">        return new ImageRequest(</span><br><span class="line">                requestUrl,</span><br><span class="line">                new Listener&lt;Bitmap&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onResponse(Bitmap response) &#123;</span><br><span class="line">                        onGetImageSuccess(cacheKey, response);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                maxWidth,</span><br><span class="line">                maxHeight,</span><br><span class="line">                scaleType,</span><br><span class="line">                Config.RGB_565,</span><br><span class="line">                new ErrorListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onErrorResponse(VolleyError error) &#123;</span><br><span class="line">                        onGetImageError(cacheKey, error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //图片请求成功</span><br><span class="line">    protected void onGetImageSuccess(String cacheKey, Bitmap response) &#123;</span><br><span class="line">        // 添加到以及缓存中</span><br><span class="line">        mCache.putBitmap(cacheKey, response);</span><br><span class="line"></span><br><span class="line">        // 从正在运行的请求列表中删除这个请求</span><br><span class="line">        BatchedImageRequest request = mInFlightRequests.remove(cacheKey);</span><br><span class="line"></span><br><span class="line">        if (request != null) &#123;</span><br><span class="line">            //更新BatchedImageRequest的bitmap</span><br><span class="line">            request.mResponseBitmap = response;</span><br><span class="line">            //发送一个批处理请求，将多个相同的请求进行分发</span><br><span class="line">            batchResponse(cacheKey, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //图片请求失败，跟上面成功处理大致类似</span><br><span class="line">    protected void onGetImageError(String cacheKey, VolleyError error) &#123;</span><br><span class="line">        BatchedImageRequest request = mInFlightRequests.remove(cacheKey);</span><br><span class="line"></span><br><span class="line">        if (request != null) &#123;</span><br><span class="line">            //设置这个请求的错误</span><br><span class="line">            request.setError(error);</span><br><span class="line"></span><br><span class="line">            batchResponse(cacheKey, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里执行网络请求还是调用我们上面分析的 <code>ImageRequest</code> 方法，而且在回调中分别对成功和失败在进行了一次处理。<br>接下来我们看看这个批量处理图片的 <code>batchResponse</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void batchResponse(String cacheKey, BatchedImageRequest request) &#123;</span><br><span class="line">        //首先添加到这个map中，表明现在进入了批处理中</span><br><span class="line">        mBatchedResponses.put(cacheKey, request);</span><br><span class="line">        // 如果还没有进行处理，那么我们则开始一个新的任务</span><br><span class="line">        if (mRunnable == null) &#123;</span><br><span class="line">            mRunnable =</span><br><span class="line">                    new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            //循环mBatchedResponses的所有值</span><br><span class="line">                            for (BatchedImageRequest bir : mBatchedResponses.values()) &#123;</span><br><span class="line">                                //循环BatchedImageRequest的mContainers的值</span><br><span class="line">                                for (ImageContainer container : bir.mContainers) &#123;</span><br><span class="line">                                    //如果有的请求取消了，在收到请求的</span><br><span class="line">                                    响应后还没有分发之前那么跳过循环下一个</span><br><span class="line">                                    if (container.mListener == null) &#123;</span><br><span class="line">                                        continue;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    // 如果不是请求错误则调用onResponse</span><br><span class="line">                                    if (bir.getError() == null) &#123;</span><br><span class="line">                                        container.mBitmap = bir.mResponseBitmap;</span><br><span class="line">                                        container.mListener.onResponse(container, false);</span><br><span class="line">                                    &#125; else &#123;</span><br><span class="line">                                       //请求报错则调用onErrorResponse设置一个错误的图片展示 container.mListener.onErrorResponse(bir.getError());</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            //清除所有响应的BatchedImageRequest</span><br><span class="line">                            mBatchedResponses.clear();</span><br><span class="line">                            //置为null，通过是否为null判断当前是否正在处理</span><br><span class="line">                            mRunnable = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">            // 将这个post投递到主线程去执行</span><br><span class="line">            mHandler.postDelayed(mRunnable, mBatchResponseDelayMs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码也很简单，不过有个地方有个比较奇怪的地方，为啥是使用双层循环，为啥不直接使用内层的循环；个人认为有可能是这样，首先这个 <code>mBatchedResponses</code> 刚开始进来添加了相同的key的请求的 <code>BatchedImageRequest</code>，那么存在正在分发的时候又有不同的key的请求进来了，因为正在处理的时候 <code>runnable</code> 不为 <code>null</code>，则后续添加的有可能不能分发，所以要遍历这个 <code>map</code>中所有的请求。</p>
<h5 id="三、-NetworkImageView-分析"><a href="#三、-NetworkImageView-分析" class="headerlink" title="三、 NetworkImageView 分析"></a>三、 NetworkImageView 分析</h5><p>这是一个继承 <code>ImageView</code> 的自定义 <code>view</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">public class NetworkImageView extends ImageView &#123;</span><br><span class="line">    private String mUrl;</span><br><span class="line">    //设置默认的图片</span><br><span class="line">    private int mDefaultImageId;</span><br><span class="line">    //设置请求错误的时候显示的图片</span><br><span class="line">    private int mErrorImageId;</span><br><span class="line">    </span><br><span class="line">    private ImageLoader mImageLoader;</span><br><span class="line">    private ImageContainer mImageContainer;</span><br><span class="line"></span><br><span class="line">    public NetworkImageView(Context context) &#123;</span><br><span class="line">        this(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NetworkImageView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NetworkImageView(Context context, AttributeSet attrs, int defStyle) &#123;</span><br><span class="line">        super(context, attrs, defStyle);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //这个方法就是设置我们的url</span><br><span class="line">    @MainThread</span><br><span class="line">    public void setImageUrl(String url, ImageLoader imageLoader) &#123;</span><br><span class="line">        Threads.throwIfNotOnMainThread();</span><br><span class="line">        mUrl = url;</span><br><span class="line">        mImageLoader = imageLoader;</span><br><span class="line">        // 我们的url可能已经更改，那么我们则需要判断是否需要加载</span><br><span class="line">        loadImageIfNecessary(/* isInLayoutPass= */ false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDefaultImageResId(int defaultImage) &#123;</span><br><span class="line">        mDefaultImageId = defaultImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setErrorImageResId(int errorImage) &#123;</span><br><span class="line">        mErrorImageId = errorImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果视图尚未加载图像，那么我们则去加载它</span><br><span class="line">    void loadImageIfNecessary(final boolean isInLayoutPass) &#123;</span><br><span class="line">        int width = getWidth();</span><br><span class="line">        int height = getHeight();</span><br><span class="line">        ScaleType scaleType = getScaleType();</span><br><span class="line"></span><br><span class="line">        boolean wrapWidth = false, wrapHeight = false;</span><br><span class="line">        if (getLayoutParams() != null) &#123;</span><br><span class="line">            wrapWidth = getLayoutParams().width == LayoutParams.WRAP_CONTENT;</span><br><span class="line">            wrapHeight = getLayoutParams().height == LayoutParams.WRAP_CONTENT;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果不知道视图的大小并且不是WRAP_CONTENT就暂停加载</span><br><span class="line">        boolean isFullyWrapContent = wrapWidth &amp;&amp; wrapHeight;</span><br><span class="line">        if (width == 0 &amp;&amp; height == 0 &amp;&amp; !isFullyWrapContent) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果url为空的话则请取消所有的请求，包括以前的请求，假如请求两次</span><br><span class="line">        最后次的url为null，这时候还没请求完成，肯定以最后次为准</span><br><span class="line">        if (TextUtils.isEmpty(mUrl)) &#123;</span><br><span class="line">            if (mImageContainer != null) &#123;</span><br><span class="line">                mImageContainer.cancelRequest();</span><br><span class="line">                mImageContainer = null;</span><br><span class="line">            &#125;</span><br><span class="line">            //设置默认的图片</span><br><span class="line">            setDefaultImageOrNull();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查是否取消以前的请求</span><br><span class="line">        if (mImageContainer != null &amp;&amp; mImageContainer.getRequestUrl() != null) &#123;</span><br><span class="line">            if (mImageContainer.getRequestUrl().equals(mUrl)) &#123;</span><br><span class="line">                // 如果请求和以前相同则没必要再次请求</span><br><span class="line">                return;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果存在正在请求的url并且请求url不同，那么取消正在请求的url</span><br><span class="line">                mImageContainer.cancelRequest();</span><br><span class="line">                setDefaultImageOrNull();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 计算最大宽高，如果设置WRAP_CONTENT那么则图片是多大就是多大，其它</span><br><span class="line">        情况则直接使用布局的宽高，如果设置了具体的值就有可能裁剪</span><br><span class="line">        int maxWidth = wrapWidth ? 0 : width;</span><br><span class="line">        int maxHeight = wrapHeight ? 0 : height;</span><br><span class="line"></span><br><span class="line">        // 使用ImageLoader来请求图像，上面已经分析了，最终返回一个ImageContainer</span><br><span class="line">        mImageContainer =</span><br><span class="line">                mImageLoader.get(</span><br><span class="line">                        mUrl,</span><br><span class="line">                        new ImageListener() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void onErrorResponse(VolleyError error) &#123;</span><br><span class="line">                                if (mErrorImageId != 0) &#123;</span><br><span class="line">                                    setImageResource(mErrorImageId);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            @Override</span><br><span class="line">                            public void onResponse(</span><br><span class="line">                                    final ImageContainer response, boolean isImmediate) &#123;</span><br><span class="line">                                //isImmediate：在网络请求过程中调用的时候为true，可以用来</span><br><span class="line">                                区分是否是取的缓存图像还是网络图像加载</span><br><span class="line">                                isInLayoutPass：如果通过onLayout调用此函数，</span><br><span class="line">                                则为true，否则为false</span><br><span class="line">                                这个if的意思就是，如果是缓存图像并且是在布局中调用那么则发送</span><br><span class="line">                                到主线程并延迟设置图像，因为可能多次调用</span><br><span class="line">                                if (isImmediate &amp;&amp; isInLayoutPass) &#123;</span><br><span class="line">                                    post(</span><br><span class="line">                                            new Runnable() &#123;</span><br><span class="line">                                                @Override</span><br><span class="line">                                                public void run() &#123;</span><br><span class="line">                                                    onResponse(response, /* isImmediate= */ false);</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;);</span><br><span class="line">                                    return;</span><br><span class="line">                                &#125;</span><br><span class="line">                                //请求成功加载图片</span><br><span class="line">                                if (response.getBitmap() != null) &#123;</span><br><span class="line">                                    setImageBitmap(response.getBitmap());</span><br><span class="line">                                &#125; else if (mDefaultImageId != 0) &#123;</span><br><span class="line">                                    setImageResource(mDefaultImageId);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        maxWidth,</span><br><span class="line">                        maxHeight,</span><br><span class="line">                        scaleType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setDefaultImageOrNull() &#123;</span><br><span class="line">        if (mDefaultImageId != 0) &#123;</span><br><span class="line">            setImageResource(mDefaultImageId);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            setImageBitmap(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class="line">        super.onLayout(changed, left, top, right, bottom);</span><br><span class="line">        loadImageIfNecessary(/* isInLayoutPass= */ true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //当imageview销毁的时候，取消请求并且清除ImageContainer以便重新加载图像</span><br><span class="line">    @Override</span><br><span class="line">    protected void onDetachedFromWindow() &#123;</span><br><span class="line">        if (mImageContainer != null) &#123;</span><br><span class="line">            // If the view was bound to an image request, cancel it and clear</span><br><span class="line">            // out the image from the view.</span><br><span class="line">            mImageContainer.cancelRequest();</span><br><span class="line">            setImageBitmap(null);</span><br><span class="line">            // also clear out the container so we can reload the image if necessary.</span><br><span class="line">            mImageContainer = null;</span><br><span class="line">        &#125;</span><br><span class="line">        super.onDetachedFromWindow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void drawableStateChanged() &#123;</span><br><span class="line">        super.drawableStateChanged();</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个类没啥好分析的，就是利用前两个类来完成请求，只不过方便的是直接在xml中使用，使用 <code>ImageLoader</code> 请求的 <code>Bitmap</code> 设置给 <code>NetworkImageView</code>。</p>
<h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>三种不同的方式都可以完成图片的加载，不过后面的方式都比较依赖前面的 <code>ImageRequest</code>，毕竟还是要这个类去完成网络请求操作；在使用中，根据不同的场景选择不同的方式使用。不过我建议使用 <code>ImageLoader</code> 来加载图片，可以自己设置缓存，两级缓存，一级内存缓存，一级 <code>volley</code> 请求时候的磁盘缓存。总体来讲封装的很不错，对一些细节处理的比较好，比如相同的请求、图片的裁剪等，值得我们学习的地方很多。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/guolin_blog/article/details/17482165" target="_blank" rel="noopener">Android Volley完全解析(二)，使用Volley加载网络图片</a><br><a href="https://github.com/wangzhengyi/Volley/blob/master/README.md" target="_blank" rel="noopener">Volley 源码解析</a></p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-03-06T08:42:03.273Z" itemprop="dateUpdated">2020-03-06 16:42:03</time>
</span><br>


        
        如需转发请注明出处：<a href="/2020/03/05/Volley-源码解析之图片请求/" target="_blank" rel="external">https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/</a>
        
    </div>
    <footer>
        <a href="https://wvisible.github.io">
            <img src="/img/avatar.jpg" alt="哆啦A梦Doraemon">
            哆啦A梦Doraemon
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volley/">Volley</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/&title=《Volley 源码解析之图片请求》 — 哆啦A梦Doraemon&pic=https://wvisible.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/&title=《Volley 源码解析之图片请求》 — 哆啦A梦Doraemon&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Volley 源码解析之图片请求》 — 哆啦A梦Doraemon&url=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/&via=https://wvisible.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/03/05/Volley-源码解析之缓存机制/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Volley 源码解析之缓存机制</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/03/05/Volley-源码解析之网络请求/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Volley 源码解析之网络请求</h4>
      </a>
    </div>
  
</nav>



    











</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>哆啦A梦Doraemon &copy; 2015 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/&title=《Volley 源码解析之图片请求》 — 哆啦A梦Doraemon&pic=https://wvisible.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/&title=《Volley 源码解析之图片请求》 — 哆啦A梦Doraemon&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Volley 源码解析之图片请求》 — 哆啦A梦Doraemon&url=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/&via=https://wvisible.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACrklEQVR42u3aSU4DMRAF0Nz/0rBGKPGvwSFIr1co6cGvkezKLz8e8fEVHK+vffb372ufnfP6KaMDDw8Pb3Xor8/pDejZtfndCi8aDw8P7xqvOohkcp8vHpNz8PDw8D6Tl0zoyfnVu+Hh4eH9R16OSZaNKgkPDw/vE3h53JAHu0mIkMOuZy14eHh4nV5VoVz+27+v9Pfw8PDwljYEVIPaySSexBOF0eLh4eFd4FUj2l5Q29t01SuX8fDw8N7Jy8Pc3Wm92vRKnouHh4d3jzcPUicLST7QZMvXobOHh4eHt8pLBjqPd5PiuNoeO7wyPDw8vGu8HiMPeXsFev6Ky107PDw8vPGmgXwKrpbC1SVk/oIOKTUeHh7eBV4+x1Y/TwrlyRISJS54eHh4S7xkkp0MdFIoL8Dw8PDwVnnVQnke4/baaXkB/eMTPDw8vAu8arO/V2r3wo5q0+vwsvDw8PBWeT1YL1bII9rkzKh8x8PDw1vlJcOas2+U5tELwsPDw7vG6229mkS61e1W1Y0IP7IWPDw8vFVeNXKtHtX5Ob9P4bXi4eHhXeDlTa/e3oRqdJtvPqi26/Dw8PB2ecngtoaeLCeTPBYPDw/vHq+3+SkJDnrU3uJxKKDx8PDwVnlzcN6UKjSuWk+J1kA8PDy8Jd5WaZsX0PPIeGG9wsPDw1vi9VpN+TnVTVq9WBkPDw/v/bzXgWlyVTKJL0z6yX3w8PDwVnmTTVT3tiDkjMO3eHh4eBd4k1/01YI4jyTyu82bdnh4eHg9XnUxqIazkzZb8oIOz8XDw8O7xuu1u/Kgtlqg56vZIUbBw8PD+2Be7/NeA+wPFgY8PDy88SCqEWq+MOSRR/QPwMPDw7vGyyOG5Nt8KNW4oRzp4uHh4V3gVX/wF8rZVuurWTrP+3t4eHh4Z94352Z9gmmqauoAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '哆啦A梦Doraemon';
            clearTimeout(titleTime);
        } else {
            document.title = '哆啦A梦Doraemon';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
