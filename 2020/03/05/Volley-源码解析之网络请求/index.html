<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>Volley 源码解析之网络请求 | 哆啦A梦Doraemon | So we beat on, boats against the current, borne back ceaselessly into the past.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#1FA67A">
    
    
    <meta name="keywords" content="Volley">
    <meta name="description" content="Volley源码分析三部曲Volley 源码解析之网络请求Volley 源码解析之图片请求Volley 源码解析之缓存机制  Volley 是 Google 推出的一款网络通信框架，非常适合数据量小、通信频繁的网络请求，支持并发、缓存和容易扩展、调试等；不过不太适合下载大文件、大量数据的网络请求，因为 Volley 在解析期间将响应放到内存中，我们可以使用 Okhttp 或者系统提供的Downlo">
<meta name="keywords" content="Volley">
<meta property="og:type" content="article">
<meta property="og:title" content="Volley 源码解析之网络请求">
<meta property="og:url" content="https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/index.html">
<meta property="og:site_name" content="哆啦A梦Doraemon">
<meta property="og:description" content="Volley源码分析三部曲Volley 源码解析之网络请求Volley 源码解析之图片请求Volley 源码解析之缓存机制  Volley 是 Google 推出的一款网络通信框架，非常适合数据量小、通信频繁的网络请求，支持并发、缓存和容易扩展、调试等；不过不太适合下载大文件、大量数据的网络请求，因为 Volley 在解析期间将响应放到内存中，我们可以使用 Okhttp 或者系统提供的Downlo">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/volley.jpg">
<meta property="og:updated_time" content="2020-03-06T09:43:32.606Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Volley 源码解析之网络请求">
<meta name="twitter:description" content="Volley源码分析三部曲Volley 源码解析之网络请求Volley 源码解析之图片请求Volley 源码解析之缓存机制  Volley 是 Google 推出的一款网络通信框架，非常适合数据量小、通信频繁的网络请求，支持并发、缓存和容易扩展、调试等；不过不太适合下载大文件、大量数据的网络请求，因为 Volley 在解析期间将响应放到内存中，我们可以使用 Okhttp 或者系统提供的Downlo">
<meta name="twitter:image" content="https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/volley.jpg">
    
        <link rel="alternate" type="application/atom+xml" title="哆啦A梦Doraemon" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">哆啦A梦Doraemon</h5>
          <a href="mailto:wvisible@outlook.com" title="wvisible@outlook.com" class="mail">wvisible@outlook.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/wvisible" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://juejin.im/user/5853e9e98d6d8100659a8e7a" target="_blank" >
                <i class="icon icon-lg icon-link"></i>
                掘金
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Volley 源码解析之网络请求</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Volley 源码解析之网络请求</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-03-05T15:36:09.000Z" itemprop="datePublished" class="page-time">
  2020-03-05
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/源码解析/">源码解析</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#一、简单使用"><span class="post-toc-number">1.</span> <span class="post-toc-text">一、简单使用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#二、源码分析"><span class="post-toc-number">2.</span> <span class="post-toc-text">二、源码分析</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#三、总结"><span class="post-toc-number">3.</span> <span class="post-toc-text">三、总结</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#参考以及相关链接"><span class="post-toc-number">4.</span> <span class="post-toc-text">参考以及相关链接</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-Volley-源码解析之网络请求"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Volley 源码解析之网络请求</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-03-05 23:36:09" datetime="2020-03-05T15:36:09.000Z"  itemprop="datePublished">2020-03-05</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/源码解析/">源码解析</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p><code>Volley</code>源码分析三部曲<br><a href="https://juejin.im/post/5c1c58b35188251f1f320e70" target="_blank" rel="noopener">Volley 源码解析之网络请求</a><br><a href="https://juejin.im/post/5c1c84ade51d4535f05a192c" target="_blank" rel="noopener">Volley 源码解析之图片请求</a><br><a href="https://juejin.im/post/5c27a52de51d455fac46838d" target="_blank" rel="noopener">Volley 源码解析之缓存机制</a></p>
<blockquote>
<p><code>Volley</code> 是 <code>Google</code> 推出的一款网络通信框架，非常适合数据量小、通信频繁的网络请求，支持并发、缓存和容易扩展、调试等；不过不太适合下载大文件、大量数据的网络请求，因为 <code>Volley</code> 在解析期间将响应放到内存中，我们可以使用 <code>Okhttp</code> 或者系统提供的<code>DownloadManager</code>来下载文件。</p>
</blockquote>
<h4 id="一、简单使用"><a href="#一、简单使用" class="headerlink" title="一、简单使用"></a>一、简单使用</h4><p>首先在工程引入volley的library：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'com.android.volley:volley:1.1.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后需要我们打开网络权限，我这里直接贴出官网简单请求的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TextView mTextView = (TextView) findViewById(R.id.text);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate the RequestQueue.</span></span><br><span class="line">RequestQueue queue = Volley.newRequestQueue(<span class="keyword">this</span>);</span><br><span class="line">String url =<span class="string">"http://www.google.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Request a string response from the provided URL.</span></span><br><span class="line">StringRequest stringRequest = <span class="keyword">new</span> StringRequest(Request.Method.GET, url,</span><br><span class="line">            <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Display the first 500 characters of the response string.</span></span><br><span class="line">        mTextView.setText(<span class="string">"Response is: "</span>+ response.substring(<span class="number">0</span>,<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">        mTextView.setText(<span class="string">"That didn't work!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the request to the RequestQueue.</span></span><br><span class="line">queue.add(stringRequest);</span><br></pre></td></tr></table></figure>
<p>使用相对简单，回调直接在主线程，我们取消某个请求直接这样操作：</p>
<ol>
<li><p>定义一个标记添加到requests中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyTag"</span>;</span><br><span class="line">StringRequest stringRequest; <span class="comment">// Assume this exists.</span></span><br><span class="line">RequestQueue mRequestQueue;  <span class="comment">// Assume this exists.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the tag on the request.</span></span><br><span class="line">stringRequest.setTag(TAG);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the request to the RequestQueue.</span></span><br><span class="line">mRequestQueue.add(stringRequest);</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后我们可以在 onStop() 中取消所有标记的请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    <span class="keyword">if</span> (mRequestQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRequestQueue.cancelAll(TAG);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h4><p>我们先从Volley这个类入手：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, BaseHttpStack stack)</span> </span>&#123;</span><br><span class="line">    BasicNetwork network;</span><br><span class="line">    <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">            network = <span class="keyword">new</span> BasicNetwork(<span class="keyword">new</span> HurlStack());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String userAgent = <span class="string">"volley/0"</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String packageName = context.getPackageName();</span><br><span class="line">                PackageInfo info =</span><br><span class="line">                    context.getPackageManager().getPackageInfo(packageName, <span class="comment">/* flags= */</span> <span class="number">0</span>);</span><br><span class="line">                userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            network =</span><br><span class="line">                <span class="keyword">new</span> BasicNetwork(</span><br><span class="line">                <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRequestQueue(context, network);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, Network network)</span> </span>&#123;</span><br><span class="line">    File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">    RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</span><br><span class="line">    queue.start();</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newRequestQueue(context, (BaseHttpStack) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们传递一个 <code>Context</code> 的时候，首先为 <code>BaseHttpStack</code> 为 <code>null</code>，会执行到创建 <code>BaseHttpStack</code>，<code>BaseHttpStack</code> 是一个网络具体的处理请求，<code>Volley</code> 默认提供了基于 <code>HttpURLCollection</code> 的 <code>HurlStack</code> 和基于<code>HttpClient</code> 的 <code>HttpClientStack</code>。Android6.0 移除了 <code>HttpClient</code>，<code>Google</code> 官方推荐使用<code>HttpURLCollection</code> 类作为替换。所以这里在API大于9的版本是用的是 <code>HurlStack</code>,为什么这样选择，详情可见这篇博客<a href="https://blog.csdn.net/guolin_blog/article/details/12452307" target="_blank" rel="noopener">Android访问网络，使用HttpURLConnection还是HttpClient？</a>。我们使用的是默认的构造，<code>BaseHttpStack</code> 传入为 <code>null</code>，如果我们想使用自定义的 <code>okhttp</code> 替换底层，我们直接继承 <code>HttpStack</code> 重写即可，也可以自定义 <code>Network</code> 和 <code>RequestQueue</code>,<code>Volley</code> 的高扩展性充分体现。接下来则创建一个 <code>Network</code> 对象，然后实例化 <code>RequestQueue</code>,首先创建了一个用于缓存的文件夹，然后创建了一个磁盘缓存，将文件缓存到指定目录的硬盘上，默认大小是5M，但是大小可以配置。接下来调用 <code>RequestQueue</code> 的 <code>start()</code>方法进行启动，我们进入这个方法查看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stop(); </span><br><span class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher =</span><br><span class="line">            <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开始启动的时候先停止所有的请求线程和网络缓存线程，然后实例化一个缓存线程并运行，然后一个循环开启<code>DEFAULT_NETWORK_THREAD_POOL_SIZE</code>（4）个网络请求线程并运行，一共就是5个线程在后台运行，不断的等待网络请求的到来。</p>
<p>构造了 <code>RequestQueue</code> 之后，我们调用 <code>add()</code> 方法将相应的 <code>Request</code> 传入就开始执行网络请求了，我们看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将请求队列和请求关联起来</span></span><br><span class="line">    request.setRequestQueue(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//添加到正在请求中但是还未完成的集合中</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">        mCurrentRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置请求的一个序列号，通过原子变量的incrementAndGet方法，</span></span><br><span class="line">    <span class="comment">//以原子方式给当前值加1并获取新值实现请求的优先级</span></span><br><span class="line">    request.setSequence(getSequenceNumber());</span><br><span class="line">    <span class="comment">//添加一个调试信息</span></span><br><span class="line">    request.addMarker(<span class="string">"add-to-queue"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不需要缓存则直接加到网络的请求队列，默认每一个请求都是缓存的，</span></span><br><span class="line">    <span class="comment">//如果不需要缓存需要调用Request的setShouldCache方法来修改</span></span><br><span class="line">    <span class="keyword">if</span> (!request.shouldCache()) &#123;</span><br><span class="line">        mNetworkQueue.add(request);</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加到缓存的请求队列</span></span><br><span class="line">    mCacheQueue.add(request);</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键地方都写了注释，主要作用就是将请求加到请求队列，执行网络请求或者从缓存中获取结果。网络和缓存的请求都是一个优先级阻塞队列，按照优先级出队。上面几个关键步骤，添加到请求集合里面还有设置优先级以及添加到缓存和请求队列都是线程安全的，要么加锁，要么使用线程安全的队列或者原子操作。</p>
<p>接下来我们看看添加到 <code>CacheDispatcher</code> 缓存请求队列的 <code>run</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//初始化DiskBasedCache的缓存类</span></span><br><span class="line">    mCache.initialize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processRequest();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            VolleyLog.e(</span><br><span class="line">                <span class="string">"Ignoring spurious interrupt of CacheDispatcher thread; "</span></span><br><span class="line">                + <span class="string">"use quit() to terminate it"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的重点是看看 <code>processRequest()</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//从缓存队列取出请求</span></span><br><span class="line">    <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</span><br><span class="line">    processRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">final</span> Request&lt;?&gt; request)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    request.addMarker(<span class="string">"cache-queue-take"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求被取消，我们可以通过RequestQueue的回调接口来监听</span></span><br><span class="line">    <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">        request.finish(<span class="string">"cache-discard-canceled"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存中获取Cache.Entry</span></span><br><span class="line">    Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">    <span class="comment">//没有取到缓存</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.addMarker(<span class="string">"cache-miss"</span>);</span><br><span class="line">        <span class="comment">// 缓存未命中，对于可缓存的请求先去检查是否有相同的请求是否已经在运行中，</span></span><br><span class="line">        <span class="comment">//如果有的话先加入请求等待队列，等待请求完成，返回true；如果返回false则表示第一次请求</span></span><br><span class="line">        <span class="keyword">if</span> (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">            <span class="comment">//加入到网络请求的阻塞队列</span></span><br><span class="line">            mNetworkQueue.put(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存完全过期，处理过程跟上面类似</span></span><br><span class="line">    <span class="keyword">if</span> (entry.isExpired()) &#123;</span><br><span class="line">        request.addMarker(<span class="string">"cache-hit-expired"</span>);</span><br><span class="line">        <span class="comment">//设置请求缓存的entry到这个request中</span></span><br><span class="line">        request.setCacheEntry(entry);</span><br><span class="line">        <span class="keyword">if</span> (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">            mNetworkQueue.put(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存命中，将数据解析并返回到request的抽象方法中</span></span><br><span class="line">    request.addMarker(<span class="string">"cache-hit"</span>);</span><br><span class="line">    Response&lt;?&gt; response =</span><br><span class="line">        request.parseNetworkResponse(</span><br><span class="line">        <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">    request.addMarker(<span class="string">"cache-hit-parsed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断请求结果是否需要刷新</span></span><br><span class="line">    <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</span><br><span class="line">        <span class="comment">// 未过期的缓存命中，通过ExecutorDelivery回调给我们的request子类的接口中，</span></span><br><span class="line">        <span class="comment">// 我们在使用的时候就可以通过StringRequest、JsonRequest等拿到结果，</span></span><br><span class="line">        <span class="comment">// 切换到主线程也是在这个类里执行的</span></span><br><span class="line">        mDelivery.postResponse(request, response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</span><br><span class="line">        request.setCacheEntry(entry);</span><br><span class="line">        <span class="comment">// 将这个响应标记为中间值，即这个响应是新鲜的，那么第二个响应正在请求随时到来</span></span><br><span class="line">        response.intermediate = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">            <span class="comment">//发起网络请求，这里为什么直接调用上面的mNetworkQueue.put(request);呢，</span></span><br><span class="line">            <span class="comment">//主要是为了添加一个已经分发的标记，在响应分发的时候不再回调给用户，</span></span><br><span class="line">            <span class="comment">//不然就回调了两次</span></span><br><span class="line">            mDelivery.postResponse(</span><br><span class="line">                request,</span><br><span class="line">                response,</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            mNetworkQueue.put(request);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="comment">// Restore the interrupted status</span></span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//这里第三个参数传递null，不用再去分发，因为已经有相同的请求已经在执行，</span></span><br><span class="line">            <span class="comment">//直接添加到了等待请求的列表中，然后返回的时候从已经执行的请求收到响应</span></span><br><span class="line">            mDelivery.postResponse(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分主要是对请求的缓存判断，是否过期以及需要刷新缓存。我们调用取消所有请求或者取消某个请求实质上就是对 <code>mCanceled</code> 这个变量赋值，然后在缓存线程或者网络线程里面都回去判断这个值，就完成了取消。上面的 <code>isExpired</code> 和 <code>refreshNeeded</code>，两个区别就是，前者如果过期就直接请求最新的内容，后者就是还在新鲜的时间内，但是把内容返回给用户还是会发起请求，两者一个与 <code>ttl</code> 值相比，另一个与 <code>softTtl</code> 相比。</p>
<p>其中有一个 <code>WaitingRequestManager</code>，如果有相同的请求那么就需要一个暂存的地方，这个类就是做的这个操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitingRequestManager</span> <span class="keyword">implements</span> <span class="title">Request</span>.<span class="title">NetworkRequestCompleteListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有等待请求的集合，键是缓存的key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CacheDispatcher mCacheDispatcher;</span><br><span class="line"></span><br><span class="line">    WaitingRequestManager(CacheDispatcher cacheDispatcher) &#123;</span><br><span class="line">        mCacheDispatcher = cacheDispatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求接受到一个有效的响应，后面等待的相同请求就可以使用这个响应</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponseReceived</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果缓存为空或者已经过期，那么就释放等待的请求</span></span><br><span class="line">        <span class="keyword">if</span> (response.cacheEntry == <span class="keyword">null</span> || response.cacheEntry.isExpired()) &#123;</span><br><span class="line">            onNoUsableResponseReceived(request);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String cacheKey = request.getCacheKey();</span><br><span class="line">        <span class="comment">//等待的请求的集合</span></span><br><span class="line">        List&lt;Request&lt;?&gt;&gt; waitingRequests;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//从map里面移除这个请求的集合</span></span><br><span class="line">            waitingRequests = mWaitingRequests.remove(cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (waitingRequests != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                VolleyLog.v(</span><br><span class="line">                    <span class="string">"Releasing %d waiting requests for cacheKey=%s."</span>,</span><br><span class="line">                    waitingRequests.size(), cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 里面所有的请求都分发到相应的回调执行，下面会讲解</span></span><br><span class="line">            <span class="keyword">for</span> (Request&lt;?&gt; waiting : waitingRequests) &#123;</span><br><span class="line">                mCacheDispatcher.mDelivery.postResponse(waiting, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有收到相应，则需要释放请求</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onNoUsableResponseReceived</span><span class="params">(Request&lt;?&gt; request)</span> </span>&#123;</span><br><span class="line">        String cacheKey = request.getCacheKey();</span><br><span class="line">        List&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (waitingRequests != <span class="keyword">null</span> &amp;&amp; !waitingRequests.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                VolleyLog.v(</span><br><span class="line">                    <span class="string">"%d waiting requests for cacheKey=%s; resend to network"</span>,</span><br><span class="line">                    waitingRequests.size(), cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下面这个请求执会重新执行，将这个移除添加到</span></span><br><span class="line">            Request&lt;?&gt; nextInLine = waitingRequests.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//将剩下的请求放到等待请求的map中</span></span><br><span class="line">            mWaitingRequests.put(cacheKey, waitingRequests);</span><br><span class="line">            <span class="comment">//在request里面注册一个回调接口，因为重新开始请求，需要重新注册一个监听，</span></span><br><span class="line">            <span class="comment">//后面请求成功失败以及取消都可以收到回调</span></span><br><span class="line">            nextInLine.setNetworkRequestCompleteListener(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//从上面if判断方法可以得出：waitingRequests != null &amp;&amp; !waitingRequests.isEmpty()</span></span><br><span class="line">                <span class="comment">//排除了第一次请求失败、取消的情况，后面的那个条件则表示这个等待请求队列必须要有一个请求，</span></span><br><span class="line">                <span class="comment">//同时满足才会执行这里面的代码，一般只要这里面的请求执行成功一次后续所有的请求都会被移除，</span></span><br><span class="line">                <span class="comment">//所以这里对多个请求的情况，失败一次，那么后续的请求会继续执行</span></span><br><span class="line">                mCacheDispatcher.mNetworkQueue.put(nextInLine);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException iex) &#123;</span><br><span class="line">                VolleyLog.e(<span class="string">"Couldn't add request to queue. %s"</span>, iex.toString());</span><br><span class="line">                <span class="comment">// Restore the interrupted status of the calling thread (i.e. NetworkDispatcher)</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="comment">// Quit the current CacheDispatcher thread.</span></span><br><span class="line">                mCacheDispatcher.quit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//对于可以缓存的请求，相同缓存的请求已经在运行中就添加到一个发送队列，</span></span><br><span class="line"> 	<span class="comment">//等待运行中的队列请求完成，返回true表示已经有请求在运行，false则是第一次执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">maybeAddToWaitingRequests</span><span class="params">(Request&lt;?&gt; request)</span> </span>&#123;</span><br><span class="line">        String cacheKey = request.getCacheKey();</span><br><span class="line">        <span class="comment">// 存在相同的请求则把请求加入到相同缓存键的集合中</span></span><br><span class="line">        <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class="line">            <span class="comment">// There is already a request in flight. Queue up.</span></span><br><span class="line">            List&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class="line">            <span class="comment">//如果包含相同的请求但是有可能是第二次请求，前面第一次请求插入null了</span></span><br><span class="line">            <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</span><br><span class="line">                stagedRequests = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            request.addMarker(<span class="string">"waiting-for-response"</span>);</span><br><span class="line">            stagedRequests.add(request);</span><br><span class="line">            mWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                VolleyLog.d(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//第一次请求那么则插入一个null，表示当前有一个请求正在运行</span></span><br><span class="line">            mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//注册一个接口监听</span></span><br><span class="line">            request.setNetworkRequestCompleteListener(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                VolleyLog.d(<span class="string">"new request, sending to network %s"</span>, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类主要是避免相同的请求多次请求，而且在 <code>NetworkDispatcher</code> 里面也会通过这个接口回调相应的值在这里执行，最终比如在网络请求返回304、请求取消或者异常那么都会在这里来处理，如果收到响应则会把值回调给用户，后面的请求也不会再去请求，如果无效的响应则会做一些释放等待的请求操作，请求完成也会将后面相同的请求回调给用户，三个方法都在不同的地方发挥作用。</p>
<p>我们接下来看看 <code>NetworkDispatcher</code> 网络请求队列的 <code>run</code> 方法中的 <code>processRequest</code> 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request&lt;?&gt; request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimeMs = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        request.addMarker(<span class="string">"network-queue-take"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求被取消了，就不执行网络请求,</span></span><br><span class="line">        <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">            request.finish(<span class="string">"network-discard-cancelled"</span>);</span><br><span class="line">            request.notifyListenerResponseNotUsable();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addTrafficStatsTag(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里就是执行网络请求的地方</span></span><br><span class="line">        NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">        request.addMarker(<span class="string">"network-http-complete"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果服务器返回304响应，即没有修改过，</span></span><br><span class="line">        <span class="comment">//缓存依然是有效的并且是在需要刷新的有效期内，那么则不需要解析响应</span></span><br><span class="line">        <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">            request.finish(<span class="string">"not-modified"</span>);</span><br><span class="line">            <span class="comment">//没有收到来自网络的有效响应，释放请求</span></span><br><span class="line">            request.notifyListenerResponseNotUsable();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在工作线程中解析这些响应</span></span><br><span class="line">        Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">        request.addMarker(<span class="string">"network-parse-complete"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将缓存写入到应用</span></span><br><span class="line">        <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">            request.addMarker(<span class="string">"network-cache-written"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记此请求已将分发</span></span><br><span class="line">        request.markDelivered();</span><br><span class="line">        <span class="comment">//将请求的响应回调给用户</span></span><br><span class="line">        mDelivery.postResponse(request, response);</span><br><span class="line">        <span class="comment">//请求接受到了一个响应，其他相同的请求可以使用这个响应</span></span><br><span class="line">        request.notifyListenerResponseReceived(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里才是网络请求的真正执行以及解析分发的地方，重点看两个地方的代码，执行和解析，我们先看看执行网络请求这个代码，执行的地方是 <code>BasicNetwork.performRequest</code>，下面看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        HttpResponse httpResponse = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;Header&gt; responseHeaders = Collections.emptyList();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 构造缓存的头部，添加If-None-Match和If-Modified-Since，都是http/1.1中控制协商缓存的两个字段，   			  </span></span><br><span class="line">            <span class="comment">// If-None-Match：客服端再次发起请求时，携带上次请求返回的唯一标识Etag值，</span></span><br><span class="line">            <span class="comment">//服务端用携带的值和最后修改的值作对比，最后修改时间大于携带的字段值则返回200，否则304；</span></span><br><span class="line">            <span class="comment">// If-Modified-Since：客服端再次发起请求时，携带上次请求返回的Last-Modified值，</span></span><br><span class="line">            <span class="comment">//服务端用携带的值和服务器的Etag值作对比，一致则返回304</span></span><br><span class="line">            Map&lt;String, String&gt; additionalRequestHeaders =</span><br><span class="line">                getCacheHeaders(request.getCacheEntry());</span><br><span class="line">            <span class="comment">//因为现在一般的sdk都是大于9的，那么这里执行的就是HurlStack的executeRequest方法，</span></span><br><span class="line">            <span class="comment">//执行网络请求，和我们平时使用HttpURLConnection请求网络大致相同</span></span><br><span class="line">            httpResponse = mBaseHttpStack.executeRequest(request, additionalRequestHeaders);</span><br><span class="line">            <span class="keyword">int</span> statusCode = httpResponse.getStatusCode();</span><br><span class="line"></span><br><span class="line">            responseHeaders = httpResponse.getHeaders();</span><br><span class="line">            <span class="comment">// 服务端返回304时，那么就表示资源无更新，可以继续使用缓存的值</span></span><br><span class="line">            <span class="keyword">if</span> (statusCode == HttpURLConnection.HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">                Entry entry = request.getCacheEntry();</span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(</span><br><span class="line">                        HttpURLConnection.HTTP_NOT_MODIFIED,</span><br><span class="line">                        <span class="comment">/* data= */</span> <span class="keyword">null</span>,</span><br><span class="line">                        <span class="comment">/* notModified= */</span> <span class="keyword">true</span>,</span><br><span class="line">                        SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                        responseHeaders);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将缓存头和响应头组合在一起，一次响应就完成了</span></span><br><span class="line">                List&lt;Header&gt; combinedHeaders = combineHeaders(responseHeaders, entry);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(</span><br><span class="line">                    HttpURLConnection.HTTP_NOT_MODIFIED,</span><br><span class="line">                    entry.data,</span><br><span class="line">                    <span class="comment">/* notModified= */</span> <span class="keyword">true</span>,</span><br><span class="line">                    SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                    combinedHeaders);</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 如果返回204，执行成功，没有数据，这里需要检查</span></span><br><span class="line">            InputStream inputStream = httpResponse.getContent();</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                responseContents =</span><br><span class="line">                    inputStreamToBytes(inputStream, httpResponse.getContentLength());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//返回204，就返回一个空的byte数组</span></span><br><span class="line">                responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if the request is slow, log it.</span></span><br><span class="line">            <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">            logSlowRequests(requestLifetime, request, responseContents, statusCode);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(</span><br><span class="line">                statusCode,</span><br><span class="line">                responseContents,</span><br><span class="line">                <span class="comment">/* notModified= */</span> <span class="keyword">false</span>,</span><br><span class="line">                SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                responseHeaders);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">            <span class="comment">//异常进行重新请求等...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要执行了添加缓存头并发起网络请求，然后将返回值组装成一个 <code>NetworkResponse</code> 值返回，接下来我们看看是如何解析这个值的，解析是由 <code>Request</code> 的子类去实现的，我们就看系统提供的 <code>StringRequest</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"DefaultCharset"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Response&lt;String&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">    String parsed;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsed = <span class="keyword">new</span> String(response.data, HttpHeaderParser.parseCharset(response.headers));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// Since minSdkVersion = 8, we can't call</span></span><br><span class="line">        <span class="comment">// new String(response.data, Charset.defaultCharset())</span></span><br><span class="line">        <span class="comment">// So suppress the warning instead.</span></span><br><span class="line">        parsed = <span class="keyword">new</span> String(response.data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到将值组装成一个String，然后组装成一个 <code>Response</code> 返回，接下来看看这里如何将这个值回调给用户的这个方法<code>mDelivery.postResponse(request, response)</code>，这里我们先重点看看这个类 <code>ExecutorDelivery</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorDelivery</span> <span class="keyword">implements</span> <span class="title">ResponseDelivery</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造执行已提交的Runnable任务对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor mResponsePoster;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//这里在RequestQueue构造参数中初始化，new ExecutorDelivery(new Handler(Looper.getMainLooper()))，</span></span><br><span class="line">   <span class="comment">//那么这里runnable就通过绑定主线程的Looper的Handler对象投递到主线程中执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make an Executor that just wraps the handler.</span></span><br><span class="line">        mResponsePoster =</span><br><span class="line">                <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">                        handler.post(command);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        mResponsePoster = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法就是我们NetworkDispatcher里面调用的方法，调用下面这个三个参数的构造方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123;</span><br><span class="line">        postResponse(request, response, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">        request.markDelivered();</span><br><span class="line">        request.addMarker(<span class="string">"post-response"</span>);</span><br><span class="line">        <span class="comment">//构造了一个ResponseDeliveryRunnable类，传入execute，现在这个runnable就是在主线程里执行</span></span><br><span class="line">        mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span> </span>&#123;</span><br><span class="line">        request.addMarker(<span class="string">"post-error"</span>);</span><br><span class="line">        Response&lt;?&gt; response = Response.error(error);</span><br><span class="line">        mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A Runnable used for delivering network responses to a listener on the main thread. */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDeliveryRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Request mRequest;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Response mResponse;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Runnable mRunnable;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ResponseDeliveryRunnable</span><span class="params">(Request request, Response response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">            mRequest = request;</span><br><span class="line">            mResponse = response;</span><br><span class="line">            mRunnable = runnable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//请求取消，那么就不分发给用户</span></span><br><span class="line">            <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</span><br><span class="line">                mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据isSuccess这个值来提供相应的回调给用户，调用Response会通过error的值是否为null来确定这个值，</span></span><br><span class="line">            <span class="comment">//我们调用VolleyError这个构造函数的时候就为这个值就为false</span></span><br><span class="line">            <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">                mRequest.deliverResponse(mResponse.result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mRequest.deliverError(mResponse.error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果这是一个在新鲜的时间内的请求的响应，就添加一个标记，否则就结束</span></span><br><span class="line">            <span class="keyword">if</span> (mResponse.intermediate) &#123;</span><br><span class="line">                mRequest.addMarker(<span class="string">"intermediate-response"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mRequest.finish(<span class="string">"done"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在CacheDispatcher里面当请求第一次请求时直接调用三个参数的构造方法，通过这个runnable就执行run方法</span></span><br><span class="line">            <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mRunnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面方法主要是将值回调给用户，那么整个网络请求大致就完成了，其中还涉及很多细节的东西，但是大致流程是走通了，不得不说这个库有很多值得我们学习的地方。</p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>现在我们看官网的一张图，总结一下整个流程：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="//wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/volley.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li>蓝色是主线程</li>
<li>绿色是缓存线程</li>
<li>黄色是网络线程  </li>
</ul>
<p>我们可以看到首先是请求添加到 <code>RequestQueue</code> 里，首先是添加到缓存队列，然后查看是否已经缓存，如果有并且在有效期内的缓存直接回调给用户，如果没有查找到，那么则需要添加到网络请求队列重新请求并且解析响应、写入缓存在发送到主线程给用户回调。</p>
<h4 id="参考以及相关链接"><a href="#参考以及相关链接" class="headerlink" title="参考以及相关链接"></a>参考以及相关链接</h4><ul>
<li><a href="https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA" target="_blank" rel="noopener">【第1250期】彻底理解浏览器的缓存机制</a></li>
<li><a href="https://blog.csdn.net/guolin_blog/article/details/17656437" target="_blank" rel="noopener">Android Volley完全解析(四)，带你从源码的角度理解Volley</a></li>
<li><a href="https://github.com/wangzhengyi/Volley" target="_blank" rel="noopener">Volley 源码解析</a></li>
<li><a href="http://codekk.com/open-source-project-analysis/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="noopener">Volley 源码解析</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-03-06T09:43:32.606Z" itemprop="dateUpdated">2020-03-06 17:43:32</time>
</span><br>


        
        如需转发请注明出处：<a href="/2020/03/05/Volley-源码解析之网络请求/" target="_blank" rel="external">https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/</a>
        
    </div>
    <footer>
        <a href="https://wvisible.github.io">
            <img src="/img/avatar.jpg" alt="哆啦A梦Doraemon">
            哆啦A梦Doraemon
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volley/">Volley</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/&title=《Volley 源码解析之网络请求》 — 哆啦A梦Doraemon&pic=https://wvisible.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/&title=《Volley 源码解析之网络请求》 — 哆啦A梦Doraemon&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Volley 源码解析之网络请求》 — 哆啦A梦Doraemon&url=https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/&via=https://wvisible.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/03/05/Volley-源码解析之图片请求/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Volley 源码解析之图片请求</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/10/07/Java-8-Lambda-指南/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Java 8 Lambda 指南</h4>
      </a>
    </div>
  
</nav>



    











</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>哆啦A梦Doraemon &copy; 2015 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/&title=《Volley 源码解析之网络请求》 — 哆啦A梦Doraemon&pic=https://wvisible.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/&title=《Volley 源码解析之网络请求》 — 哆啦A梦Doraemon&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Volley 源码解析之网络请求》 — 哆啦A梦Doraemon&url=https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/&via=https://wvisible.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACsklEQVR42u3ay3LcMAwEQP//T9vnVCztDChsbSqtk8qrB5sHER7w6ys+vm+P5N6r87+fcHVN8q7hgYeHh7cw9O/gyAd0Bc55xXTj4eHhrfHaQbSLwf0Tkne11+Dh4eF9Jq8tl5P3Jk/Dw8PD+7d49wVu8sr7Qjkh4eHh4X0CL4kY8rvaqKKdvpWsBQ8PD2/esaqbWO8/X+nv4eHh4R131dvm0/lHPIknitHi4eHhLfDyD+79gE4ChbZYr8eJh4eHt8bLhz5rerULQx4Wv/gLHh4e3qO87cb/rP2fLEj3ofCb9jXg4eH9x7ynGMlktWV0+7RoxcPDw8M75s2aYflw86J5NsUP34aHh4c32hbQRqj5Jq18Q0A7QVEDDA8PD2+Bl7wyec2sGZYzitgCDw8Pb4GXDDEZSlv4tjHuEIaHh4f3KO+EMQte220B+dt/eQ4eHh7eAq+NA2bns0K8bXrVbTA8PDy8Y97JI/JYIY9okyujIh4PDw/vUd5JAd3Grye9/nbLAh4eHt427zwJPtkW0G5KKIp4PDw8vGXeSXQ7C23z4j7/9Y9zPDw8vAXeLFZoo4FZdNsel/fi4eHhPcpL/rFvy9k8RGgL+nrLFx4eHt4CL29Ztc2ntiyebSBIRouHh4e3x5vdnJTF+QIwG+GLqcfDw8N7Oy8PZzc+/edTg4eHh7fHmw0xaXHNQt52WcLDw8N7Py+Ja2cLw3mhfLSw4eHh4T3Km7WmkkHMPuizaPjyVzw8PLwF3vnHt91YkEcSs/PhgYeHh1fy2sWgRSb5QBtVJIEIHh4e3jYveXQe+57semrL4heTi4eHh/cBvPNiN2+V5bHFYwsDHh4e3gfUnEkYMWvFRZEEHh4e3hovKXzza05Is4D4EomHh4e3wGv/4W/jg3zKjkrn8/4eHh4e3mveD0wQIhYmjZEaAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '哆啦A梦Doraemon';
            clearTimeout(titleTime);
        } else {
            document.title = '哆啦A梦Doraemon';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
