{"meta":{"title":"哆啦A梦Doraemon","subtitle":"So we beat on, boats against the current, borne back ceaselessly into the past.","description":null,"author":"哆啦A梦Doraemon","url":"https://wvisible.github.io"},"pages":[{"title":"","date":"2020-03-05T14:26:35.292Z","updated":"2017-11-16T16:00:10.000Z","comments":true,"path":"404.html","permalink":"https://wvisible.github.io/404.html","excerpt":"","text":"404"},{"title":"标签","date":"2017-11-16T15:54:36.000Z","updated":"2020-03-06T06:56:52.070Z","comments":true,"path":"tags/index.html","permalink":"https://wvisible.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-11-16T15:55:06.000Z","updated":"2020-03-06T06:56:37.467Z","comments":true,"path":"categories/index.html","permalink":"https://wvisible.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Volley 源码解析之缓存机制","slug":"Volley-源码解析之缓存机制","date":"2020-03-05T15:45:42.000Z","updated":"2020-03-06T08:48:58.860Z","comments":true,"path":"2020/03/05/Volley-源码解析之缓存机制/","link":"","permalink":"https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/","excerpt":"","text":"一、前言前面我们分析了 Volley 的网络请求的相关流程以及图片加载的源码，如果没有看过的话可以阅读一下，接下来我们分析 Volley 的缓存，看看是怎么处理缓存超时、缓存更新以及缓存的整个流程，掌握 Volley 的缓存设计，对整个 Volley 的源码以及细节一个比较完整的认识。 二、 源码分析我们首先看看 Cache 这个缓存接口：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public interface Cache &#123; //通过key获取指定请求的缓存实体 Entry get(String key); //存入指定的缓存实体 void put(String key, Entry entry); //初始化缓存 void initialize(); //使缓存中的指定请求实体过期 void invalidate(String key, boolean fullExpire); //移除指定的请求缓存实体 void remove(String key); //清空缓存 void clear(); class Entry &#123; //请求返回的数据 public byte[] data; //用于缓存验证的http请求头Etag public String etag; //Http 请求响应产生的时间 public long serverDate; //最后修改时间 public long lastModified; //过期时间 public long ttl; //新鲜度时间 public long softTtl; public Map&lt;String, String&gt; responseHeaders = Collections.emptyMap(); public List&lt;Header&gt; allResponseHeaders; //返回true则过期 public boolean isExpired() &#123; return this.ttl &lt; System.currentTimeMillis(); &#125; //需要从原始数据源刷新，则为true public boolean refreshNeeded() &#123; return this.softTtl &lt; System.currentTimeMillis(); &#125; &#125;&#125; 存储的实体就是响应，以字节数组作为数据的请求URL为键的缓存接口。接下来我们看看 HttpHeaderParser 中用于解析 http 头的方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public static Cache.Entry parseCacheHeaders(NetworkResponse response) &#123; long now = System.currentTimeMillis(); Map&lt;String, String&gt; headers = response.headers; long serverDate = 0; long lastModified = 0; long serverExpires = 0; long softExpire = 0; long finalExpire = 0; long maxAge = 0; long staleWhileRevalidate = 0; boolean hasCacheControl = false; boolean mustRevalidate = false; String serverEtag = null; String headerValue; //表示收到响应的时间 headerValue = headers.get(&quot;Date&quot;); if (headerValue != null) &#123; serverDate = parseDateAsEpoch(headerValue); &#125; //Cache-Control用于定义资源的缓存策略，在HTTP/1.1中，Cache-Control是 最重要的规则，取代了 Expires headerValue = headers.get(&quot;Cache-Control&quot;); if (headerValue != null) &#123; hasCacheControl = true; String[] tokens = headerValue.split(&quot;,&quot;, 0); for (int i = 0; i &lt; tokens.length; i++) &#123; String token = tokens[i].trim(); //no-cache：客户端缓存内容，每次都要向服务器重新验证资源是否 被更改，但是是否使用缓存则需要经过协商缓存来验证决定， no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 这两种情况不缓存返回null if (token.equals(&quot;no-cache&quot;) || token.equals(&quot;no-store&quot;)) &#123; return null; //max-age：设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒) &#125; else if (token.startsWith(&quot;max-age=&quot;)) &#123; try &#123; maxAge = Long.parseLong(token.substring(8)); &#125; catch (Exception e) &#123; &#125; //stale-while-revalidate：表明客户端愿意接受陈旧的响应，同时 在后台异步检查新的响应。秒值指示客户愿意接受陈旧响应的时间长度 &#125; else if (token.startsWith(&quot;stale-while-revalidate=&quot;)) &#123; try &#123; staleWhileRevalidate = Long.parseLong(token.substring(23)); &#125; catch (Exception e) &#123; &#125; //must-revalidate：缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。 并不是说「每次都要验证」，它意味着某个资源在本地已缓存时长短于 max-age 指定时 长时，可以直接使用，否则就要发起验证 proxy-revalidate：与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。 &#125; else if (token.equals(&quot;must-revalidate&quot;) || token.equals(&quot;proxy-revalidate&quot;)) &#123; mustRevalidate = true; &#125; &#125; &#125; //Expires 是 HTTP/1.0的控制手段，其值为服务器返回该请求结果 缓存的到期时间 headerValue = headers.get(&quot;Expires&quot;); if (headerValue != null) &#123; serverExpires = parseDateAsEpoch(headerValue); &#125; // Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间 headerValue = headers.get(&quot;Last-Modified&quot;); if (headerValue != null) &#123; lastModified = parseDateAsEpoch(headerValue); &#125; //Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成) serverEtag = headers.get(&quot;ETag&quot;); // Cache-Control 优先 Expires 字段,请求头包含 Cache-Control，计算缓存的ttl和softTtl if (hasCacheControl) &#123; //新鲜度时间只跟maxAge有关 softExpire = now + maxAge * 1000; // 最终过期时间分两种情况：如果mustRevalidate为true，即需要验证新鲜度， 那么直接跟新鲜度时间一样的，另一种情况是新鲜度时间 + 陈旧的响应时间 * 1000 finalExpire = mustRevalidate ? softExpire : softExpire + staleWhileRevalidate * 1000; // 如果不包含Cache-Control头 &#125; else if (serverDate &gt; 0 &amp;&amp; serverExpires &gt;= serverDate) &#123; // 缓存失效时间的计算 softExpire = now + (serverExpires - serverDate); // 最终过期时间跟新鲜度时间一致 finalExpire = softExpire; &#125; Cache.Entry entry = new Cache.Entry(); entry.data = response.data; entry.etag = serverEtag; entry.softTtl = softExpire; entry.ttl = finalExpire; entry.serverDate = serverDate; entry.lastModified = lastModified; entry.responseHeaders = headers; entry.allResponseHeaders = response.allHeaders; return entry; &#125; 这里主要是对请求头的缓存字段进行解析，并对缓存的相关字段赋值，特别是过期时间的计算要考虑到不同缓存头部的区别，以及每个缓存请求头的含义；上面讲到的 stale-while-revalidate 这个字段举个例子： Cache-Control: max-age=600, stale-while-revalidate=30 这个响应表明当前响应内容新鲜时间为 600 秒，以及额外的 30 秒可以用来容忍过期缓存，服务器会将 max-age 和 stale-while-revalidate 的时间加在一起作为潜在最长可容忍的新鲜度时间，所有的响应都由缓存提供;不过在容忍过期缓存时间内,先直接从缓存中获取响应返回给调用者，然后在静默的在后台向原始服务器发起一次异步请求,然后在后台静默的更新缓存内容。 这部分代码都是关于HTTP缓存的相关知识，我下面给出一些我参考引用的链接，大家可以去学习相关知识。 我们接下来继续看缓存的实现类 DiskBasedCache，将缓存文件直接缓存到指定目录下的硬盘上，我们首先看看构造方法：12345678public DiskBasedCache(File rootDirectory, int maxCacheSizeInBytes) &#123; mRootDirectory = rootDirectory; mMaxCacheSizeInBytes = maxCacheSizeInBytes; &#125;public DiskBasedCache(File rootDirectory) &#123; this(rootDirectory, DEFAULT_DISK_USAGE_BYTES);&#125; 构造方法做了两件事，指定硬盘缓存的文件夹以及缓存的大小，默认5M。我们首先看看初始化方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445public synchronized void initialize() &#123; //如果缓存文件夹不存在则创建文件夹 if (!mRootDirectory.exists()) &#123; if (!mRootDirectory.mkdirs()) &#123; VolleyLog.e(&quot;Unable to create cache dir %s&quot;, mRootDirectory.getAbsolutePath()); &#125; return; &#125; File[] files = mRootDirectory.listFiles(); if (files == null) &#123; return; &#125; for (File file : files) &#123; try &#123; long entrySize = file.length(); CountingInputStream cis = new CountingInputStream( new BufferedInputStream(createInputStream(file)), entrySize); try &#123; CacheHeader entry = CacheHeader.readHeader(cis); // 初始化的时候更新缓存大小为文件大小 entry.size = entrySize; // 将已经存在的缓存存入到映射表中 putEntry(entry.key, entry); &#125; finally &#123; // Any IOException thrown here is handled by the below catch block by design. //noinspection ThrowFromFinallyBlock cis.close(); &#125; &#125; catch (IOException e) &#123; //noinspection ResultOfMethodCallIgnored file.delete(); &#125; &#125; &#125;//将 key 和 CacheHeader 存入到 map 对象当中，然后更新当前字节数private void putEntry(String key, CacheHeader entry) &#123; if (!mEntries.containsKey(key)) &#123; mTotalSize += entry.size; &#125; else &#123; CacheHeader oldEntry = mEntries.get(key); mTotalSize += (entry.size - oldEntry.size); &#125; mEntries.put(key, entry);&#125; 初始化这里首先判断了缓存文件夹是否存在，不存在就要新建文件夹，这个很好理解。如果存在了就会将原来的已经存在的文件夹依次读取并存入一个缓存映射表中，方便后续判断有无缓存，不用直接从磁盘缓存中去查找文件名判断有无缓存。一般每个请求都会有一个 CacheHeader，然后将存在的缓存头里的 size 重新赋值，初始化时大小为文件大小，存入数据为数据的大小。这里提一下 CacheHeader 是一个静态内部类，跟 Cache 的 Entry 有点像，少了一个 byte[] data 数组，其中维护了缓存头部的相关字段，这样设计的原因是方便快速读取，合理利用内存空间，因为缓存的相关信息需要频繁读取，内存占用小，可以缓存到内存中，但是网络请求的响应数据是非常占地方的，很容易就占满空间了，需要单独存储到硬盘中。我们看下存入的方法：12345678910111213141516171819202122232425262728@Overridepublic synchronized void put(String key, Entry entry) &#123; //首先进行缓存剩余空间的大小判断 pruneIfNeeded(entry.data.length); File file = getFileForKey(key); try &#123; BufferedOutputStream fos = new BufferedOutputStream(createOutputStream(file)); CacheHeader e = new CacheHeader(key, entry); //CacheHeader 写入到磁盘 boolean success = e.writeHeader(fos); if (!success) &#123; fos.close(); VolleyLog.d(&quot;Failed to write header for %s&quot;, file.getAbsolutePath()); throw new IOException(); &#125; //网络请求的响应数据写入到磁盘 fos.write(entry.data); fos.close(); //头部信息等存储到到映射表 putEntry(key, e); return; &#125; catch (IOException e) &#123; &#125; boolean deleted = file.delete(); if (!deleted) &#123; VolleyLog.d(&quot;Could not clean up file %s&quot;, file.getAbsolutePath()); &#125;&#125; 这个方法比较简单就是将响应数据以及缓存的头部信息写入到磁盘并且将头部缓存到内存中，我们看下当缓存空间不足，是怎么考虑缓存替换的：123456789101112131415161718192021222324252627282930313233343536 private void pruneIfNeeded(int neededSpace) &#123; //缓存当前已经使用的空间总字节数 + 待存入的文件字节数是否大于缓存的最大大小， 默认为5M，也可以自己指定，如果大于就要进行删除以前的缓存 if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes) &#123; return; &#125; long before = mTotalSize; // 删除的文件数量 int prunedFiles = 0; long startTime = SystemClock.elapsedRealtime(); Iterator&lt;Map.Entry&lt;String, CacheHeader&gt;&gt; iterator = mEntries.entrySet().iterator(); //遍历mEntries中所有的缓存 while (iterator.hasNext()) &#123; Map.Entry&lt;String, CacheHeader&gt; entry = iterator.next(); CacheHeader e = entry.getValue(); //因为mEntries是一个访问有序的LinkedHashMap，经常访问的会被移动到末尾， 所以这里的思想就是 LRU 缓存算法 boolean deleted = getFileForKey(e.key).delete(); if (deleted) &#123; //删除成功过后减少当前空间的总字节数 mTotalSize -= e.size; &#125; else &#123; VolleyLog.d( &quot;Could not delete cache entry for key=%s, filename=%s&quot;, e.key, getFilenameForKey(e.key)); &#125; iterator.remove(); prunedFiles++; //最后判断当前的空间是否满足新存入申请的空间大小，满足就跳出循环 if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) &#123; break; &#125; &#125;&#125; 这里的缓存替换策略也很好理解，如果不加以限制，那么岂不是一直写入数据到磁盘，有很多不用的数据很快就把磁盘写满了，所以使用了 LRU 缓存替换算法。接下来我们看看存储的 key，即缓存文件名生成方法：123456private String getFilenameForKey(String key) &#123; int firstHalfLength = key.length() / 2; String localFilename = String.valueOf(key.substring(0, firstHalfLength).hashCode()); localFilename += String.valueOf(key.substring(firstHalfLength).hashCode()); return localFilename;&#125; 首先将请求的 url 分成两部分，然后两部分分别求 hashCode，最后拼接起来。如果我们使用 volley 来请求数据，那么通常是同一个地址中后面的不一样，很多字符一样，那么这样做可以避免 hashCode 重复造成文件名重复，创造更多的差异，因为hash 在 Java 中不是那么可靠,关于这个问题我们可以在这篇文章中找到解答面试后的总结然后我们看下 get 方法：12345678910111213141516171819202122232425262728293031323334@Override public synchronized Entry get(String key) &#123; CacheHeader entry = mEntries.get(key); // 如果entry不存在，则返回null if (entry == null) &#123; return null; &#125; //获取缓存的文件 File file = getFileForKey(key); try &#123; //这个类的作用是通过bytesRead记录已经读取的字节数 CountingInputStream cis = new CountingInputStream( new BufferedInputStream(createInputStream(file)), file.length()); try &#123; //从磁盘获取缓存的CacheHeader CacheHeader entryOnDisk = CacheHeader.readHeader(cis); //如果传递进来的key和磁盘缓存中CacheHeader的key不相等，那么从内存缓存中 移除这个缓存 if (!TextUtils.equals(key, entryOnDisk.key)) &#123; removeEntry(key); return null; &#125; //读取缓存文件中的http响应体内容，然后创建一个entry返回 byte[] data = streamToBytes(cis, cis.bytesRemaining()); return entry.toCacheEntry(data); &#125; finally &#123; cis.close(); &#125; &#125; catch (IOException e) &#123; remove(key); return null; &#125; &#125; 取数据首先从内存缓存中取出 CacheHeader，如果为 null 那么直接返回，接下来如果取到了缓存，那么直接从磁盘里读取 CacheHeader，如果存在两个 key 映射一个文件，那么就从内存缓存中移除这个缓存，最后将读取的文件组装成一个entry 返回。这里有个疑问就是什么时候存在两个 key 映射一个文件呢？我们知道每个内存缓存中的 key 是我们请求的 url，而磁盘缓存的文件名则是根据 key 的 hash 值计算得出，那么个人猜测有可能算出的文件名重复了，那么就会出现两个 key 对应一个文件，那么为了避免这种情况，需要先判断，出现了先从内存缓存移除，一般来说这种情况很少。 我们看看从 CountingInputStream 读取字节的方法12345678910static byte[] streamToBytes(CountingInputStream cis, long length) throws IOException &#123; long maxLength = cis.bytesRemaining(); // 读取的字节数不能为负数，不能大于当前剩余的字节数，还有不能整型溢出 if (length &lt; 0 || length &gt; maxLength || (int) length != length) &#123; throw new IOException(&quot;streamToBytes length=&quot; + length + &quot;, maxLength=&quot; + maxLength); &#125; byte[] bytes = new byte[(int) length]; new DataInputStream(cis).readFully(bytes); return bytes; &#125; 这个方法是从 CountingInputStream 读取响应头还有响应体，怎么实现分开读取的呢，因为文件缓存首先是缓存的CacheHeader，接下来会从总的字节数减去已经读取的字节数，那么剩下的字节数就是响应体了。读取响应头是依次读取的，首先会先读取魔数判断是否是写入的缓存，然后依次读取各个 CacheHeader 字段，最后剩下的就是响应体了，读取和写入的顺序要一致。 看一看缓存的清除方法：123456789101112@Overridepublic synchronized void clear() &#123; File[] files = mRootDirectory.listFiles(); if (files != null) &#123; for (File file : files) &#123; file.delete(); &#125; &#125; mEntries.clear(); mTotalSize = 0; VolleyLog.d(&quot;Cache cleared.&quot;);&#125; 遍历磁盘的每一个缓存文件并删除，清除内存缓存，更新使 size 为0。接下来看看使某一个缓存 key 无效的方法1234567891011@Overridepublic synchronized void invalidate(String key, boolean fullExpire) &#123; Entry entry = get(key); if (entry != null) &#123; entry.softTtl = 0; if (fullExpire) &#123; entry.ttl = 0; &#125; put(key, entry); &#125;&#125; 这里主要对传入的 key 使缓存新鲜度无效，然后根据传入的第二个值是否为 true，如果为 true 那么所有缓存都过期，否则只是缓存新鲜度过期，这里对 softTtl 和 ttl 值置为0，判断缓存过期的时候自然就小于当前时间返回 true，达到了过期的目的，最后存入内存缓存和磁盘缓存当中。 接下来我们看看一个特殊的类 NoCache：123456789101112131415161718192021public class NoCache implements Cache &#123; @Override public void clear() &#123;&#125; @Override public Entry get(String key) &#123; return null; &#125; @Override public void put(String key, Entry entry) &#123;&#125; @Override public void invalidate(String key, boolean fullExpire) &#123;&#125; @Override public void remove(String key) &#123;&#125; @Override public void initialize() &#123;&#125;&#125; 实现 Cache 接口，不做任何操作的缓存实现类，可将它作为 RequestQueue 的参数实现一个默认不缓存的请求队列，后续取到的缓存都为 null。 三、缓存的使用我们梳理下整个流程，看这几个方法的调用时期：123456private static RequestQueue newRequestQueue(Context context, Network network) &#123; File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR); RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network); queue.start(); return queue;&#125; 首先这里调用了 DiskBasedCache 的构造方法，缓存默认大小是5M，缓存文件夹为 volley。然后在 CacheDispatcher 的 run 方法里面实现了调用：1234567891011121314151617181920212223 @Overridepublic void run() &#123; if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // Make a blocking call to initialize the cache. mCache.initialize(); while (true) &#123; try &#123; processRequest(); &#125; catch (InterruptedException e) &#123; // We may have been interrupted because it was time to quit. if (mQuit) &#123; Thread.currentThread().interrupt(); return; &#125; VolleyLog.e( &quot;Ignoring spurious interrupt of CacheDispatcher thread; &quot; + &quot;use quit() to terminate it&quot;); &#125; &#125;&#125; 这个类前面我们分析过，发起网络请求的时候会启动五个线程，一个缓存请求线程，四个网络请求分发的线程。首先在缓存线程里执行了缓存的初始化，如果关闭了应用那么重新发起请求的时候原来的缓存会重新缓存到到内存中。 然后在 CacheDispatcher 里发起请求之前首先会从磁盘缓存获取缓存的内容：1Cache.Entry entry = mCache.get(request.getCacheKey()); 然后在 NetworkDispatcher 的请求到数据并缓存到根据 url 生成的缓存键的磁盘缓存中，缓存键默认是 url。1234if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123; mCache.put(request.getCacheKey(), response.cacheEntry); request.addMarker(&quot;network-cache-written&quot;);&#125; 四、 总结Volley 的缓存机制分析完毕了，可以看出 Volley 缓存设计考虑了很多细节，对各种缓存头的解析，将请求的响应和缓存头的相关信息缓存到磁盘缓存，缓存头的信息也缓存到内存缓存，将二者很好的联系起来，便于读取和查找缓存等一系列操作。缓存命中率、缓存的替换算法、缓存文件名的计算、使用接口抽象等设计都值得我们认真学习。 参考链接Volley的缓存机制Cache-Control 缓存最佳实践及 max-age 注意事项Cache-Control扩展面试后的总结","categories":[{"name":"源码解析","slug":"源码解析","permalink":"https://wvisible.github.io/categories/源码解析/"}],"tags":[{"name":"Volley","slug":"Volley","permalink":"https://wvisible.github.io/tags/Volley/"}]},{"title":"Volley 源码解析之图片请求","slug":"Volley-源码解析之图片请求","date":"2020-03-05T15:45:28.000Z","updated":"2020-03-06T08:42:03.273Z","comments":true,"path":"2020/03/05/Volley-源码解析之图片请求/","link":"","permalink":"https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/","excerpt":"","text":"一、前言上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章Volley 源码解析之网络请求。Volley 不仅仅对请求网络数据作了良好的封装，还封装了对图片的加载等操作，虽然比不上 Glide、Fresco，不过可以满足我们的日常使用，从学习者的角度看看是怎么封装的。上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章Volley 源码解析之网络请求。Volley 不仅仅对请求网络数据作了良好的封装，还封装了对图片的加载等操作，虽然比不上 Glide、Fresco，不过可以满足我们的日常使用，从学习者的角度看看是怎么封装的。 二、简单使用 使用 ImageRequest 加载图片，用法跟请求网络的用法差不多，只是构造request的参数不太一样： 1234567String imageUrl = &quot;https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;;RequestQueue queue = Volley.newRequestQueue(this);ImageRequest imageRequest = new ImageRequest(imageUrl, response -&gt; imageView.setImageBitmap(response), 0, 0, ImageView.ScaleType.CENTER_CROP, Bitmap.Config.ARGB_8888, error -&gt; &#123;&#125;);queue.add(imageRequest); 第一个参数是图片地址没啥说的 第二个参数是成功的回调，返回一个bitmap 第三和第四个参数则是图片的最大的高度和宽度，0为默认图片大小，如果填写的图片最大的高度和宽度小于图片的实际尺寸则会进行压缩 第五个值就是对图片进行边界缩放 第六个参数是图片的格式，常用的就是 RGB_565 和 ARGB_8888，前者每个像素占2个字节，后者每个像素占4个字节，后者成像质量高，有alpha通道，如果使用的是jpg，不需要alpha通道则可以使用前者； 还有个 ARGB_4444，不过已经废弃了，在4.4以后默认转成 ARGB_8888， ALPHA_8 只有透明度，没有颜色值，一般很少使用 最后个参数就是错误的回调 使用 ImageLoader 加载图片 123456789101112131415161718192021222324252627282930String imageUrl = &quot;https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;;RequestQueue queue = Volley.newRequestQueue(this);ImageLoader imageLoader = new ImageLoader(queue, new BitmapCache());ImageLoader.ImageListener imageListener = ImageLoader.getImageListener(imageView, R.mipmap.ic_launcher, R.mipmap.ic_launcher_round);imageLoader.get(imageUrl, imageListener, 0, 0);private class BitmapCache implements ImageLoader.ImageCache&#123; private LruCache&lt;String, Bitmap&gt; lruCache; public BitmapCache() &#123; int maxSize = 10 * 1024 * 1024; lruCache = new LruCache&lt;String, Bitmap&gt;(maxSize) &#123; @Override protected int sizeOf(String key, Bitmap bitmap) &#123; return bitmap.getRowBytes() * bitmap.getHeight(); &#125; &#125;; &#125; @Override public Bitmap getBitmap(String url) &#123; return lruCache.get(url); &#125; @Override public void putBitmap(String url, Bitmap bitmap) &#123; lruCache.put(url, bitmap); &#125;&#125; 使用 NetworkImageView 加载图片 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;8dp&quot; android:layout_marginTop=&quot;88dp&quot; android:layout_marginEnd=&quot;8dp&quot; android:text=&quot;Button&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;com.android.volley.toolbox.NetworkImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;8dp&quot; android:layout_marginTop=&quot;32dp&quot; android:layout_marginEnd=&quot;8dp&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/textView&quot; tools:srcCompat=&quot;@tools:sample/avatars&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 12345String imageUrl = &quot;https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;;NetworkImageView networkImageView = findViewById(R.id.imageView);networkImageView.setDefaultImageResId(R.mipmap.ic_launcher);networkImageView.setErrorImageResId(R.mipmap.ic_launcher_round);networkImageView.setImageUrl(imageUrl, imageLoader); 三、源码分析一、 ImageRequest 分析首先我们分析 ImageRequest，直接分析这个类，代码不多，直接继承 Request，那么不用说跟上一篇我们分析的网络请求的request 大体相同，不同的是这个是请求图片，如果我们需要自定义大小那么这里就对图片进行了裁剪以满足我们的大小：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221public class ImageRequest extends Request&lt;Bitmap&gt; &#123; //图片请求的超时时间，单位毫秒 public static final int DEFAULT_IMAGE_TIMEOUT_MS = 1000; //图片请求的默认重试次数 public static final int DEFAULT_IMAGE_MAX_RETRIES = 2; //发生冲突时的默认重传延迟增加数，和TCP协议有关系，退避算法，短时间的重复请求失败还会是失败 public static final float DEFAULT_IMAGE_BACKOFF_MULT = 2f; //对mListener加锁，保证线程安全，避免取消的时候同时执行分发 private final Object mLock = new Object(); @GuardedBy(&quot;mLock&quot;) @Nullable private Response.Listener&lt;Bitmap&gt; mListener; private final Config mDecodeConfig; private final int mMaxWidth; private final int mMaxHeight; private final ScaleType mScaleType; //Bitmap 的同步解析锁，保证一个时间内只有一个Bitmap被加载到内存进行解析，避免多个同时解析oom private static final Object sDecodeLock = new Object(); public ImageRequest( String url, Response.Listener&lt;Bitmap&gt; listener, int maxWidth, int maxHeight, ScaleType scaleType, Config decodeConfig, @Nullable Response.ErrorListener errorListener) &#123; super(Method.GET, url, errorListener); setRetryPolicy( new DefaultRetryPolicy( DEFAULT_IMAGE_TIMEOUT_MS, DEFAULT_IMAGE_MAX_RETRIES, DEFAULT_IMAGE_BACKOFF_MULT)); mListener = listener; mDecodeConfig = decodeConfig; mMaxWidth = maxWidth; mMaxHeight = maxHeight; mScaleType = scaleType; &#125; @Deprecated public ImageRequest( String url, Response.Listener&lt;Bitmap&gt; listener, int maxWidth, int maxHeight, Config decodeConfig, Response.ErrorListener errorListener) &#123; this( url, listener, maxWidth, maxHeight, ScaleType.CENTER_INSIDE, decodeConfig, errorListener); &#125; @Override public Priority getPriority() &#123; return Priority.LOW; &#125; //根据ScaleType设置图片大小 private static int getResizedDimension( int maxPrimary, int maxSecondary, int actualPrimary, int actualSecondary, ScaleType scaleType) &#123; // 如果主要值和次要的值为0，就返回实际值，如果我们计算宽度的期望值， 那么主要值就是宽度，高度就是次要值，反之亦然 if ((maxPrimary == 0) &amp;&amp; (maxSecondary == 0)) &#123; return actualPrimary; &#125; // 如果为ScaleType.FIT_XY，填充整个矩形，忽略比值； 即如果主要的值为0则返回实际值，否则返回传入的值 if (scaleType == ScaleType.FIT_XY) &#123; if (maxPrimary == 0) &#123; return actualPrimary; &#125; return maxPrimary; &#125; // 如果主要的值为0，则通过比例值计算出主要的值返回 if (maxPrimary == 0) &#123; double ratio = (double) maxSecondary / (double) actualSecondary; return (int) (actualPrimary * ratio); &#125; // 次要的值为0，下面的比例调整就是多余的，那么直接返回主要的值， if (maxSecondary == 0) &#123; return maxPrimary; &#125; // 图片真实尺寸大小的比例，通过这个比例我们可以计算出次要的最大值，通 过计算出的值和我们传递进来的值做比较 double ratio = (double) actualSecondary / (double) actualPrimary; int resized = maxPrimary; // 如果是ScaleType.CENTER_CROP，填充整个矩形，保持长宽比，这里的宽高值相等或者大于传入的宽高尺寸 if (scaleType == ScaleType.CENTER_CROP) &#123; // 小于传入的次要最大值，则返回通过比例计算的最大值，这里相当于把resized 值增大 if ((resized * ratio) &lt; maxSecondary) &#123; resized = (int) (maxSecondary / ratio); &#125; return resized; &#125; // 其它scaleType值，如果计算的值大于次要值，那么resized 值减小 if ((resized * ratio) &gt; maxSecondary) &#123; resized = (int) (maxSecondary / ratio); &#125; return resized; &#125; //解析response @Override protected Response&lt;Bitmap&gt; parseNetworkResponse(NetworkResponse response) &#123; synchronized (sDecodeLock) &#123; try &#123; return doParse(response); &#125; catch (OutOfMemoryError e) &#123; VolleyLog.e(&quot;Caught OOM for %d byte image, url=%s&quot;, response.data.length, getUrl()); return Response.error(new ParseError(e)); &#125; &#125; &#125; //解析的地方 private Response&lt;Bitmap&gt; doParse(NetworkResponse response) &#123; byte[] data = response.data; BitmapFactory.Options decodeOptions = new BitmapFactory.Options(); Bitmap bitmap = null; //如果最大宽度和最大高度都传入的为0，直接解析成一个bitmap if (mMaxWidth == 0 &amp;&amp; mMaxHeight == 0) &#123; decodeOptions.inPreferredConfig = mDecodeConfig; bitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions); &#125; else &#123; //如果要调整图片的大小，首先获取图片真实的尺寸大小，首先设置inJustDecodeBounds为true，不加载到内存但是可以获取图像的宽高 decodeOptions.inJustDecodeBounds = true; BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions); int actualWidth = decodeOptions.outWidth; int actualHeight = decodeOptions.outHeight; // 计算我们想要的尺寸 int desiredWidth = getResizedDimension( mMaxWidth, mMaxHeight, actualWidth, actualHeight, mScaleType); int desiredHeight = getResizedDimension( mMaxHeight, mMaxWidth, actualHeight, actualWidth, mScaleType); // 计算出采样值，2的倍数 decodeOptions.inJustDecodeBounds = false; decodeOptions.inSampleSize = findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight); Bitmap tempBitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions); // 如果采样率计算出的值为1的话，那么就没有尺寸压缩，tempBitmap的宽高值就是图片的 真实值，那么这里就需要缩放到满足我们上面计算出来的值 if (tempBitmap != null &amp;&amp; (tempBitmap.getWidth() &gt; desiredWidth || tempBitmap.getHeight() &gt; desiredHeight)) &#123; bitmap = Bitmap.createScaledBitmap(tempBitmap, desiredWidth, desiredHeight, true); tempBitmap.recycle(); &#125; else &#123; bitmap = tempBitmap; &#125; &#125; //回调给用户 if (bitmap == null) &#123; return Response.error(new ParseError(response)); &#125; else &#123; return Response.success(bitmap, HttpHeaderParser.parseCacheHeaders(response)); &#125; &#125; @Override public void cancel() &#123; super.cancel(); synchronized (mLock) &#123; mListener = null; &#125; &#125; @Override protected void deliverResponse(Bitmap response) &#123; Response.Listener&lt;Bitmap&gt; listener; synchronized (mLock) &#123; listener = mListener; &#125; if (listener != null) &#123; listener.onResponse(response); &#125; &#125; //计算合适的采样率 @VisibleForTesting static int findBestSampleSize( int actualWidth, int actualHeight, int desiredWidth, int desiredHeight) &#123; double wr = (double) actualWidth / desiredWidth; double hr = (double) actualHeight / desiredHeight; double ratio = Math.min(wr, hr); float n = 1.0f; while ((n * 2) &lt;= ratio) &#123; n *= 2; &#125; return (int) n; &#125;&#125; 关键部分我都写了注释，下面我们看主要流程，对 Bitmap 的高效加载。首先我们获取到返回的 response 进行解析，然后根据传递的期望宽高以及图片格式生成 Bitmap 返回，对于我们传入的宽高会按比例裁剪，不是直接使用裁剪到合适的值，不然会有拉伸，最后再回调给用户。 二、ImageLoader 分析我们直接先看构造方法，看所有的关键地方，不重要的就不分析了1234public ImageLoader(RequestQueue queue, ImageCache imageCache) &#123; mRequestQueue = queue; mCache = imageCache;&#125; 没啥说的，就是赋值，一个是请求队列，一个是图片缓存的自己实现，这个是在内部把请求添加到请求队列，所以直接传递进去，第二个参数缓存，我们可以自己实现，一般使用 LruCache 实现。接下来我们接着看 getImageListener:1234567891011121314151617181920public static ImageListener getImageListener( final ImageView view, final int defaultImageResId, final int errorImageResId) &#123; return new ImageListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; if (errorImageResId != 0) &#123; view.setImageResource(errorImageResId); &#125; &#125; @Override public void onResponse(ImageContainer response, boolean isImmediate) &#123; if (response.getBitmap() != null) &#123; view.setImageBitmap(response.getBitmap()); &#125; else if (defaultImageResId != 0) &#123; view.setImageResource(defaultImageResId); &#125; &#125; &#125;;&#125; 这个方法比较简单，就是传入我们的 ImageView 进行设置图像，然后分别提供一个默认和请求失败的占位图，刚开始设置的时候还没有请求到 Bitmap,所以最开始设置的事默认图。首先看两个变量，后面需要用到：1234//相同URL正在请求中存储的mapprivate final HashMap&lt;String, BatchedImageRequest&gt; mInFlightRequests = new HashMap&lt;&gt;();//相同URL请求结果存储的mapprivate final HashMap&lt;String, BatchedImageRequest&gt; mBatchedResponses = new HashMap&lt;&gt;(); 接下来我们看看关键的一步123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 @MainThread public ImageContainer get( String requestUrl, ImageListener imageListener, int maxWidth, int maxHeight, ScaleType scaleType) &#123; // 检查当前线程是否在主线程，只满足从主线程发起的请求 Threads.throwIfNotOnMainThread(); //根据url、width、height、scaleType拼接的缓存key final String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight, scaleType); // 从缓存中查找bitmap Bitmap cachedBitmap = mCache.getBitmap(cacheKey); if (cachedBitmap != null) &#123; // 有相应的缓存那么则返回一个ImageContainer，包括其中的bitmap ImageContainer container = new ImageContainer( cachedBitmap, requestUrl, /* cacheKey= */ null, /* listener= */ null); // 直接调用onResponse，把bitmap设置给imageView imageListener.onResponse(container, true); return container; &#125; // 缓存中没有查找到，那么我们直接获取，首先new一个ImageContainer ImageContainer imageContainer = new ImageContainer(null, requestUrl, cacheKey, imageListener); // 更新调用的地方，使用默认的图片先设置 imageListener.onResponse(imageContainer, true); //检查是否有相同的cacheKey请求正在运行 BatchedImageRequest request = mInFlightRequests.get(cacheKey); if (request != null) &#123; // 如果相同的请求正在运行，那么不需要重复请求，只需要将这个实例化 的imageContainer添加到BatchedImageRequest的mContainers中，然后请 求结束后对所有添加到集合中的imageContainer依次回调 request.addContainer(imageContainer); return imageContainer; &#125; // 如果这个请求尚未执行，发送一个新的请求到网络上，这里才是执行请求的地方 Request&lt;Bitmap&gt; newRequest = makeImageRequest(requestUrl, maxWidth, maxHeight, scaleType, cacheKey); //添加到请求队列 mRequestQueue.add(newRequest); //添加到正在请求的集合中 mInFlightRequests.put(cacheKey, new BatchedImageRequest(newRequest, imageContainer)); return imageContainer;&#125; 这个方法是一个重点，主要流程是首先看看缓存里面有没有缓存的 Bitmap,来源于我们自己实现的缓存策略，我们使用的是内存缓存的话这里就是一级缓存；如果有直接调用 onResponse 方法设置图片，如果没有，首先实例化 ImageContainer，涉及到了几个类，接下来就看是否有相同的请求，如果有则添加到一个集合中，请求下来统一处理；如果没有那么则构造一个 Request，通过 RequestQueue 去获取网络图片，可能是网络请求也有可能是磁盘缓存的，这里就是二级缓存，然后添加到正在请求的集合中。接下来看一看 ImageContainer 这个类,这个类就是图像请求的一个容器对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class ImageContainer &#123; //imageview加载的Bitmap private Bitmap mBitmap; //图片加载成功和失败的监听 private final ImageListener mListener; //缓存的key private final String mCacheKey; //请求指定的URL private final String mRequestUrl; public ImageContainer( Bitmap bitmap, String requestUrl, String cacheKey, ImageListener listener) &#123; mBitmap = bitmap; mRequestUrl = requestUrl; mCacheKey = cacheKey; mListener = listener; &#125; //取消请求 @MainThread public void cancelRequest() &#123; Threads.throwIfNotOnMainThread(); if (mListener == null) &#123; return; &#125; //从正在请求的集合获取一个批处理request BatchedImageRequest request = mInFlightRequests.get(mCacheKey); if (request != null) &#123; //如果取到request，那么首先从mContainers移除当前的这个ImageContainer， 如果移除后集合为空一个ImageContainer也没有了，那么则取消掉这个请求并返回 true boolean canceled = request.removeContainerAndCancelIfNecessary(this); if (canceled) &#123; //取消了请求则从正在请求的集合中移除BatchedImageRequest mInFlightRequests.remove(mCacheKey); &#125; &#125; else &#123; // 如果已经请求完成添加到批处理中准备处理分发 request = mBatchedResponses.get(mCacheKey); if (request != null) &#123; //首先从mContainers移除当前的这个ImageContainer request.removeContainerAndCancelIfNecessary(this); if (request.mContainers.size() == 0) &#123; //如果集合中一个ImageContainer都没有，则从等待处理的 response中移除掉这个BatchedImageRequest mBatchedResponses.remove(mCacheKey); &#125; &#125; &#125; &#125; public Bitmap getBitmap() &#123; return mBitmap; &#125; /** Returns the requested URL for this container. */ public String getRequestUrl() &#123; return mRequestUrl; &#125; &#125; 这个类主要包含是一个图片的容器对象，里面包括了 bitmap、监听器、缓存的key以及请求的 URL，每个请求都会先组装这个类，然后添加到一个 BatchedImageRequest的mContainers 中 接下来我们看看真正发起请求的地方：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253protected Request&lt;Bitmap&gt; makeImageRequest( String requestUrl, int maxWidth, int maxHeight, ScaleType scaleType, final String cacheKey) &#123; return new ImageRequest( requestUrl, new Listener&lt;Bitmap&gt;() &#123; @Override public void onResponse(Bitmap response) &#123; onGetImageSuccess(cacheKey, response); &#125; &#125;, maxWidth, maxHeight, scaleType, Config.RGB_565, new ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; onGetImageError(cacheKey, error); &#125; &#125;); &#125; //图片请求成功 protected void onGetImageSuccess(String cacheKey, Bitmap response) &#123; // 添加到以及缓存中 mCache.putBitmap(cacheKey, response); // 从正在运行的请求列表中删除这个请求 BatchedImageRequest request = mInFlightRequests.remove(cacheKey); if (request != null) &#123; //更新BatchedImageRequest的bitmap request.mResponseBitmap = response; //发送一个批处理请求，将多个相同的请求进行分发 batchResponse(cacheKey, request); &#125; &#125; //图片请求失败，跟上面成功处理大致类似 protected void onGetImageError(String cacheKey, VolleyError error) &#123; BatchedImageRequest request = mInFlightRequests.remove(cacheKey); if (request != null) &#123; //设置这个请求的错误 request.setError(error); batchResponse(cacheKey, request); &#125; &#125; 这里执行网络请求还是调用我们上面分析的 ImageRequest 方法，而且在回调中分别对成功和失败在进行了一次处理。接下来我们看看这个批量处理图片的 batchResponse 方法：12345678910111213141516171819202122232425262728293031323334353637private void batchResponse(String cacheKey, BatchedImageRequest request) &#123; //首先添加到这个map中，表明现在进入了批处理中 mBatchedResponses.put(cacheKey, request); // 如果还没有进行处理，那么我们则开始一个新的任务 if (mRunnable == null) &#123; mRunnable = new Runnable() &#123; @Override public void run() &#123; //循环mBatchedResponses的所有值 for (BatchedImageRequest bir : mBatchedResponses.values()) &#123; //循环BatchedImageRequest的mContainers的值 for (ImageContainer container : bir.mContainers) &#123; //如果有的请求取消了，在收到请求的 响应后还没有分发之前那么跳过循环下一个 if (container.mListener == null) &#123; continue; &#125; // 如果不是请求错误则调用onResponse if (bir.getError() == null) &#123; container.mBitmap = bir.mResponseBitmap; container.mListener.onResponse(container, false); &#125; else &#123; //请求报错则调用onErrorResponse设置一个错误的图片展示 container.mListener.onErrorResponse(bir.getError()); &#125; &#125; &#125; //清除所有响应的BatchedImageRequest mBatchedResponses.clear(); //置为null，通过是否为null判断当前是否正在处理 mRunnable = null; &#125; &#125;; // 将这个post投递到主线程去执行 mHandler.postDelayed(mRunnable, mBatchResponseDelayMs); &#125; &#125; 这段代码也很简单，不过有个地方有个比较奇怪的地方，为啥是使用双层循环，为啥不直接使用内层的循环；个人认为有可能是这样，首先这个 mBatchedResponses 刚开始进来添加了相同的key的请求的 BatchedImageRequest，那么存在正在分发的时候又有不同的key的请求进来了，因为正在处理的时候 runnable 不为 null，则后续添加的有可能不能分发，所以要遍历这个 map中所有的请求。 三、 NetworkImageView 分析这是一个继承 ImageView 的自定义 view：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165public class NetworkImageView extends ImageView &#123; private String mUrl; //设置默认的图片 private int mDefaultImageId; //设置请求错误的时候显示的图片 private int mErrorImageId; private ImageLoader mImageLoader; private ImageContainer mImageContainer; public NetworkImageView(Context context) &#123; this(context, null); &#125; public NetworkImageView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public NetworkImageView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; //这个方法就是设置我们的url @MainThread public void setImageUrl(String url, ImageLoader imageLoader) &#123; Threads.throwIfNotOnMainThread(); mUrl = url; mImageLoader = imageLoader; // 我们的url可能已经更改，那么我们则需要判断是否需要加载 loadImageIfNecessary(/* isInLayoutPass= */ false); &#125; public void setDefaultImageResId(int defaultImage) &#123; mDefaultImageId = defaultImage; &#125; public void setErrorImageResId(int errorImage) &#123; mErrorImageId = errorImage; &#125; //如果视图尚未加载图像，那么我们则去加载它 void loadImageIfNecessary(final boolean isInLayoutPass) &#123; int width = getWidth(); int height = getHeight(); ScaleType scaleType = getScaleType(); boolean wrapWidth = false, wrapHeight = false; if (getLayoutParams() != null) &#123; wrapWidth = getLayoutParams().width == LayoutParams.WRAP_CONTENT; wrapHeight = getLayoutParams().height == LayoutParams.WRAP_CONTENT; &#125; //如果不知道视图的大小并且不是WRAP_CONTENT就暂停加载 boolean isFullyWrapContent = wrapWidth &amp;&amp; wrapHeight; if (width == 0 &amp;&amp; height == 0 &amp;&amp; !isFullyWrapContent) &#123; return; &#125; // 如果url为空的话则请取消所有的请求，包括以前的请求，假如请求两次 最后次的url为null，这时候还没请求完成，肯定以最后次为准 if (TextUtils.isEmpty(mUrl)) &#123; if (mImageContainer != null) &#123; mImageContainer.cancelRequest(); mImageContainer = null; &#125; //设置默认的图片 setDefaultImageOrNull(); return; &#125; // 检查是否取消以前的请求 if (mImageContainer != null &amp;&amp; mImageContainer.getRequestUrl() != null) &#123; if (mImageContainer.getRequestUrl().equals(mUrl)) &#123; // 如果请求和以前相同则没必要再次请求 return; &#125; else &#123; // 如果存在正在请求的url并且请求url不同，那么取消正在请求的url mImageContainer.cancelRequest(); setDefaultImageOrNull(); &#125; &#125; // 计算最大宽高，如果设置WRAP_CONTENT那么则图片是多大就是多大，其它 情况则直接使用布局的宽高，如果设置了具体的值就有可能裁剪 int maxWidth = wrapWidth ? 0 : width; int maxHeight = wrapHeight ? 0 : height; // 使用ImageLoader来请求图像，上面已经分析了，最终返回一个ImageContainer mImageContainer = mImageLoader.get( mUrl, new ImageListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; if (mErrorImageId != 0) &#123; setImageResource(mErrorImageId); &#125; &#125; @Override public void onResponse( final ImageContainer response, boolean isImmediate) &#123; //isImmediate：在网络请求过程中调用的时候为true，可以用来 区分是否是取的缓存图像还是网络图像加载 isInLayoutPass：如果通过onLayout调用此函数， 则为true，否则为false 这个if的意思就是，如果是缓存图像并且是在布局中调用那么则发送 到主线程并延迟设置图像，因为可能多次调用 if (isImmediate &amp;&amp; isInLayoutPass) &#123; post( new Runnable() &#123; @Override public void run() &#123; onResponse(response, /* isImmediate= */ false); &#125; &#125;); return; &#125; //请求成功加载图片 if (response.getBitmap() != null) &#123; setImageBitmap(response.getBitmap()); &#125; else if (mDefaultImageId != 0) &#123; setImageResource(mDefaultImageId); &#125; &#125; &#125;, maxWidth, maxHeight, scaleType); &#125; private void setDefaultImageOrNull() &#123; if (mDefaultImageId != 0) &#123; setImageResource(mDefaultImageId); &#125; else &#123; setImageBitmap(null); &#125; &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); loadImageIfNecessary(/* isInLayoutPass= */ true); &#125; //当imageview销毁的时候，取消请求并且清除ImageContainer以便重新加载图像 @Override protected void onDetachedFromWindow() &#123; if (mImageContainer != null) &#123; // If the view was bound to an image request, cancel it and clear // out the image from the view. mImageContainer.cancelRequest(); setImageBitmap(null); // also clear out the container so we can reload the image if necessary. mImageContainer = null; &#125; super.onDetachedFromWindow(); &#125; @Override protected void drawableStateChanged() &#123; super.drawableStateChanged(); invalidate(); &#125;&#125; 这个类没啥好分析的，就是利用前两个类来完成请求，只不过方便的是直接在xml中使用，使用 ImageLoader 请求的 Bitmap 设置给 NetworkImageView。 四、总结三种不同的方式都可以完成图片的加载，不过后面的方式都比较依赖前面的 ImageRequest，毕竟还是要这个类去完成网络请求操作；在使用中，根据不同的场景选择不同的方式使用。不过我建议使用 ImageLoader 来加载图片，可以自己设置缓存，两级缓存，一级内存缓存，一级 volley 请求时候的磁盘缓存。总体来讲封装的很不错，对一些细节处理的比较好，比如相同的请求、图片的裁剪等，值得我们学习的地方很多。 参考Android Volley完全解析(二)，使用Volley加载网络图片Volley 源码解析","categories":[{"name":"源码解析","slug":"源码解析","permalink":"https://wvisible.github.io/categories/源码解析/"}],"tags":[{"name":"Volley","slug":"Volley","permalink":"https://wvisible.github.io/tags/Volley/"}]},{"title":"Volley 源码解析之网络请求","slug":"Volley-源码解析之网络请求","date":"2020-03-05T15:36:09.000Z","updated":"2020-03-06T09:12:10.225Z","comments":true,"path":"2020/03/05/Volley-源码解析之网络请求/","link":"","permalink":"https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/","excerpt":"","text":"Volley源码分析三部曲Volley 源码解析之网络请求Volley 源码解析之图片请求Volley 源码解析之缓存机制 Volley 是 Google 推出的一款网络通信框架，非常适合数据量小、通信频繁的网络请求，支持并发、缓存和容易扩展、调试等；不过不太适合下载大文件、大量数据的网络请求，因为 Volley 在解析期间将响应放到内存中，我们可以使用 Okhttp 或者系统提供的DownloadManager来下载文件。 一、简单使用首先在工程引入volley的library： 123dependencies &#123; implementation 'com.android.volley:volley:1.1.1'&#125; 然后需要我们打开网络权限，我这里直接贴出官网简单请求的示例代码： 123456789101112131415161718192021222324final TextView mTextView = (TextView) findViewById(R.id.text);// ...// Instantiate the RequestQueue.RequestQueue queue = Volley.newRequestQueue(this);String url =\"http://www.google.com\";// Request a string response from the provided URL.StringRequest stringRequest = new StringRequest(Request.Method.GET, url, new Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String response) &#123; // Display the first 500 characters of the response string. mTextView.setText(\"Response is: \"+ response.substring(0,500)); &#125;&#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; mTextView.setText(\"That didn't work!\"); &#125;&#125;);// Add the request to the RequestQueue.queue.add(stringRequest); 使用相对简单，回调直接在主线程，我们取消某个请求直接这样操作： 定义一个标记添加到requests中 123456789public static final String TAG = \"MyTag\";StringRequest stringRequest; // Assume this exists.RequestQueue mRequestQueue; // Assume this exists.// Set the tag on the request.stringRequest.setTag(TAG);// Add the request to the RequestQueue.mRequestQueue.add(stringRequest); 然后我们可以在 onStop() 中取消所有标记的请求 1234567@Overrideprotected void onStop () &#123; super.onStop(); if (mRequestQueue != null) &#123; mRequestQueue.cancelAll(TAG); &#125;&#125; 二、源码分析我们先从Volley这个类入手： 123456789101112131415161718192021222324252627282930313233343536public static RequestQueue newRequestQueue(Context context, BaseHttpStack stack) &#123; BasicNetwork network; if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; network = new BasicNetwork(new HurlStack()); &#125; else &#123; String userAgent = \"volley/0\"; try &#123; String packageName = context.getPackageName(); PackageInfo info = context.getPackageManager().getPackageInfo(packageName, /* flags= */ 0); userAgent = packageName + \"/\" + info.versionCode; &#125; catch (NameNotFoundException e) &#123; &#125; network = new BasicNetwork( new HttpClientStack(AndroidHttpClient.newInstance(userAgent))); &#125; &#125; else &#123; network = new BasicNetwork(stack); &#125; return newRequestQueue(context, network);&#125;private static RequestQueue newRequestQueue(Context context, Network network) &#123; File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR); RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network); queue.start(); return queue;&#125;public static RequestQueue newRequestQueue(Context context) &#123; return newRequestQueue(context, (BaseHttpStack) null);&#125; 当我们传递一个 Context 的时候，首先为 BaseHttpStack 为 null，会执行到创建 BaseHttpStack，BaseHttpStack 是一个网络具体的处理请求，Volley 默认提供了基于 HttpURLCollection 的 HurlStack 和基于HttpClient 的 HttpClientStack。Android6.0 移除了 HttpClient，Google 官方推荐使用HttpURLCollection 类作为替换。所以这里在API大于9的版本是用的是 HurlStack,为什么这样选择，详情可见这篇博客Android访问网络，使用HttpURLConnection还是HttpClient？。我们使用的是默认的构造，BaseHttpStack 传入为 null，如果我们想使用自定义的 okhttp 替换底层，我们直接继承 HttpStack 重写即可，也可以自定义 Network 和 RequestQueue,Volley 的高扩展性充分体现。接下来则创建一个 Network 对象，然后实例化 RequestQueue,首先创建了一个用于缓存的文件夹，然后创建了一个磁盘缓存，将文件缓存到指定目录的硬盘上，默认大小是5M，但是大小可以配置。接下来调用 RequestQueue 的 start()方法进行启动，我们进入这个方法查看一下： 123456789101112public void start() &#123; stop(); mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); for (int i = 0; i &lt; mDispatchers.length; i++) &#123; NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start(); &#125;&#125; 开始启动的时候先停止所有的请求线程和网络缓存线程，然后实例化一个缓存线程并运行，然后一个循环开启DEFAULT_NETWORK_THREAD_POOL_SIZE（4）个网络请求线程并运行，一共就是5个线程在后台运行，不断的等待网络请求的到来。 构造了 RequestQueue 之后，我们调用 add() 方法将相应的 Request 传入就开始执行网络请求了，我们看看这个方法： 1234567891011121314151617181920212223public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) &#123; //将请求队列和请求关联起来 request.setRequestQueue(this); //添加到正在请求中但是还未完成的集合中 synchronized (mCurrentRequests) &#123; mCurrentRequests.add(request); &#125; //设置请求的一个序列号，通过原子变量的incrementAndGet方法， //以原子方式给当前值加1并获取新值实现请求的优先级 request.setSequence(getSequenceNumber()); //添加一个调试信息 request.addMarker(\"add-to-queue\"); //如果不需要缓存则直接加到网络的请求队列，默认每一个请求都是缓存的， //如果不需要缓存需要调用Request的setShouldCache方法来修改 if (!request.shouldCache()) &#123; mNetworkQueue.add(request); return request; &#125; //加到缓存的请求队列 mCacheQueue.add(request); return request;&#125; 关键地方都写了注释，主要作用就是将请求加到请求队列，执行网络请求或者从缓存中获取结果。网络和缓存的请求都是一个优先级阻塞队列，按照优先级出队。上面几个关键步骤，添加到请求集合里面还有设置优先级以及添加到缓存和请求队列都是线程安全的，要么加锁，要么使用线程安全的队列或者原子操作。 接下来我们看看添加到 CacheDispatcher 缓存请求队列的 run 方法： 12345678910111213141516171819202122@Overridepublic void run() &#123; if (DEBUG) VolleyLog.v(\"start new dispatcher\"); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //初始化DiskBasedCache的缓存类 mCache.initialize(); while (true) &#123; try &#123; processRequest(); &#125; catch (InterruptedException e) &#123; if (mQuit) &#123; Thread.currentThread().interrupt(); return; &#125; VolleyLog.e( \"Ignoring spurious interrupt of CacheDispatcher thread; \" + \"use quit() to terminate it\"); &#125; &#125;&#125; 接下来的重点是看看 processRequest() 这个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485private void processRequest() throws InterruptedException &#123; //从缓存队列取出请求 final Request&lt;?&gt; request = mCacheQueue.take(); processRequest(request);&#125;@VisibleForTestingvoid processRequest(final Request&lt;?&gt; request) throws InterruptedException &#123; request.addMarker(\"cache-queue-take\"); // 如果请求被取消，我们可以通过RequestQueue的回调接口来监听 if (request.isCanceled()) &#123; request.finish(\"cache-discard-canceled\"); return; &#125; // 从缓存中获取Cache.Entry Cache.Entry entry = mCache.get(request.getCacheKey()); //没有取到缓存 if (entry == null) &#123; request.addMarker(\"cache-miss\"); // 缓存未命中，对于可缓存的请求先去检查是否有相同的请求是否已经在运行中， //如果有的话先加入请求等待队列，等待请求完成，返回true；如果返回false则表示第一次请求 if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123; //加入到网络请求的阻塞队列 mNetworkQueue.put(request); &#125; return; &#125; // 如果缓存完全过期，处理过程跟上面类似 if (entry.isExpired()) &#123; request.addMarker(\"cache-hit-expired\"); //设置请求缓存的entry到这个request中 request.setCacheEntry(entry); if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123; mNetworkQueue.put(request); &#125; return; &#125; //缓存命中，将数据解析并返回到request的抽象方法中 request.addMarker(\"cache-hit\"); Response&lt;?&gt; response = request.parseNetworkResponse( new NetworkResponse(entry.data, entry.responseHeaders)); request.addMarker(\"cache-hit-parsed\"); //判断请求结果是否需要刷新 if (!entry.refreshNeeded()) &#123; // 未过期的缓存命中，通过ExecutorDelivery回调给我们的request子类的接口中， // 我们在使用的时候就可以通过StringRequest、JsonRequest等拿到结果， // 切换到主线程也是在这个类里执行的 mDelivery.postResponse(request, response); &#125; else &#123; request.addMarker(\"cache-hit-refresh-needed\"); request.setCacheEntry(entry); // 将这个响应标记为中间值，即这个响应是新鲜的，那么第二个响应正在请求随时到来 response.intermediate = true; if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123; //发起网络请求，这里为什么直接调用上面的mNetworkQueue.put(request);呢， //主要是为了添加一个已经分发的标记，在响应分发的时候不再回调给用户， //不然就回调了两次 mDelivery.postResponse( request, response, new Runnable() &#123; @Override public void run() &#123; try &#123; mNetworkQueue.put(request); &#125; catch (InterruptedException e) &#123; // Restore the interrupted status Thread.currentThread().interrupt(); &#125; &#125; &#125;); &#125; else &#123; //这里第三个参数传递null，不用再去分发，因为已经有相同的请求已经在执行， //直接添加到了等待请求的列表中，然后返回的时候从已经执行的请求收到响应 mDelivery.postResponse(request, response); &#125; &#125;&#125; 这部分主要是对请求的缓存判断，是否过期以及需要刷新缓存。我们调用取消所有请求或者取消某个请求实质上就是对 mCanceled 这个变量赋值，然后在缓存线程或者网络线程里面都回去判断这个值，就完成了取消。上面的 isExpired 和 refreshNeeded，两个区别就是，前者如果过期就直接请求最新的内容，后者就是还在新鲜的时间内，但是把内容返回给用户还是会发起请求，两者一个与 ttl 值相比，另一个与 softTtl 相比。 其中有一个 WaitingRequestManager，如果有相同的请求那么就需要一个暂存的地方，这个类就是做的这个操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103private static class WaitingRequestManager implements Request.NetworkRequestCompleteListener &#123; //所有等待请求的集合，键是缓存的key private final Map&lt;String, List&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests = new HashMap&lt;&gt;(); private final CacheDispatcher mCacheDispatcher; WaitingRequestManager(CacheDispatcher cacheDispatcher) &#123; mCacheDispatcher = cacheDispatcher; &#125; //请求接受到一个有效的响应，后面等待的相同请求就可以使用这个响应 @Override public void onResponseReceived(Request&lt;?&gt; request, Response&lt;?&gt; response) &#123; //如果缓存为空或者已经过期，那么就释放等待的请求 if (response.cacheEntry == null || response.cacheEntry.isExpired()) &#123; onNoUsableResponseReceived(request); return; &#125; String cacheKey = request.getCacheKey(); //等待的请求的集合 List&lt;Request&lt;?&gt;&gt; waitingRequests; synchronized (this) &#123; //从map里面移除这个请求的集合 waitingRequests = mWaitingRequests.remove(cacheKey); &#125; if (waitingRequests != null) &#123; if (VolleyLog.DEBUG) &#123; VolleyLog.v( \"Releasing %d waiting requests for cacheKey=%s.\", waitingRequests.size(), cacheKey); &#125; // 里面所有的请求都分发到相应的回调执行，下面会讲解 for (Request&lt;?&gt; waiting : waitingRequests) &#123; mCacheDispatcher.mDelivery.postResponse(waiting, response); &#125; &#125; &#125; //没有收到相应，则需要释放请求 @Override public synchronized void onNoUsableResponseReceived(Request&lt;?&gt; request) &#123; String cacheKey = request.getCacheKey(); List&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey); if (waitingRequests != null &amp;&amp; !waitingRequests.isEmpty()) &#123; if (VolleyLog.DEBUG) &#123; VolleyLog.v( \"%d waiting requests for cacheKey=%s; resend to network\", waitingRequests.size(), cacheKey); &#125; //下面这个请求执会重新执行，将这个移除添加到 Request&lt;?&gt; nextInLine = waitingRequests.remove(0); //将剩下的请求放到等待请求的map中 mWaitingRequests.put(cacheKey, waitingRequests); //在request里面注册一个回调接口，因为重新开始请求，需要重新注册一个监听， //后面请求成功失败以及取消都可以收到回调 nextInLine.setNetworkRequestCompleteListener(this); try &#123; //从上面if判断方法可以得出：waitingRequests != null &amp;&amp; !waitingRequests.isEmpty() //排除了第一次请求失败、取消的情况，后面的那个条件则表示这个等待请求队列必须要有一个请求， //同时满足才会执行这里面的代码，一般只要这里面的请求执行成功一次后续所有的请求都会被移除， //所以这里对多个请求的情况，失败一次，那么后续的请求会继续执行 mCacheDispatcher.mNetworkQueue.put(nextInLine); &#125; catch (InterruptedException iex) &#123; VolleyLog.e(\"Couldn't add request to queue. %s\", iex.toString()); // Restore the interrupted status of the calling thread (i.e. NetworkDispatcher) Thread.currentThread().interrupt(); // Quit the current CacheDispatcher thread. mCacheDispatcher.quit(); &#125; &#125; &#125; //对于可以缓存的请求，相同缓存的请求已经在运行中就添加到一个发送队列， //等待运行中的队列请求完成，返回true表示已经有请求在运行，false则是第一次执行 private synchronized boolean maybeAddToWaitingRequests(Request&lt;?&gt; request) &#123; String cacheKey = request.getCacheKey(); // 存在相同的请求则把请求加入到相同缓存键的集合中 if (mWaitingRequests.containsKey(cacheKey)) &#123; // There is already a request in flight. Queue up. List&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey); //如果包含相同的请求但是有可能是第二次请求，前面第一次请求插入null了 if (stagedRequests == null) &#123; stagedRequests = new ArrayList&lt;&gt;(); &#125; request.addMarker(\"waiting-for-response\"); stagedRequests.add(request); mWaitingRequests.put(cacheKey, stagedRequests); if (VolleyLog.DEBUG) &#123; VolleyLog.d(\"Request for cacheKey=%s is in flight, putting on hold.\", cacheKey); &#125; return true; &#125; else &#123; //第一次请求那么则插入一个null，表示当前有一个请求正在运行 mWaitingRequests.put(cacheKey, null); //注册一个接口监听 request.setNetworkRequestCompleteListener(this); if (VolleyLog.DEBUG) &#123; VolleyLog.d(\"new request, sending to network %s\", cacheKey); &#125; return false; &#125; &#125;&#125; 这个类主要是避免相同的请求多次请求，而且在 NetworkDispatcher 里面也会通过这个接口回调相应的值在这里执行，最终比如在网络请求返回304、请求取消或者异常那么都会在这里来处理，如果收到响应则会把值回调给用户，后面的请求也不会再去请求，如果无效的响应则会做一些释放等待的请求操作，请求完成也会将后面相同的请求回调给用户，三个方法都在不同的地方发挥作用。 我们接下来看看 NetworkDispatcher 网络请求队列的 run 方法中的 processRequest 方法: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@VisibleForTestingvoid processRequest(Request&lt;?&gt; request) &#123; long startTimeMs = SystemClock.elapsedRealtime(); try &#123; request.addMarker(\"network-queue-take\"); // 请求被取消了，就不执行网络请求, if (request.isCanceled()) &#123; request.finish(\"network-discard-cancelled\"); request.notifyListenerResponseNotUsable(); return; &#125; addTrafficStatsTag(request); // 这里就是执行网络请求的地方 NetworkResponse networkResponse = mNetwork.performRequest(request); request.addMarker(\"network-http-complete\"); // 如果服务器返回304响应，即没有修改过， //缓存依然是有效的并且是在需要刷新的有效期内，那么则不需要解析响应 if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123; request.finish(\"not-modified\"); //没有收到来自网络的有效响应，释放请求 request.notifyListenerResponseNotUsable(); return; &#125; // 在工作线程中解析这些响应 Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse); request.addMarker(\"network-parse-complete\"); // 将缓存写入到应用 if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123; mCache.put(request.getCacheKey(), response.cacheEntry); request.addMarker(\"network-cache-written\"); &#125; // 标记此请求已将分发 request.markDelivered(); //将请求的响应回调给用户 mDelivery.postResponse(request, response); //请求接受到了一个响应，其他相同的请求可以使用这个响应 request.notifyListenerResponseReceived(response); &#125; catch (VolleyError volleyError) &#123; ... &#125;&#125; 这里才是网络请求的真正执行以及解析分发的地方，重点看两个地方的代码，执行和解析，我们先看看执行网络请求这个代码，执行的地方是 BasicNetwork.performRequest，下面看看这个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Overridepublic NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123; long requestStart = SystemClock.elapsedRealtime(); while (true) &#123; HttpResponse httpResponse = null; byte[] responseContents = null; List&lt;Header&gt; responseHeaders = Collections.emptyList(); try &#123; // 构造缓存的头部，添加If-None-Match和If-Modified-Since，都是http/1.1中控制协商缓存的两个字段， // If-None-Match：客服端再次发起请求时，携带上次请求返回的唯一标识Etag值， //服务端用携带的值和最后修改的值作对比，最后修改时间大于携带的字段值则返回200，否则304； // If-Modified-Since：客服端再次发起请求时，携带上次请求返回的Last-Modified值， //服务端用携带的值和服务器的Etag值作对比，一致则返回304 Map&lt;String, String&gt; additionalRequestHeaders = getCacheHeaders(request.getCacheEntry()); //因为现在一般的sdk都是大于9的，那么这里执行的就是HurlStack的executeRequest方法， //执行网络请求，和我们平时使用HttpURLConnection请求网络大致相同 httpResponse = mBaseHttpStack.executeRequest(request, additionalRequestHeaders); int statusCode = httpResponse.getStatusCode(); responseHeaders = httpResponse.getHeaders(); // 服务端返回304时，那么就表示资源无更新，可以继续使用缓存的值 if (statusCode == HttpURLConnection.HTTP_NOT_MODIFIED) &#123; Entry entry = request.getCacheEntry(); if (entry == null) &#123; return new NetworkResponse( HttpURLConnection.HTTP_NOT_MODIFIED, /* data= */ null, /* notModified= */ true, SystemClock.elapsedRealtime() - requestStart, responseHeaders); &#125; // 将缓存头和响应头组合在一起，一次响应就完成了 List&lt;Header&gt; combinedHeaders = combineHeaders(responseHeaders, entry); return new NetworkResponse( HttpURLConnection.HTTP_NOT_MODIFIED, entry.data, /* notModified= */ true, SystemClock.elapsedRealtime() - requestStart, combinedHeaders); &#125; // 如果返回204，执行成功，没有数据，这里需要检查 InputStream inputStream = httpResponse.getContent(); if (inputStream != null) &#123; responseContents = inputStreamToBytes(inputStream, httpResponse.getContentLength()); &#125; else &#123; //返回204，就返回一个空的byte数组 responseContents = new byte[0]; &#125; // if the request is slow, log it. long requestLifetime = SystemClock.elapsedRealtime() - requestStart; logSlowRequests(requestLifetime, request, responseContents, statusCode); if (statusCode &lt; 200 || statusCode &gt; 299) &#123; throw new IOException(); &#125; return new NetworkResponse( statusCode, responseContents, /* notModified= */ false, SystemClock.elapsedRealtime() - requestStart, responseHeaders); &#125; catch (SocketTimeoutException e) &#123; //异常进行重新请求等... &#125; &#125;&#125; 这里主要执行了添加缓存头并发起网络请求，然后将返回值组装成一个 NetworkResponse 值返回，接下来我们看看是如何解析这个值的，解析是由 Request 的子类去实现的，我们就看系统提供的 StringRequest： 1234567891011121314@Override@SuppressWarnings(\"DefaultCharset\")protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) &#123; String parsed; try &#123; parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers)); &#125; catch (UnsupportedEncodingException e) &#123; // Since minSdkVersion = 8, we can't call // new String(response.data, Charset.defaultCharset()) // So suppress the warning instead. parsed = new String(response.data); &#125; return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));&#125; 我们可以看到将值组装成一个String，然后组装成一个 Response 返回，接下来看看这里如何将这个值回调给用户的这个方法mDelivery.postResponse(request, response)，这里我们先重点看看这个类 ExecutorDelivery: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class ExecutorDelivery implements ResponseDelivery &#123; //构造执行已提交的Runnable任务对象 private final Executor mResponsePoster; //这里在RequestQueue构造参数中初始化，new ExecutorDelivery(new Handler(Looper.getMainLooper()))， //那么这里runnable就通过绑定主线程的Looper的Handler对象投递到主线程中执行 public ExecutorDelivery(final Handler handler) &#123; // Make an Executor that just wraps the handler. mResponsePoster = new Executor() &#123; @Override public void execute(Runnable command) &#123; handler.post(command); &#125; &#125;; &#125; public ExecutorDelivery(Executor executor) &#123; mResponsePoster = executor; &#125; //这个方法就是我们NetworkDispatcher里面调用的方法，调用下面这个三个参数的构造方法 @Override public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response) &#123; postResponse(request, response, null); &#125; @Override public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) &#123; request.markDelivered(); request.addMarker(\"post-response\"); //构造了一个ResponseDeliveryRunnable类，传入execute，现在这个runnable就是在主线程里执行 mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable)); &#125; @Override public void postError(Request&lt;?&gt; request, VolleyError error) &#123; request.addMarker(\"post-error\"); Response&lt;?&gt; response = Response.error(error); mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, null)); &#125; /** A Runnable used for delivering network responses to a listener on the main thread. */ @SuppressWarnings(\"rawtypes\") private static class ResponseDeliveryRunnable implements Runnable &#123; private final Request mRequest; private final Response mResponse; private final Runnable mRunnable; public ResponseDeliveryRunnable(Request request, Response response, Runnable runnable) &#123; mRequest = request; mResponse = response; mRunnable = runnable; &#125; @SuppressWarnings(\"unchecked\") @Override public void run() &#123; //请求取消，那么就不分发给用户 if (mRequest.isCanceled()) &#123; mRequest.finish(\"canceled-at-delivery\"); return; &#125; // 根据isSuccess这个值来提供相应的回调给用户，调用Response会通过error的值是否为null来确定这个值， //我们调用VolleyError这个构造函数的时候就为这个值就为false if (mResponse.isSuccess()) &#123; mRequest.deliverResponse(mResponse.result); &#125; else &#123; mRequest.deliverError(mResponse.error); &#125; // 如果这是一个在新鲜的时间内的请求的响应，就添加一个标记，否则就结束 if (mResponse.intermediate) &#123; mRequest.addMarker(\"intermediate-response\"); &#125; else &#123; mRequest.finish(\"done\"); &#125; // 在CacheDispatcher里面当请求第一次请求时直接调用三个参数的构造方法，通过这个runnable就执行run方法 if (mRunnable != null) &#123; mRunnable.run(); &#125; &#125; &#125;&#125; 上面方法主要是将值回调给用户，那么整个网络请求大致就完成了，其中还涉及很多细节的东西，但是大致流程是走通了，不得不说这个库有很多值得我们学习的地方。 三、总结现在我们看官网的一张图，总结一下整个流程： 蓝色是主线程 绿色是缓存线程 黄色是网络线程 我们可以看到首先是请求添加到 RequestQueue 里，首先是添加到缓存队列，然后查看是否已经缓存，如果有并且在有效期内的缓存直接回调给用户，如果没有查找到，那么则需要添加到网络请求队列重新请求并且解析响应、写入缓存在发送到主线程给用户回调。 参考以及相关链接 【第1250期】彻底理解浏览器的缓存机制 Android Volley完全解析(四)，带你从源码的角度理解Volley Volley 源码解析 Volley 源码解析","categories":[{"name":"源码解析","slug":"源码解析","permalink":"https://wvisible.github.io/categories/源码解析/"}],"tags":[{"name":"Volley","slug":"Volley","permalink":"https://wvisible.github.io/tags/Volley/"}]},{"title":"Java 8 Lambda 指南","slug":"Java-8-Lambda-指南","date":"2018-10-07T09:31:03.000Z","updated":"2020-03-06T08:53:35.417Z","comments":true,"path":"2018/10/07/Java-8-Lambda-指南/","link":"","permalink":"https://wvisible.github.io/2018/10/07/Java-8-Lambda-指南/","excerpt":"","text":"一、前言2014年3月，Java 8发布，Lambda表达式作为一个重要的特性。不过在 Android 中最先使用 Retrolambda 插件来使用 Lambda 表达式，随着 Android Studio 的更新，在3.0版本之后通过配置就可以使用 Java8 的所有特性。","categories":[{"name":"Java8","slug":"Java8","permalink":"https://wvisible.github.io/categories/Java8/"}],"tags":[{"name":"Java8 Lambda","slug":"Java8-Lambda","permalink":"https://wvisible.github.io/tags/Java8-Lambda/"},{"name":"Lambda 原理","slug":"Lambda-原理","permalink":"https://wvisible.github.io/tags/Lambda-原理/"}]}]}