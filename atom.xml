<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>哆啦A梦Doraemon</title>
  
  <subtitle>So we beat on, boats against the current, borne back ceaselessly into the past.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wvisible.github.io/"/>
  <updated>2020-03-06T08:48:58.860Z</updated>
  <id>https://wvisible.github.io/</id>
  
  <author>
    <name>哆啦A梦Doraemon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Volley 源码解析之缓存机制</title>
    <link href="https://wvisible.github.io/2020/03/05/Volley-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/</id>
    <published>2020-03-05T15:45:42.000Z</published>
    <updated>2020-03-06T08:48:58.860Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>前面我们分析了 <code>Volley</code> 的网络请求的相关流程以及图片加载的源码，如果没有看过的话可以阅读一下，接下来我们分析 <code>Volley</code> 的缓存，看看是怎么处理缓存超时、缓存更新以及缓存的整个流程，掌握 <code>Volley</code> 的缓存设计，对整个 <code>Volley</code> 的源码以及细节一个比较完整的认识。</p><h4 id="二、-源码分析"><a href="#二、-源码分析" class="headerlink" title="二、 源码分析"></a>二、 源码分析</h4><p>我们首先看看 <code>Cache</code> 这个缓存接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public interface Cache &#123;</span><br><span class="line">    //通过key获取指定请求的缓存实体</span><br><span class="line">    Entry get(String key);</span><br><span class="line"></span><br><span class="line">    //存入指定的缓存实体</span><br><span class="line">    void put(String key, Entry entry);</span><br><span class="line"></span><br><span class="line">    //初始化缓存</span><br><span class="line">    void initialize();</span><br><span class="line"></span><br><span class="line">    //使缓存中的指定请求实体过期</span><br><span class="line">    void invalidate(String key, boolean fullExpire);</span><br><span class="line"></span><br><span class="line">    //移除指定的请求缓存实体</span><br><span class="line">    void remove(String key);</span><br><span class="line"></span><br><span class="line">    //清空缓存</span><br><span class="line">    void clear();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    class Entry &#123;</span><br><span class="line">        //请求返回的数据</span><br><span class="line">        public byte[] data;</span><br><span class="line"></span><br><span class="line">        //用于缓存验证的http请求头Etag</span><br><span class="line">        public String etag;</span><br><span class="line"></span><br><span class="line">        //Http 请求响应产生的时间</span><br><span class="line">        public long serverDate;</span><br><span class="line"></span><br><span class="line">        //最后修改时间</span><br><span class="line">        public long lastModified;</span><br><span class="line"></span><br><span class="line">        //过期时间</span><br><span class="line">        public long ttl;</span><br><span class="line"></span><br><span class="line">        //新鲜度时间</span><br><span class="line">        public long softTtl;</span><br><span class="line">        </span><br><span class="line">        public Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</span><br><span class="line">        </span><br><span class="line">        public List&lt;Header&gt; allResponseHeaders;</span><br><span class="line"></span><br><span class="line">        //返回true则过期</span><br><span class="line">        public boolean isExpired() &#123;</span><br><span class="line">            return this.ttl &lt; System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //需要从原始数据源刷新，则为true</span><br><span class="line">        public boolean refreshNeeded() &#123;</span><br><span class="line">            return this.softTtl &lt; System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>存储的实体就是响应，以字节数组作为数据的请求URL为键的缓存接口。<br>接下来我们看看 <code>HttpHeaderParser</code> 中用于解析 <code>http</code> 头的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">public static Cache.Entry parseCacheHeaders(NetworkResponse response) &#123;</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; headers = response.headers;</span><br><span class="line"></span><br><span class="line">        long serverDate = 0;</span><br><span class="line">        long lastModified = 0;</span><br><span class="line">        long serverExpires = 0;</span><br><span class="line">        long softExpire = 0;</span><br><span class="line">        long finalExpire = 0;</span><br><span class="line">        long maxAge = 0;</span><br><span class="line">        long staleWhileRevalidate = 0;</span><br><span class="line">        boolean hasCacheControl = false;</span><br><span class="line">        boolean mustRevalidate = false;</span><br><span class="line"></span><br><span class="line">        String serverEtag = null;</span><br><span class="line">        String headerValue;</span><br><span class="line">        //表示收到响应的时间</span><br><span class="line">        headerValue = headers.get(&quot;Date&quot;);</span><br><span class="line">        if (headerValue != null) &#123;</span><br><span class="line">            serverDate = parseDateAsEpoch(headerValue);</span><br><span class="line">        &#125;</span><br><span class="line">        //Cache-Control用于定义资源的缓存策略，在HTTP/1.1中，Cache-Control是</span><br><span class="line">        最重要的规则，取代了 Expires</span><br><span class="line">        headerValue = headers.get(&quot;Cache-Control&quot;);</span><br><span class="line">        if (headerValue != null) &#123;</span><br><span class="line">            hasCacheControl = true;</span><br><span class="line">            String[] tokens = headerValue.split(&quot;,&quot;, 0);</span><br><span class="line">            for (int i = 0; i &lt; tokens.length; i++) &#123;</span><br><span class="line">                String token = tokens[i].trim();</span><br><span class="line">                //no-cache：客户端缓存内容，每次都要向服务器重新验证资源是否</span><br><span class="line">                被更改，但是是否使用缓存则需要经过协商缓存来验证决定，</span><br><span class="line">                no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</span><br><span class="line">                这两种情况不缓存返回null</span><br><span class="line">                if (token.equals(&quot;no-cache&quot;) || token.equals(&quot;no-store&quot;)) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                //max-age：设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)</span><br><span class="line">                &#125; else if (token.startsWith(&quot;max-age=&quot;)) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        maxAge = Long.parseLong(token.substring(8));</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                //stale-while-revalidate：表明客户端愿意接受陈旧的响应，同时</span><br><span class="line">                在后台异步检查新的响应。秒值指示客户愿意接受陈旧响应的时间长度</span><br><span class="line">                &#125; else if (token.startsWith(&quot;stale-while-revalidate=&quot;)) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        staleWhileRevalidate = Long.parseLong(token.substring(23));</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                //must-revalidate：缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。</span><br><span class="line">                并不是说「每次都要验证」，它意味着某个资源在本地已缓存时长短于 max-age 指定时</span><br><span class="line">                长时，可以直接使用，否则就要发起验证</span><br><span class="line">                proxy-revalidate：与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。</span><br><span class="line">                &#125; else if (token.equals(&quot;must-revalidate&quot;) || token.equals(&quot;proxy-revalidate&quot;)) &#123;</span><br><span class="line">                    mustRevalidate = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //Expires 是 HTTP/1.0的控制手段，其值为服务器返回该请求结果</span><br><span class="line">        缓存的到期时间</span><br><span class="line">        headerValue = headers.get(&quot;Expires&quot;);</span><br><span class="line">        if (headerValue != null) &#123;</span><br><span class="line">            serverExpires = parseDateAsEpoch(headerValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间</span><br><span class="line">        headerValue = headers.get(&quot;Last-Modified&quot;);</span><br><span class="line">        if (headerValue != null) &#123;</span><br><span class="line">            lastModified = parseDateAsEpoch(headerValue);</span><br><span class="line">        &#125;</span><br><span class="line">        //Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</span><br><span class="line">        serverEtag = headers.get(&quot;ETag&quot;);</span><br><span class="line"></span><br><span class="line">        // Cache-Control 优先 Expires 字段,请求头包含 Cache-Control，计算缓存的ttl和softTtl</span><br><span class="line">        if (hasCacheControl) &#123;</span><br><span class="line">            //新鲜度时间只跟maxAge有关</span><br><span class="line">            softExpire = now + maxAge * 1000;</span><br><span class="line">            // 最终过期时间分两种情况：如果mustRevalidate为true，即需要验证新鲜度，</span><br><span class="line">            那么直接跟新鲜度时间一样的，另一种情况是新鲜度时间 + 陈旧的响应时间 * 1000</span><br><span class="line">            finalExpire = mustRevalidate ? softExpire : softExpire + staleWhileRevalidate * 1000;</span><br><span class="line">        // 如果不包含Cache-Control头</span><br><span class="line">        &#125; else if (serverDate &gt; 0 &amp;&amp; serverExpires &gt;= serverDate) &#123;</span><br><span class="line">            // 缓存失效时间的计算</span><br><span class="line">            softExpire = now + (serverExpires - serverDate);</span><br><span class="line">            // 最终过期时间跟新鲜度时间一致</span><br><span class="line">            finalExpire = softExpire;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Cache.Entry entry = new Cache.Entry();</span><br><span class="line">        entry.data = response.data;</span><br><span class="line">        entry.etag = serverEtag;</span><br><span class="line">        entry.softTtl = softExpire;</span><br><span class="line">        entry.ttl = finalExpire;</span><br><span class="line">        entry.serverDate = serverDate;</span><br><span class="line">        entry.lastModified = lastModified;</span><br><span class="line">        entry.responseHeaders = headers;</span><br><span class="line">        entry.allResponseHeaders = response.allHeaders;</span><br><span class="line"></span><br><span class="line">        return entry;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里主要是对请求头的缓存字段进行解析，并对缓存的相关字段赋值，特别是过期时间的计算要考虑到不同缓存头部的区别，以及每个缓存请求头的含义；<br>上面讲到的 <code>stale-while-revalidate</code> 这个字段举个例子：</p><blockquote><p>Cache-Control: max-age=600, stale-while-revalidate=30  </p></blockquote><p>这个响应表明当前响应内容新鲜时间为 600 秒，以及额外的 30 秒可以用来容忍过期缓存，服务器会将 <code>max-age</code> 和 <code>stale-while-revalidate</code> 的时间加在一起作为潜在最长可容忍的新鲜度时间，所有的响应都由缓存提供;不过在容忍过期缓存时间内,先直接从缓存中获取响应返回给调用者，然后在静默的在后台向原始服务器发起一次异步请求,然后在后台静默的更新缓存内容。</p><p>这部分代码都是关于HTTP缓存的相关知识，我下面给出一些我参考引用的链接，大家可以去学习相关知识。  </p><p>我们接下来继续看缓存的实现类 <code>DiskBasedCache</code>，将缓存文件直接缓存到指定目录下的硬盘上，我们首先看看构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public DiskBasedCache(File rootDirectory, int maxCacheSizeInBytes) &#123;</span><br><span class="line">        mRootDirectory = rootDirectory;</span><br><span class="line">        mMaxCacheSizeInBytes = maxCacheSizeInBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public DiskBasedCache(File rootDirectory) &#123;</span><br><span class="line">    this(rootDirectory, DEFAULT_DISK_USAGE_BYTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造方法做了两件事，指定硬盘缓存的文件夹以及缓存的大小，默认5M。<br>我们首先看看初始化方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void initialize() &#123;</span><br><span class="line">        //如果缓存文件夹不存在则创建文件夹</span><br><span class="line">        if (!mRootDirectory.exists()) &#123;</span><br><span class="line">            if (!mRootDirectory.mkdirs()) &#123;</span><br><span class="line">                VolleyLog.e(&quot;Unable to create cache dir %s&quot;, mRootDirectory.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        File[] files = mRootDirectory.listFiles();</span><br><span class="line">        if (files == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (File file : files) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                long entrySize = file.length();</span><br><span class="line">                CountingInputStream cis =</span><br><span class="line">                        new CountingInputStream(</span><br><span class="line">                                new BufferedInputStream(createInputStream(file)), entrySize);</span><br><span class="line">                try &#123;</span><br><span class="line">                    CacheHeader entry = CacheHeader.readHeader(cis);</span><br><span class="line">                    // 初始化的时候更新缓存大小为文件大小</span><br><span class="line">                    entry.size = entrySize;</span><br><span class="line">                    // 将已经存在的缓存存入到映射表中</span><br><span class="line">                    putEntry(entry.key, entry);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    // Any IOException thrown here is handled by the below catch block by design.</span><br><span class="line">                    //noinspection ThrowFromFinallyBlock</span><br><span class="line">                    cis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                //noinspection ResultOfMethodCallIgnored</span><br><span class="line">                file.delete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//将 key 和 CacheHeader 存入到 map 对象当中，然后更新当前字节数</span><br><span class="line">private void putEntry(String key, CacheHeader entry) &#123;</span><br><span class="line">    if (!mEntries.containsKey(key)) &#123;</span><br><span class="line">        mTotalSize += entry.size;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        CacheHeader oldEntry = mEntries.get(key);</span><br><span class="line">        mTotalSize += (entry.size - oldEntry.size);</span><br><span class="line">    &#125;</span><br><span class="line">    mEntries.put(key, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初始化这里首先判断了缓存文件夹是否存在，不存在就要新建文件夹，这个很好理解。如果存在了就会将原来的已经存在的文件夹依次读取并存入一个缓存映射表中，方便后续判断有无缓存，不用直接从磁盘缓存中去查找文件名判断有无缓存。一般每个请求都会有一个 <code>CacheHeader</code>，然后将存在的缓存头里的 <code>size</code> 重新赋值，初始化时大小为文件大小，存入数据为数据的大小。这里提一下 <code>CacheHeader</code> 是一个静态内部类，跟 <code>Cache</code> 的 <code>Entry</code> 有点像，少了一个 <code>byte[] data</code> 数组，其中维护了缓存头部的相关字段，这样设计的原因是方便快速读取，合理利用内存空间，因为缓存的相关信息需要频繁读取，内存占用小，可以缓存到内存中，但是网络请求的响应数据是非常占地方的，很容易就占满空间了，需要单独存储到硬盘中。<br>我们看下存入的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized void put(String key, Entry entry) &#123;</span><br><span class="line">    //首先进行缓存剩余空间的大小判断</span><br><span class="line">    pruneIfNeeded(entry.data.length);</span><br><span class="line">    File file = getFileForKey(key);</span><br><span class="line">    try &#123;</span><br><span class="line">        BufferedOutputStream fos = new BufferedOutputStream(createOutputStream(file));</span><br><span class="line">        CacheHeader e = new CacheHeader(key, entry);</span><br><span class="line">        //CacheHeader 写入到磁盘</span><br><span class="line">        boolean success = e.writeHeader(fos);</span><br><span class="line">        if (!success) &#123;</span><br><span class="line">            fos.close();</span><br><span class="line">            VolleyLog.d(&quot;Failed to write header for %s&quot;, file.getAbsolutePath());</span><br><span class="line">            throw new IOException();</span><br><span class="line">        &#125;</span><br><span class="line">        //网络请求的响应数据写入到磁盘</span><br><span class="line">        fos.write(entry.data);</span><br><span class="line">        fos.close();</span><br><span class="line">        //头部信息等存储到到映射表</span><br><span class="line">        putEntry(key, e);</span><br><span class="line">        return;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean deleted = file.delete();</span><br><span class="line">    if (!deleted) &#123;</span><br><span class="line">        VolleyLog.d(&quot;Could not clean up file %s&quot;, file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法比较简单就是将响应数据以及缓存的头部信息写入到磁盘并且将头部缓存到内存中，我们看下当缓存空间不足，是怎么考虑缓存替换的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> private void pruneIfNeeded(int neededSpace) &#123;</span><br><span class="line">    //缓存当前已经使用的空间总字节数 + 待存入的文件字节数是否大于缓存的最大大小，</span><br><span class="line">    默认为5M，也可以自己指定，如果大于就要进行删除以前的缓存</span><br><span class="line">    if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long before = mTotalSize;</span><br><span class="line">    // 删除的文件数量</span><br><span class="line">    int prunedFiles = 0;</span><br><span class="line">    long startTime = SystemClock.elapsedRealtime();</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, CacheHeader&gt;&gt; iterator = mEntries.entrySet().iterator();</span><br><span class="line">    //遍历mEntries中所有的缓存</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, CacheHeader&gt; entry = iterator.next();</span><br><span class="line">        CacheHeader e = entry.getValue();</span><br><span class="line">        //因为mEntries是一个访问有序的LinkedHashMap，经常访问的会被移动到末尾，</span><br><span class="line">        所以这里的思想就是 LRU 缓存算法</span><br><span class="line">        boolean deleted = getFileForKey(e.key).delete();</span><br><span class="line">        if (deleted) &#123;</span><br><span class="line">            //删除成功过后减少当前空间的总字节数</span><br><span class="line">            mTotalSize -= e.size;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            VolleyLog.d(</span><br><span class="line">                    &quot;Could not delete cache entry for key=%s, filename=%s&quot;,</span><br><span class="line">                    e.key, getFilenameForKey(e.key));</span><br><span class="line">        &#125;</span><br><span class="line">        iterator.remove();</span><br><span class="line">        prunedFiles++;</span><br><span class="line">        //最后判断当前的空间是否满足新存入申请的空间大小，满足就跳出循环</span><br><span class="line">        if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的缓存替换策略也很好理解，如果不加以限制，那么岂不是一直写入数据到磁盘，有很多不用的数据很快就把磁盘写满了，所以使用了 <code>LRU</code> 缓存替换算法。<br>接下来我们看看存储的 <code>key</code>，即缓存文件名生成方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private String getFilenameForKey(String key) &#123;</span><br><span class="line">    int firstHalfLength = key.length() / 2;</span><br><span class="line">    String localFilename = String.valueOf(key.substring(0, firstHalfLength).hashCode());</span><br><span class="line">    localFilename += String.valueOf(key.substring(firstHalfLength).hashCode());</span><br><span class="line">    return localFilename;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先将请求的 <code>url</code> 分成两部分，然后两部分分别求 <code>hashCode</code>，最后拼接起来。如果我们使用 <code>volley</code> 来请求数据，那么通常是同一个地址中后面的不一样，很多字符一样，那么这样做可以避免 <code>hashCode</code> 重复造成文件名重复，创造更多的差异，因为<code>hash</code> 在 <code>Java</code> 中不是那么可靠,关于这个问题我们可以在这篇文章中找到解答<a href="https://www.kymjs.com/code/2016/03/08/01/" target="_blank" rel="noopener">面试后的总结</a><br>然后我们看下 <code>get</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public synchronized Entry get(String key) &#123;</span><br><span class="line">        CacheHeader entry = mEntries.get(key);</span><br><span class="line">        // 如果entry不存在，则返回null</span><br><span class="line">        if (entry == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //获取缓存的文件</span><br><span class="line">        File file = getFileForKey(key);</span><br><span class="line">        try &#123;</span><br><span class="line">            //这个类的作用是通过bytesRead记录已经读取的字节数</span><br><span class="line">            CountingInputStream cis =</span><br><span class="line">                    new CountingInputStream(</span><br><span class="line">                            new BufferedInputStream(createInputStream(file)), file.length());</span><br><span class="line">            try &#123;</span><br><span class="line">                //从磁盘获取缓存的CacheHeader</span><br><span class="line">                CacheHeader entryOnDisk = CacheHeader.readHeader(cis);</span><br><span class="line">                //如果传递进来的key和磁盘缓存中CacheHeader的key不相等，那么从内存缓存中</span><br><span class="line">                移除这个缓存</span><br><span class="line">                if (!TextUtils.equals(key, entryOnDisk.key)) &#123;</span><br><span class="line">                    removeEntry(key);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                //读取缓存文件中的http响应体内容，然后创建一个entry返回</span><br><span class="line">                byte[] data = streamToBytes(cis, cis.bytesRemaining());</span><br><span class="line">                return entry.toCacheEntry(data);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                cis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            remove(key);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>取数据首先从内存缓存中取出 <code>CacheHeader</code>，如果为 <code>null</code> 那么直接返回，接下来如果取到了缓存，那么直接从磁盘里读取 <code>CacheHeader</code>，如果存在两个 <code>key</code> 映射一个文件，那么就从内存缓存中移除这个缓存，最后将读取的文件组装成一个<code>entry</code> 返回。这里有个疑问就是什么时候存在两个 <code>key</code> 映射一个文件呢？我们知道每个内存缓存中的 <code>key</code> 是我们请求的 <code>url</code>，而磁盘缓存的文件名则是根据 <code>key</code> 的 <code>hash</code> 值计算得出，那么个人猜测有可能算出的文件名重复了，那么就会出现两个 <code>key</code> 对应一个文件，那么为了避免这种情况，需要先判断，出现了先从内存缓存移除，一般来说这种情况很少。   </p><p>我们看看从 <code>CountingInputStream</code> 读取字节的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static byte[] streamToBytes(CountingInputStream cis, long length) throws IOException &#123;</span><br><span class="line">       long maxLength = cis.bytesRemaining();</span><br><span class="line">       // 读取的字节数不能为负数，不能大于当前剩余的字节数，还有不能整型溢出</span><br><span class="line">       if (length &lt; 0 || length &gt; maxLength || (int) length != length) &#123;</span><br><span class="line">           throw new IOException(&quot;streamToBytes length=&quot; + length + &quot;, maxLength=&quot; + maxLength);</span><br><span class="line">       &#125;</span><br><span class="line">       byte[] bytes = new byte[(int) length];</span><br><span class="line">       new DataInputStream(cis).readFully(bytes);</span><br><span class="line">       return bytes;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法是从 <code>CountingInputStream</code> 读取响应头还有响应体，怎么实现分开读取的呢，因为文件缓存首先是缓存的<code>CacheHeader</code>，接下来会从总的字节数减去已经读取的字节数，那么剩下的字节数就是响应体了。读取响应头是依次读取的，首先会先读取魔数判断是否是写入的缓存，然后依次读取各个 <code>CacheHeader</code> 字段，最后剩下的就是响应体了，读取和写入的顺序要一致。</p><p>看一看缓存的清除方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized void clear() &#123;</span><br><span class="line">    File[] files = mRootDirectory.listFiles();</span><br><span class="line">    if (files != null) &#123;</span><br><span class="line">        for (File file : files) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mEntries.clear();</span><br><span class="line">    mTotalSize = 0;</span><br><span class="line">    VolleyLog.d(&quot;Cache cleared.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遍历磁盘的每一个缓存文件并删除，清除内存缓存，更新使 <code>size</code> 为0。<br>接下来看看使某一个缓存 <code>key</code> 无效的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized void invalidate(String key, boolean fullExpire) &#123;</span><br><span class="line">    Entry entry = get(key);</span><br><span class="line">    if (entry != null) &#123;</span><br><span class="line">        entry.softTtl = 0;</span><br><span class="line">        if (fullExpire) &#123;</span><br><span class="line">            entry.ttl = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        put(key, entry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里主要对传入的 <code>key</code> 使缓存新鲜度无效，然后根据传入的第二个值是否为 <code>true</code>，如果为 <code>true</code> 那么所有缓存都过期，否则只是缓存新鲜度过期，这里对 <code>softTtl</code> 和 <code>ttl</code> 值置为0，判断缓存过期的时候自然就小于当前时间返回 <code>true</code>，达到了过期的目的，最后存入内存缓存和磁盘缓存当中。</p><p>接下来我们看看一个特殊的类 <code>NoCache</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class NoCache implements Cache &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void clear() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Entry get(String key) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void put(String key, Entry entry) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void invalidate(String key, boolean fullExpire) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void remove(String key) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void initialize() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现 Cache 接口，不做任何操作的缓存实现类，可将它作为 <code>RequestQueue</code> 的参数实现一个默认不缓存的请求队列，后续取到的缓存都为 <code>null</code>。</p><h4 id="三、缓存的使用"><a href="#三、缓存的使用" class="headerlink" title="三、缓存的使用"></a>三、缓存的使用</h4><p>我们梳理下整个流程，看这几个方法的调用时期：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static RequestQueue newRequestQueue(Context context, Network network) &#123;</span><br><span class="line">    File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">    RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);</span><br><span class="line">    queue.start();</span><br><span class="line">    return queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先这里调用了 <code>DiskBasedCache</code> 的构造方法，缓存默认大小是5M，缓存文件夹为 <code>volley</code>。<br>然后在 <code>CacheDispatcher</code> 的 <code>run</code> 方法里面实现了调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);</span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line"></span><br><span class="line">    // Make a blocking call to initialize the cache.</span><br><span class="line">    mCache.initialize();</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            processRequest();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            // We may have been interrupted because it was time to quit.</span><br><span class="line">            if (mQuit) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            VolleyLog.e(</span><br><span class="line">                    &quot;Ignoring spurious interrupt of CacheDispatcher thread; &quot;</span><br><span class="line">                            + &quot;use quit() to terminate it&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个类前面我们分析过，发起网络请求的时候会启动五个线程，一个缓存请求线程，四个网络请求分发的线程。首先在缓存线程里执行了缓存的初始化，如果关闭了应用那么重新发起请求的时候原来的缓存会重新缓存到到内存中。</p><p>然后在 <code>CacheDispatcher</code> 里发起请求之前首先会从磁盘缓存获取缓存的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache.Entry entry = mCache.get(request.getCacheKey());</span><br></pre></td></tr></table></figure></p><p>然后在 <code>NetworkDispatcher</code> 的请求到数据并缓存到根据 <code>url</code> 生成的缓存键的磁盘缓存中，缓存键默认是 <code>url</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</span><br><span class="line">    mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">    request.addMarker(&quot;network-cache-written&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="四、-总结"><a href="#四、-总结" class="headerlink" title="四、 总结"></a>四、 总结</h4><p><code>Volley</code> 的缓存机制分析完毕了，可以看出 <code>Volley</code> 缓存设计考虑了很多细节，对各种缓存头的解析，将请求的响应和缓存头的相关信息缓存到磁盘缓存，缓存头的信息也缓存到内存缓存，将二者很好的联系起来，便于读取和查找缓存等一系列操作。缓存命中率、缓存的替换算法、缓存文件名的计算、使用接口抽象等设计都值得我们认真学习。</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://github.com/wangzhengyi/Volley/blob/master/VOLLEY_CACHE.md" target="_blank" rel="noopener">Volley的缓存机制</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">Cache-Control</a><br><a href="https://www.zcfy.cc/article/caching-best-practices-amp-max-age-gotchas-jakearchibald-com" target="_blank" rel="noopener">缓存最佳实践及 max-age 注意事项</a><br><a href="https://xesam.github.io/computer/2017/05/08/http-cache-control-extensions-for-stale.html" target="_blank" rel="noopener">Cache-Control扩展</a><br><a href="https://www.kymjs.com/code/2016/03/08/01/" target="_blank" rel="noopener">面试后的总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h4&gt;&lt;p&gt;前面我们分析了 &lt;code&gt;Volley&lt;/code&gt; 的网络请求的相关流程以及图片加载的源码，如果没有看过的话可以阅读一下
      
    
    </summary>
    
      <category term="源码解析" scheme="https://wvisible.github.io/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Volley" scheme="https://wvisible.github.io/tags/Volley/"/>
    
  </entry>
  
  <entry>
    <title>Volley 源码解析之图片请求</title>
    <link href="https://wvisible.github.io/2020/03/05/Volley-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%9B%BE%E7%89%87%E8%AF%B7%E6%B1%82/"/>
    <id>https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/</id>
    <published>2020-03-05T15:45:28.000Z</published>
    <updated>2020-03-06T08:42:03.273Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章<a href="https://juejin.im/post/5c1c58b35188251f1f320e70" target="_blank" rel="noopener">Volley 源码解析之网络请求</a>。Volley 不仅仅对请求网络数据作了良好的封装，还封装了对图片的加载等操作，虽然比不上 <code>Glide</code>、<code>Fresco</code>，不过可以满足我们的日常使用，从学习者的角度看看是怎么封装的。<br>上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章<a href="https://juejin.im/post/5c1c58b35188251f1f320e70" target="_blank" rel="noopener">Volley 源码解析之网络请求</a>。Volley 不仅仅对请求网络数据作了良好的封装，还封装了对图片的加载等操作，虽然比不上 <code>Glide</code>、<code>Fresco</code>，不过可以满足我们的日常使用，从学习者的角度看看是怎么封装的。</p><h4 id="二、简单使用"><a href="#二、简单使用" class="headerlink" title="二、简单使用"></a>二、简单使用</h4><ol><li><p>使用 <code>ImageRequest</code> 加载图片，用法跟请求网络的用法差不多，只是构造request的参数不太一样：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String imageUrl = &quot;https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;;</span><br><span class="line">RequestQueue queue = Volley.newRequestQueue(this);</span><br><span class="line">ImageRequest imageRequest = new ImageRequest(imageUrl,</span><br><span class="line">                   response -&gt; imageView.setImageBitmap(response),</span><br><span class="line">                   0, 0, ImageView.ScaleType.CENTER_CROP, Bitmap.Config.ARGB_8888,</span><br><span class="line">                   error -&gt; &#123;&#125;);</span><br><span class="line">queue.add(imageRequest);</span><br></pre></td></tr></table></figure><ul><li>第一个参数是图片地址没啥说的</li><li>第二个参数是成功的回调，返回一个bitmap</li><li>第三和第四个参数则是图片的最大的高度和宽度，0为默认图片大小，如果填写的图片最大的高度和宽度小于图片的实际尺寸则会进行压缩</li><li>第五个值就是对图片进行边界缩放</li><li>第六个参数是图片的格式，常用的就是 <code>RGB_565</code> 和 <code>ARGB_8888</code>，前者每个像素占2个字节，后者每个像素占4个字节，后者成像质量高，有alpha通道，如果使用的是jpg，不需要alpha通道则可以使用前者； 还有个 <code>ARGB_4444</code>，不过已经废弃了，在4.4以后默认转成 <code>ARGB_8888</code>， <code>ALPHA_8</code> 只有透明度，没有颜色值，一般很少使用</li><li>最后个参数就是错误的回调</li></ul></li><li><p>使用 <code>ImageLoader</code> 加载图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">String imageUrl = &quot;https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;;</span><br><span class="line">RequestQueue queue = Volley.newRequestQueue(this);</span><br><span class="line">ImageLoader imageLoader = new ImageLoader(queue, new BitmapCache());</span><br><span class="line">ImageLoader.ImageListener imageListener = ImageLoader.getImageListener(imageView, </span><br><span class="line">     R.mipmap.ic_launcher, R.mipmap.ic_launcher_round);</span><br><span class="line">imageLoader.get(imageUrl,</span><br><span class="line">     imageListener, 0, 0);</span><br><span class="line">private class BitmapCache implements ImageLoader.ImageCache&#123;</span><br><span class="line">     private LruCache&lt;String, Bitmap&gt; lruCache;</span><br><span class="line"></span><br><span class="line">     public BitmapCache() &#123;</span><br><span class="line">         int maxSize = 10 * 1024 * 1024;</span><br><span class="line">         lruCache = new LruCache&lt;String, Bitmap&gt;(maxSize) &#123;</span><br><span class="line">             @Override</span><br><span class="line">             protected int sizeOf(String key, Bitmap bitmap) &#123;</span><br><span class="line">                 return bitmap.getRowBytes() * bitmap.getHeight();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public Bitmap getBitmap(String url) &#123;</span><br><span class="line">         return lruCache.get(url);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void putBitmap(String url, Bitmap bitmap) &#123;</span><br><span class="line">         lruCache.put(url, bitmap);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>NetworkImageView</code> 加载图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout</span><br><span class="line"> xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line"> xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line"> xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line"> android:layout_width=&quot;match_parent&quot;</span><br><span class="line"> android:layout_height=&quot;match_parent&quot;</span><br><span class="line"> tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line"> &lt;Button</span><br><span class="line">     android:id=&quot;@+id/button&quot;</span><br><span class="line">     android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_marginStart=&quot;8dp&quot;</span><br><span class="line">     android:layout_marginTop=&quot;88dp&quot;</span><br><span class="line">     android:layout_marginEnd=&quot;8dp&quot;</span><br><span class="line">     android:text=&quot;Button&quot;</span><br><span class="line">     app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">     app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">     app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line"> &lt;com.android.volley.toolbox.NetworkImageView</span><br><span class="line">     android:id=&quot;@+id/imageView&quot;</span><br><span class="line">     android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">     android:layout_marginStart=&quot;8dp&quot;</span><br><span class="line">     android:layout_marginTop=&quot;32dp&quot;</span><br><span class="line">     android:layout_marginEnd=&quot;8dp&quot;</span><br><span class="line">     app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">     app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">     app:layout_constraintTop_toBottomOf=&quot;@+id/textView&quot;</span><br><span class="line">     tools:srcCompat=&quot;@tools:sample/avatars&quot; /&gt;</span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String imageUrl = &quot;https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;;</span><br><span class="line">NetworkImageView networkImageView = findViewById(R.id.imageView);</span><br><span class="line">networkImageView.setDefaultImageResId(R.mipmap.ic_launcher);</span><br><span class="line">networkImageView.setErrorImageResId(R.mipmap.ic_launcher_round);</span><br><span class="line">networkImageView.setImageUrl(imageUrl, imageLoader);</span><br></pre></td></tr></table></figure></li></ol><h4 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h4><h5 id="一、-ImageRequest-分析"><a href="#一、-ImageRequest-分析" class="headerlink" title="一、 ImageRequest 分析"></a>一、 ImageRequest 分析</h5><p>首先我们分析 <code>ImageRequest</code>，直接分析这个类，代码不多，直接继承 <code>Request</code>，那么不用说跟上一篇我们分析的网络请求的<code>request</code> 大体相同，不同的是这个是请求图片，如果我们需要自定义大小那么这里就对图片进行了裁剪以满足我们的大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line">public class ImageRequest extends Request&lt;Bitmap&gt; &#123;</span><br><span class="line">    //图片请求的超时时间，单位毫秒</span><br><span class="line">    public static final int DEFAULT_IMAGE_TIMEOUT_MS = 1000;</span><br><span class="line"></span><br><span class="line">    //图片请求的默认重试次数</span><br><span class="line">    public static final int DEFAULT_IMAGE_MAX_RETRIES = 2;</span><br><span class="line"></span><br><span class="line">    //发生冲突时的默认重传延迟增加数，和TCP协议有关系，退避算法，短时间的重复请求失败还会是失败</span><br><span class="line">    public static final float DEFAULT_IMAGE_BACKOFF_MULT = 2f;</span><br><span class="line"></span><br><span class="line">    //对mListener加锁，保证线程安全，避免取消的时候同时执行分发</span><br><span class="line">    private final Object mLock = new Object();</span><br><span class="line"></span><br><span class="line">    @GuardedBy(&quot;mLock&quot;)</span><br><span class="line">    @Nullable</span><br><span class="line">    private Response.Listener&lt;Bitmap&gt; mListener;</span><br><span class="line"></span><br><span class="line">    private final Config mDecodeConfig;</span><br><span class="line">    private final int mMaxWidth;</span><br><span class="line">    private final int mMaxHeight;</span><br><span class="line">    private final ScaleType mScaleType;</span><br><span class="line"></span><br><span class="line">    //Bitmap 的同步解析锁，保证一个时间内只有一个Bitmap被加载到内存进行解析，避免多个同时解析oom</span><br><span class="line">    private static final Object sDecodeLock = new Object();</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    public ImageRequest(</span><br><span class="line">            String url,</span><br><span class="line">            Response.Listener&lt;Bitmap&gt; listener,</span><br><span class="line">            int maxWidth,</span><br><span class="line">            int maxHeight,</span><br><span class="line">            ScaleType scaleType,</span><br><span class="line">            Config decodeConfig,</span><br><span class="line">            @Nullable Response.ErrorListener errorListener) &#123;</span><br><span class="line">        super(Method.GET, url, errorListener);</span><br><span class="line">        setRetryPolicy(</span><br><span class="line">                new DefaultRetryPolicy(</span><br><span class="line">                        DEFAULT_IMAGE_TIMEOUT_MS,</span><br><span class="line">                        DEFAULT_IMAGE_MAX_RETRIES,</span><br><span class="line">                        DEFAULT_IMAGE_BACKOFF_MULT));</span><br><span class="line">        mListener = listener;</span><br><span class="line">        mDecodeConfig = decodeConfig;</span><br><span class="line">        mMaxWidth = maxWidth;</span><br><span class="line">        mMaxHeight = maxHeight;</span><br><span class="line">        mScaleType = scaleType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Deprecated</span><br><span class="line">    public ImageRequest(</span><br><span class="line">            String url,</span><br><span class="line">            Response.Listener&lt;Bitmap&gt; listener,</span><br><span class="line">            int maxWidth,</span><br><span class="line">            int maxHeight,</span><br><span class="line">            Config decodeConfig,</span><br><span class="line">            Response.ErrorListener errorListener) &#123;</span><br><span class="line">        this(</span><br><span class="line">                url,</span><br><span class="line">                listener,</span><br><span class="line">                maxWidth,</span><br><span class="line">                maxHeight,</span><br><span class="line">                ScaleType.CENTER_INSIDE,</span><br><span class="line">                decodeConfig,</span><br><span class="line">                errorListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Priority getPriority() &#123;</span><br><span class="line">        return Priority.LOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据ScaleType设置图片大小</span><br><span class="line">    private static int getResizedDimension(</span><br><span class="line">            int maxPrimary,</span><br><span class="line">            int maxSecondary,</span><br><span class="line">            int actualPrimary,</span><br><span class="line">            int actualSecondary,</span><br><span class="line">            ScaleType scaleType) &#123;</span><br><span class="line"></span><br><span class="line">        // 如果主要值和次要的值为0，就返回实际值，如果我们计算宽度的期望值，</span><br><span class="line">        那么主要值就是宽度，高度就是次要值，反之亦然</span><br><span class="line">        if ((maxPrimary == 0) &amp;&amp; (maxSecondary == 0)) &#123;</span><br><span class="line">            return actualPrimary;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果为ScaleType.FIT_XY，填充整个矩形，忽略比值；</span><br><span class="line">        即如果主要的值为0则返回实际值，否则返回传入的值</span><br><span class="line">        if (scaleType == ScaleType.FIT_XY) &#123;</span><br><span class="line">            if (maxPrimary == 0) &#123;</span><br><span class="line">                return actualPrimary;</span><br><span class="line">            &#125;</span><br><span class="line">            return maxPrimary;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果主要的值为0，则通过比例值计算出主要的值返回</span><br><span class="line">        if (maxPrimary == 0) &#123;</span><br><span class="line">            double ratio = (double) maxSecondary / (double) actualSecondary;</span><br><span class="line">            return (int) (actualPrimary * ratio);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 次要的值为0，下面的比例调整就是多余的，那么直接返回主要的值，</span><br><span class="line">        if (maxSecondary == 0) &#123;</span><br><span class="line">            return maxPrimary;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 图片真实尺寸大小的比例，通过这个比例我们可以计算出次要的最大值，通</span><br><span class="line">        过计算出的值和我们传递进来的值做比较</span><br><span class="line">        double ratio = (double) actualSecondary / (double) actualPrimary;</span><br><span class="line">        int resized = maxPrimary;</span><br><span class="line"></span><br><span class="line">        // 如果是ScaleType.CENTER_CROP，填充整个矩形，保持长宽比，这里的宽高值相等或者大于传入的宽高尺寸</span><br><span class="line">        if (scaleType == ScaleType.CENTER_CROP) &#123;</span><br><span class="line">            // 小于传入的次要最大值，则返回通过比例计算的最大值，这里相当于把resized 值增大</span><br><span class="line">            if ((resized * ratio) &lt; maxSecondary) &#123;</span><br><span class="line">                resized = (int) (maxSecondary / ratio);</span><br><span class="line">            &#125;</span><br><span class="line">            return resized;</span><br><span class="line">        &#125;</span><br><span class="line">        //  其它scaleType值，如果计算的值大于次要值，那么resized 值减小</span><br><span class="line">        if ((resized * ratio) &gt; maxSecondary) &#123;</span><br><span class="line">            resized = (int) (maxSecondary / ratio);</span><br><span class="line">        &#125;</span><br><span class="line">        return resized;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //解析response</span><br><span class="line">    @Override</span><br><span class="line">    protected Response&lt;Bitmap&gt; parseNetworkResponse(NetworkResponse response) &#123;</span><br><span class="line">        synchronized (sDecodeLock) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return doParse(response);</span><br><span class="line">            &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">                VolleyLog.e(&quot;Caught OOM for %d byte image, url=%s&quot;, response.data.length, getUrl());</span><br><span class="line">                return Response.error(new ParseError(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //解析的地方</span><br><span class="line">    private Response&lt;Bitmap&gt; doParse(NetworkResponse response) &#123;</span><br><span class="line">        byte[] data = response.data;</span><br><span class="line">        BitmapFactory.Options decodeOptions = new BitmapFactory.Options();</span><br><span class="line">        Bitmap bitmap = null;</span><br><span class="line">        //如果最大宽度和最大高度都传入的为0，直接解析成一个bitmap</span><br><span class="line">        if (mMaxWidth == 0 &amp;&amp; mMaxHeight == 0) &#123;</span><br><span class="line">            decodeOptions.inPreferredConfig = mDecodeConfig;</span><br><span class="line">            bitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果要调整图片的大小，首先获取图片真实的尺寸大小，首先设置inJustDecodeBounds为true，不加载到内存但是可以获取图像的宽高</span><br><span class="line">            decodeOptions.inJustDecodeBounds = true;</span><br><span class="line">            BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);</span><br><span class="line">            int actualWidth = decodeOptions.outWidth;</span><br><span class="line">            int actualHeight = decodeOptions.outHeight;</span><br><span class="line"></span><br><span class="line">            // 计算我们想要的尺寸</span><br><span class="line">            int desiredWidth =</span><br><span class="line">                    getResizedDimension(</span><br><span class="line">                            mMaxWidth, mMaxHeight, actualWidth, actualHeight, mScaleType);</span><br><span class="line">            int desiredHeight =</span><br><span class="line">                    getResizedDimension(</span><br><span class="line">                            mMaxHeight, mMaxWidth, actualHeight, actualWidth, mScaleType);</span><br><span class="line"></span><br><span class="line">            // 计算出采样值，2的倍数</span><br><span class="line">            decodeOptions.inJustDecodeBounds = false;</span><br><span class="line">            decodeOptions.inSampleSize =</span><br><span class="line">                    findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight);</span><br><span class="line">            Bitmap tempBitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);</span><br><span class="line"></span><br><span class="line">            // 如果采样率计算出的值为1的话，那么就没有尺寸压缩，tempBitmap的宽高值就是图片的</span><br><span class="line">            真实值，那么这里就需要缩放到满足我们上面计算出来的值</span><br><span class="line">            if (tempBitmap != null</span><br><span class="line">                    &amp;&amp; (tempBitmap.getWidth() &gt; desiredWidth</span><br><span class="line">                            || tempBitmap.getHeight() &gt; desiredHeight)) &#123;</span><br><span class="line">                bitmap = Bitmap.createScaledBitmap(tempBitmap, desiredWidth, desiredHeight, true);</span><br><span class="line">                tempBitmap.recycle();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                bitmap = tempBitmap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //回调给用户</span><br><span class="line">        if (bitmap == null) &#123;</span><br><span class="line">            return Response.error(new ParseError(response));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Response.success(bitmap, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void cancel() &#123;</span><br><span class="line">        super.cancel();</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            mListener = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void deliverResponse(Bitmap response) &#123;</span><br><span class="line">        Response.Listener&lt;Bitmap&gt; listener;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            listener = mListener;</span><br><span class="line">        &#125;</span><br><span class="line">        if (listener != null) &#123;</span><br><span class="line">            listener.onResponse(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算合适的采样率</span><br><span class="line">    @VisibleForTesting</span><br><span class="line">    static int findBestSampleSize(</span><br><span class="line">            int actualWidth, int actualHeight, int desiredWidth, int desiredHeight) &#123;</span><br><span class="line">        double wr = (double) actualWidth / desiredWidth;</span><br><span class="line">        double hr = (double) actualHeight / desiredHeight;</span><br><span class="line">        double ratio = Math.min(wr, hr);</span><br><span class="line">        float n = 1.0f;</span><br><span class="line">        while ((n * 2) &lt;= ratio) &#123;</span><br><span class="line">            n *= 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (int) n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键部分我都写了注释，下面我们看主要流程，对 <code>Bitmap</code> 的高效加载。首先我们获取到返回的 <code>response</code> 进行解析，然后根据传递的期望宽高以及图片格式生成 <code>Bitmap</code> 返回，对于我们传入的宽高会按比例裁剪，不是直接使用裁剪到合适的值，不然会有拉伸，最后再回调给用户。</p><h5 id="二、ImageLoader-分析"><a href="#二、ImageLoader-分析" class="headerlink" title="二、ImageLoader 分析"></a>二、ImageLoader 分析</h5><p>我们直接先看构造方法，看所有的关键地方，不重要的就不分析了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ImageLoader(RequestQueue queue, ImageCache imageCache) &#123;</span><br><span class="line">        mRequestQueue = queue;</span><br><span class="line">        mCache = imageCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>没啥说的，就是赋值，一个是请求队列，一个是图片缓存的自己实现，这个是在内部把请求添加到请求队列，所以直接传递进去，第二个参数缓存，我们可以自己实现，一般使用 <code>LruCache</code> 实现。<br>接下来我们接着看 <code>getImageListener</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static ImageListener getImageListener(</span><br><span class="line">            final ImageView view, final int defaultImageResId, final int errorImageResId) &#123;</span><br><span class="line">        return new ImageListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onErrorResponse(VolleyError error) &#123;</span><br><span class="line">                if (errorImageResId != 0) &#123;</span><br><span class="line">                    view.setImageResource(errorImageResId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(ImageContainer response, boolean isImmediate) &#123;</span><br><span class="line">                if (response.getBitmap() != null) &#123;</span><br><span class="line">                    view.setImageBitmap(response.getBitmap());</span><br><span class="line">                &#125; else if (defaultImageResId != 0) &#123;</span><br><span class="line">                    view.setImageResource(defaultImageResId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法比较简单，就是传入我们的 <code>ImageView</code> 进行设置图像，然后分别提供一个默认和请求失败的占位图，刚开始设置的时候还没有请求到 <code>Bitmap</code>,所以最开始设置的事默认图。<br>首先看两个变量，后面需要用到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//相同URL正在请求中存储的map</span><br><span class="line">private final HashMap&lt;String, BatchedImageRequest&gt; mInFlightRequests = new HashMap&lt;&gt;();</span><br><span class="line">//相同URL请求结果存储的map</span><br><span class="line">private final HashMap&lt;String, BatchedImageRequest&gt; mBatchedResponses = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>接下来我们看看关键的一步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    @MainThread</span><br><span class="line">    public ImageContainer get(</span><br><span class="line">            String requestUrl,</span><br><span class="line">            ImageListener imageListener,</span><br><span class="line">            int maxWidth,</span><br><span class="line">            int maxHeight,</span><br><span class="line">            ScaleType scaleType) &#123;</span><br><span class="line"></span><br><span class="line">        // 检查当前线程是否在主线程，只满足从主线程发起的请求</span><br><span class="line">        Threads.throwIfNotOnMainThread();</span><br><span class="line"></span><br><span class="line">        //根据url、width、height、scaleType拼接的缓存key</span><br><span class="line">        final String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight, scaleType);</span><br><span class="line"></span><br><span class="line">        // 从缓存中查找bitmap</span><br><span class="line">        Bitmap cachedBitmap = mCache.getBitmap(cacheKey);</span><br><span class="line">        if (cachedBitmap != null) &#123;</span><br><span class="line">            // 有相应的缓存那么则返回一个ImageContainer，包括其中的bitmap</span><br><span class="line">            ImageContainer container =</span><br><span class="line">                    new ImageContainer(</span><br><span class="line">                            cachedBitmap, requestUrl, /* cacheKey= */ null, /* listener= */ null);</span><br><span class="line">            // 直接调用onResponse，把bitmap设置给imageView</span><br><span class="line">            imageListener.onResponse(container, true);</span><br><span class="line">            return container;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 缓存中没有查找到，那么我们直接获取，首先new一个ImageContainer</span><br><span class="line">        ImageContainer imageContainer =</span><br><span class="line">                new ImageContainer(null, requestUrl, cacheKey, imageListener);</span><br><span class="line"></span><br><span class="line">        // 更新调用的地方，使用默认的图片先设置</span><br><span class="line">        imageListener.onResponse(imageContainer, true);</span><br><span class="line">        //检查是否有相同的cacheKey请求正在运行</span><br><span class="line">        BatchedImageRequest request = mInFlightRequests.get(cacheKey);</span><br><span class="line">        if (request != null) &#123;</span><br><span class="line">            // 如果相同的请求正在运行，那么不需要重复请求，只需要将这个实例化</span><br><span class="line">            的imageContainer添加到BatchedImageRequest的mContainers中，然后请</span><br><span class="line">            求结束后对所有添加到集合中的imageContainer依次回调</span><br><span class="line">            request.addContainer(imageContainer);</span><br><span class="line">            return imageContainer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果这个请求尚未执行，发送一个新的请求到网络上，这里才是执行请求的地方</span><br><span class="line">        Request&lt;Bitmap&gt; newRequest =</span><br><span class="line">                makeImageRequest(requestUrl, maxWidth, maxHeight, scaleType, cacheKey);</span><br><span class="line">        //添加到请求队列</span><br><span class="line">        mRequestQueue.add(newRequest);</span><br><span class="line">        //添加到正在请求的集合中</span><br><span class="line">        mInFlightRequests.put(cacheKey, new BatchedImageRequest(newRequest, imageContainer));</span><br><span class="line">        return imageContainer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法是一个重点，主要流程是首先看看缓存里面有没有缓存的 <code>Bitmap</code>,来源于我们自己实现的缓存策略，我们使用的是内存缓存的话这里就是一级缓存；如果有直接调用 <code>onResponse</code> 方法设置图片，如果没有，首先实例化 <code>ImageContainer</code>，涉及到了几个类，接下来就看是否有相同的请求，如果有则添加到一个集合中，请求下来统一处理；如果没有那么则构造一个 <code>Request</code>，通过 <code>RequestQueue</code> 去获取网络图片，可能是网络请求也有可能是磁盘缓存的，这里就是二级缓存，然后添加到正在请求的集合中。<br>接下来看一看 <code>ImageContainer</code> 这个类,这个类就是图像请求的一个容器对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class ImageContainer &#123;</span><br><span class="line">        //imageview加载的Bitmap</span><br><span class="line">        private Bitmap mBitmap;</span><br><span class="line">        </span><br><span class="line">        //图片加载成功和失败的监听</span><br><span class="line">        private final ImageListener mListener;</span><br><span class="line"></span><br><span class="line">        //缓存的key</span><br><span class="line">        private final String mCacheKey;</span><br><span class="line"></span><br><span class="line">        //请求指定的URL</span><br><span class="line">        private final String mRequestUrl;</span><br><span class="line"></span><br><span class="line">        public ImageContainer(</span><br><span class="line">                Bitmap bitmap, String requestUrl, String cacheKey, ImageListener listener) &#123;</span><br><span class="line">            mBitmap = bitmap;</span><br><span class="line">            mRequestUrl = requestUrl;</span><br><span class="line">            mCacheKey = cacheKey;</span><br><span class="line">            mListener = listener;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //取消请求</span><br><span class="line">        @MainThread</span><br><span class="line">        public void cancelRequest() &#123;</span><br><span class="line">            Threads.throwIfNotOnMainThread();</span><br><span class="line"></span><br><span class="line">            if (mListener == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //从正在请求的集合获取一个批处理request</span><br><span class="line">            BatchedImageRequest request = mInFlightRequests.get(mCacheKey);</span><br><span class="line">            if (request != null) &#123;</span><br><span class="line">                //如果取到request，那么首先从mContainers移除当前的这个ImageContainer，</span><br><span class="line">                如果移除后集合为空一个ImageContainer也没有了，那么则取消掉这个请求并返回 true</span><br><span class="line">                boolean canceled = request.removeContainerAndCancelIfNecessary(this);</span><br><span class="line">                if (canceled) &#123;</span><br><span class="line">                    //取消了请求则从正在请求的集合中移除BatchedImageRequest</span><br><span class="line">                    mInFlightRequests.remove(mCacheKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果已经请求完成添加到批处理中准备处理分发</span><br><span class="line">                request = mBatchedResponses.get(mCacheKey);</span><br><span class="line">                if (request != null) &#123;</span><br><span class="line">                    //首先从mContainers移除当前的这个ImageContainer</span><br><span class="line">                    request.removeContainerAndCancelIfNecessary(this);</span><br><span class="line">                    if (request.mContainers.size() == 0) &#123;</span><br><span class="line">                        //如果集合中一个ImageContainer都没有，则从等待处理的</span><br><span class="line">                        response中移除掉这个BatchedImageRequest</span><br><span class="line">                        mBatchedResponses.remove(mCacheKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Bitmap getBitmap() &#123;</span><br><span class="line">            return mBitmap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /** Returns the requested URL for this container. */</span><br><span class="line">        public String getRequestUrl() &#123;</span><br><span class="line">            return mRequestUrl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个类主要包含是一个图片的容器对象，里面包括了 <code>bitmap</code>、监听器、缓存的key以及请求的 <code>URL</code>，每个请求都会先组装这个类，然后添加到一个 <code>BatchedImageRequest的mContainers</code> 中</p><p>接下来我们看看真正发起请求的地方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">protected Request&lt;Bitmap&gt; makeImageRequest(</span><br><span class="line">            String requestUrl,</span><br><span class="line">            int maxWidth,</span><br><span class="line">            int maxHeight,</span><br><span class="line">            ScaleType scaleType,</span><br><span class="line">            final String cacheKey) &#123;</span><br><span class="line">        return new ImageRequest(</span><br><span class="line">                requestUrl,</span><br><span class="line">                new Listener&lt;Bitmap&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onResponse(Bitmap response) &#123;</span><br><span class="line">                        onGetImageSuccess(cacheKey, response);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                maxWidth,</span><br><span class="line">                maxHeight,</span><br><span class="line">                scaleType,</span><br><span class="line">                Config.RGB_565,</span><br><span class="line">                new ErrorListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onErrorResponse(VolleyError error) &#123;</span><br><span class="line">                        onGetImageError(cacheKey, error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //图片请求成功</span><br><span class="line">    protected void onGetImageSuccess(String cacheKey, Bitmap response) &#123;</span><br><span class="line">        // 添加到以及缓存中</span><br><span class="line">        mCache.putBitmap(cacheKey, response);</span><br><span class="line"></span><br><span class="line">        // 从正在运行的请求列表中删除这个请求</span><br><span class="line">        BatchedImageRequest request = mInFlightRequests.remove(cacheKey);</span><br><span class="line"></span><br><span class="line">        if (request != null) &#123;</span><br><span class="line">            //更新BatchedImageRequest的bitmap</span><br><span class="line">            request.mResponseBitmap = response;</span><br><span class="line">            //发送一个批处理请求，将多个相同的请求进行分发</span><br><span class="line">            batchResponse(cacheKey, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //图片请求失败，跟上面成功处理大致类似</span><br><span class="line">    protected void onGetImageError(String cacheKey, VolleyError error) &#123;</span><br><span class="line">        BatchedImageRequest request = mInFlightRequests.remove(cacheKey);</span><br><span class="line"></span><br><span class="line">        if (request != null) &#123;</span><br><span class="line">            //设置这个请求的错误</span><br><span class="line">            request.setError(error);</span><br><span class="line"></span><br><span class="line">            batchResponse(cacheKey, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里执行网络请求还是调用我们上面分析的 <code>ImageRequest</code> 方法，而且在回调中分别对成功和失败在进行了一次处理。<br>接下来我们看看这个批量处理图片的 <code>batchResponse</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void batchResponse(String cacheKey, BatchedImageRequest request) &#123;</span><br><span class="line">        //首先添加到这个map中，表明现在进入了批处理中</span><br><span class="line">        mBatchedResponses.put(cacheKey, request);</span><br><span class="line">        // 如果还没有进行处理，那么我们则开始一个新的任务</span><br><span class="line">        if (mRunnable == null) &#123;</span><br><span class="line">            mRunnable =</span><br><span class="line">                    new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            //循环mBatchedResponses的所有值</span><br><span class="line">                            for (BatchedImageRequest bir : mBatchedResponses.values()) &#123;</span><br><span class="line">                                //循环BatchedImageRequest的mContainers的值</span><br><span class="line">                                for (ImageContainer container : bir.mContainers) &#123;</span><br><span class="line">                                    //如果有的请求取消了，在收到请求的</span><br><span class="line">                                    响应后还没有分发之前那么跳过循环下一个</span><br><span class="line">                                    if (container.mListener == null) &#123;</span><br><span class="line">                                        continue;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    // 如果不是请求错误则调用onResponse</span><br><span class="line">                                    if (bir.getError() == null) &#123;</span><br><span class="line">                                        container.mBitmap = bir.mResponseBitmap;</span><br><span class="line">                                        container.mListener.onResponse(container, false);</span><br><span class="line">                                    &#125; else &#123;</span><br><span class="line">                                       //请求报错则调用onErrorResponse设置一个错误的图片展示 container.mListener.onErrorResponse(bir.getError());</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            //清除所有响应的BatchedImageRequest</span><br><span class="line">                            mBatchedResponses.clear();</span><br><span class="line">                            //置为null，通过是否为null判断当前是否正在处理</span><br><span class="line">                            mRunnable = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">            // 将这个post投递到主线程去执行</span><br><span class="line">            mHandler.postDelayed(mRunnable, mBatchResponseDelayMs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这段代码也很简单，不过有个地方有个比较奇怪的地方，为啥是使用双层循环，为啥不直接使用内层的循环；个人认为有可能是这样，首先这个 <code>mBatchedResponses</code> 刚开始进来添加了相同的key的请求的 <code>BatchedImageRequest</code>，那么存在正在分发的时候又有不同的key的请求进来了，因为正在处理的时候 <code>runnable</code> 不为 <code>null</code>，则后续添加的有可能不能分发，所以要遍历这个 <code>map</code>中所有的请求。</p><h5 id="三、-NetworkImageView-分析"><a href="#三、-NetworkImageView-分析" class="headerlink" title="三、 NetworkImageView 分析"></a>三、 NetworkImageView 分析</h5><p>这是一个继承 <code>ImageView</code> 的自定义 <code>view</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">public class NetworkImageView extends ImageView &#123;</span><br><span class="line">    private String mUrl;</span><br><span class="line">    //设置默认的图片</span><br><span class="line">    private int mDefaultImageId;</span><br><span class="line">    //设置请求错误的时候显示的图片</span><br><span class="line">    private int mErrorImageId;</span><br><span class="line">    </span><br><span class="line">    private ImageLoader mImageLoader;</span><br><span class="line">    private ImageContainer mImageContainer;</span><br><span class="line"></span><br><span class="line">    public NetworkImageView(Context context) &#123;</span><br><span class="line">        this(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NetworkImageView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NetworkImageView(Context context, AttributeSet attrs, int defStyle) &#123;</span><br><span class="line">        super(context, attrs, defStyle);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //这个方法就是设置我们的url</span><br><span class="line">    @MainThread</span><br><span class="line">    public void setImageUrl(String url, ImageLoader imageLoader) &#123;</span><br><span class="line">        Threads.throwIfNotOnMainThread();</span><br><span class="line">        mUrl = url;</span><br><span class="line">        mImageLoader = imageLoader;</span><br><span class="line">        // 我们的url可能已经更改，那么我们则需要判断是否需要加载</span><br><span class="line">        loadImageIfNecessary(/* isInLayoutPass= */ false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDefaultImageResId(int defaultImage) &#123;</span><br><span class="line">        mDefaultImageId = defaultImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setErrorImageResId(int errorImage) &#123;</span><br><span class="line">        mErrorImageId = errorImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果视图尚未加载图像，那么我们则去加载它</span><br><span class="line">    void loadImageIfNecessary(final boolean isInLayoutPass) &#123;</span><br><span class="line">        int width = getWidth();</span><br><span class="line">        int height = getHeight();</span><br><span class="line">        ScaleType scaleType = getScaleType();</span><br><span class="line"></span><br><span class="line">        boolean wrapWidth = false, wrapHeight = false;</span><br><span class="line">        if (getLayoutParams() != null) &#123;</span><br><span class="line">            wrapWidth = getLayoutParams().width == LayoutParams.WRAP_CONTENT;</span><br><span class="line">            wrapHeight = getLayoutParams().height == LayoutParams.WRAP_CONTENT;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果不知道视图的大小并且不是WRAP_CONTENT就暂停加载</span><br><span class="line">        boolean isFullyWrapContent = wrapWidth &amp;&amp; wrapHeight;</span><br><span class="line">        if (width == 0 &amp;&amp; height == 0 &amp;&amp; !isFullyWrapContent) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果url为空的话则请取消所有的请求，包括以前的请求，假如请求两次</span><br><span class="line">        最后次的url为null，这时候还没请求完成，肯定以最后次为准</span><br><span class="line">        if (TextUtils.isEmpty(mUrl)) &#123;</span><br><span class="line">            if (mImageContainer != null) &#123;</span><br><span class="line">                mImageContainer.cancelRequest();</span><br><span class="line">                mImageContainer = null;</span><br><span class="line">            &#125;</span><br><span class="line">            //设置默认的图片</span><br><span class="line">            setDefaultImageOrNull();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查是否取消以前的请求</span><br><span class="line">        if (mImageContainer != null &amp;&amp; mImageContainer.getRequestUrl() != null) &#123;</span><br><span class="line">            if (mImageContainer.getRequestUrl().equals(mUrl)) &#123;</span><br><span class="line">                // 如果请求和以前相同则没必要再次请求</span><br><span class="line">                return;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果存在正在请求的url并且请求url不同，那么取消正在请求的url</span><br><span class="line">                mImageContainer.cancelRequest();</span><br><span class="line">                setDefaultImageOrNull();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 计算最大宽高，如果设置WRAP_CONTENT那么则图片是多大就是多大，其它</span><br><span class="line">        情况则直接使用布局的宽高，如果设置了具体的值就有可能裁剪</span><br><span class="line">        int maxWidth = wrapWidth ? 0 : width;</span><br><span class="line">        int maxHeight = wrapHeight ? 0 : height;</span><br><span class="line"></span><br><span class="line">        // 使用ImageLoader来请求图像，上面已经分析了，最终返回一个ImageContainer</span><br><span class="line">        mImageContainer =</span><br><span class="line">                mImageLoader.get(</span><br><span class="line">                        mUrl,</span><br><span class="line">                        new ImageListener() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void onErrorResponse(VolleyError error) &#123;</span><br><span class="line">                                if (mErrorImageId != 0) &#123;</span><br><span class="line">                                    setImageResource(mErrorImageId);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            @Override</span><br><span class="line">                            public void onResponse(</span><br><span class="line">                                    final ImageContainer response, boolean isImmediate) &#123;</span><br><span class="line">                                //isImmediate：在网络请求过程中调用的时候为true，可以用来</span><br><span class="line">                                区分是否是取的缓存图像还是网络图像加载</span><br><span class="line">                                isInLayoutPass：如果通过onLayout调用此函数，</span><br><span class="line">                                则为true，否则为false</span><br><span class="line">                                这个if的意思就是，如果是缓存图像并且是在布局中调用那么则发送</span><br><span class="line">                                到主线程并延迟设置图像，因为可能多次调用</span><br><span class="line">                                if (isImmediate &amp;&amp; isInLayoutPass) &#123;</span><br><span class="line">                                    post(</span><br><span class="line">                                            new Runnable() &#123;</span><br><span class="line">                                                @Override</span><br><span class="line">                                                public void run() &#123;</span><br><span class="line">                                                    onResponse(response, /* isImmediate= */ false);</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;);</span><br><span class="line">                                    return;</span><br><span class="line">                                &#125;</span><br><span class="line">                                //请求成功加载图片</span><br><span class="line">                                if (response.getBitmap() != null) &#123;</span><br><span class="line">                                    setImageBitmap(response.getBitmap());</span><br><span class="line">                                &#125; else if (mDefaultImageId != 0) &#123;</span><br><span class="line">                                    setImageResource(mDefaultImageId);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        maxWidth,</span><br><span class="line">                        maxHeight,</span><br><span class="line">                        scaleType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setDefaultImageOrNull() &#123;</span><br><span class="line">        if (mDefaultImageId != 0) &#123;</span><br><span class="line">            setImageResource(mDefaultImageId);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            setImageBitmap(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class="line">        super.onLayout(changed, left, top, right, bottom);</span><br><span class="line">        loadImageIfNecessary(/* isInLayoutPass= */ true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //当imageview销毁的时候，取消请求并且清除ImageContainer以便重新加载图像</span><br><span class="line">    @Override</span><br><span class="line">    protected void onDetachedFromWindow() &#123;</span><br><span class="line">        if (mImageContainer != null) &#123;</span><br><span class="line">            // If the view was bound to an image request, cancel it and clear</span><br><span class="line">            // out the image from the view.</span><br><span class="line">            mImageContainer.cancelRequest();</span><br><span class="line">            setImageBitmap(null);</span><br><span class="line">            // also clear out the container so we can reload the image if necessary.</span><br><span class="line">            mImageContainer = null;</span><br><span class="line">        &#125;</span><br><span class="line">        super.onDetachedFromWindow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void drawableStateChanged() &#123;</span><br><span class="line">        super.drawableStateChanged();</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个类没啥好分析的，就是利用前两个类来完成请求，只不过方便的是直接在xml中使用，使用 <code>ImageLoader</code> 请求的 <code>Bitmap</code> 设置给 <code>NetworkImageView</code>。</p><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>三种不同的方式都可以完成图片的加载，不过后面的方式都比较依赖前面的 <code>ImageRequest</code>，毕竟还是要这个类去完成网络请求操作；在使用中，根据不同的场景选择不同的方式使用。不过我建议使用 <code>ImageLoader</code> 来加载图片，可以自己设置缓存，两级缓存，一级内存缓存，一级 <code>volley</code> 请求时候的磁盘缓存。总体来讲封装的很不错，对一些细节处理的比较好，比如相同的请求、图片的裁剪等，值得我们学习的地方很多。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/guolin_blog/article/details/17482165" target="_blank" rel="noopener">Android Volley完全解析(二)，使用Volley加载网络图片</a><br><a href="https://github.com/wangzhengyi/Volley/blob/master/README.md" target="_blank" rel="noopener">Volley 源码解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h4&gt;&lt;p&gt;上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章&lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="源码解析" scheme="https://wvisible.github.io/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Volley" scheme="https://wvisible.github.io/tags/Volley/"/>
    
  </entry>
  
  <entry>
    <title>Volley 源码解析之网络请求</title>
    <link href="https://wvisible.github.io/2020/03/05/Volley-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    <id>https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/</id>
    <published>2020-03-05T15:36:09.000Z</published>
    <updated>2020-03-06T09:12:10.225Z</updated>
    
    <content type="html"><![CDATA[<p><strong><code>Volley</code>源码分析三部曲</strong><br><a href="https://juejin.im/post/5c1c58b35188251f1f320e70" target="_blank" rel="noopener">Volley 源码解析之网络请求</a><br><a href="https://juejin.im/post/5c1c84ade51d4535f05a192c" target="_blank" rel="noopener">Volley 源码解析之图片请求</a><br><a href="https://juejin.im/post/5c27a52de51d455fac46838d" target="_blank" rel="noopener">Volley 源码解析之缓存机制</a></p><blockquote><p><code>Volley</code> 是 <code>Google</code> 推出的一款网络通信框架，非常适合数据量小、通信频繁的网络请求，支持并发、缓存和容易扩展、调试等；不过不太适合下载大文件、大量数据的网络请求，因为 <code>Volley</code> 在解析期间将响应放到内存中，我们可以使用 <code>Okhttp</code> 或者系统提供的<code>DownloadManager</code>来下载文件。</p></blockquote><h4 id="一、简单使用"><a href="#一、简单使用" class="headerlink" title="一、简单使用"></a>一、简单使用</h4><p>首先在工程引入volley的library：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'com.android.volley:volley:1.1.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要我们打开网络权限，我这里直接贴出官网简单请求的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TextView mTextView = (TextView) findViewById(R.id.text);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate the RequestQueue.</span></span><br><span class="line">RequestQueue queue = Volley.newRequestQueue(<span class="keyword">this</span>);</span><br><span class="line">String url =<span class="string">"http://www.google.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Request a string response from the provided URL.</span></span><br><span class="line">StringRequest stringRequest = <span class="keyword">new</span> StringRequest(Request.Method.GET, url,</span><br><span class="line">            <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Display the first 500 characters of the response string.</span></span><br><span class="line">        mTextView.setText(<span class="string">"Response is: "</span>+ response.substring(<span class="number">0</span>,<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">        mTextView.setText(<span class="string">"That didn't work!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the request to the RequestQueue.</span></span><br><span class="line">queue.add(stringRequest);</span><br></pre></td></tr></table></figure><p>使用相对简单，回调直接在主线程，我们取消某个请求直接这样操作：</p><ol><li><p>定义一个标记添加到requests中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyTag"</span>;</span><br><span class="line">StringRequest stringRequest; <span class="comment">// Assume this exists.</span></span><br><span class="line">RequestQueue mRequestQueue;  <span class="comment">// Assume this exists.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the tag on the request.</span></span><br><span class="line">stringRequest.setTag(TAG);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the request to the RequestQueue.</span></span><br><span class="line">mRequestQueue.add(stringRequest);</span><br></pre></td></tr></table></figure></li><li><p>然后我们可以在 onStop() 中取消所有标记的请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    <span class="keyword">if</span> (mRequestQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRequestQueue.cancelAll(TAG);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h4><p>我们先从Volley这个类入手：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, BaseHttpStack stack)</span> </span>&#123;</span><br><span class="line">    BasicNetwork network;</span><br><span class="line">    <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">            network = <span class="keyword">new</span> BasicNetwork(<span class="keyword">new</span> HurlStack());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String userAgent = <span class="string">"volley/0"</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String packageName = context.getPackageName();</span><br><span class="line">                PackageInfo info =</span><br><span class="line">                    context.getPackageManager().getPackageInfo(packageName, <span class="comment">/* flags= */</span> <span class="number">0</span>);</span><br><span class="line">                userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            network =</span><br><span class="line">                <span class="keyword">new</span> BasicNetwork(</span><br><span class="line">                <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRequestQueue(context, network);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, Network network)</span> </span>&#123;</span><br><span class="line">    File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">    RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</span><br><span class="line">    queue.start();</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newRequestQueue(context, (BaseHttpStack) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们传递一个 <code>Context</code> 的时候，首先为 <code>BaseHttpStack</code> 为 <code>null</code>，会执行到创建 <code>BaseHttpStack</code>，<code>BaseHttpStack</code> 是一个网络具体的处理请求，<code>Volley</code> 默认提供了基于 <code>HttpURLCollection</code> 的 <code>HurlStack</code> 和基于<code>HttpClient</code> 的 <code>HttpClientStack</code>。Android6.0 移除了 <code>HttpClient</code>，<code>Google</code> 官方推荐使用<code>HttpURLCollection</code> 类作为替换。所以这里在API大于9的版本是用的是 <code>HurlStack</code>,为什么这样选择，详情可见这篇博客<a href="https://blog.csdn.net/guolin_blog/article/details/12452307" target="_blank" rel="noopener">Android访问网络，使用HttpURLConnection还是HttpClient？</a>。我们使用的是默认的构造，<code>BaseHttpStack</code> 传入为 <code>null</code>，如果我们想使用自定义的 <code>okhttp</code> 替换底层，我们直接继承 <code>HttpStack</code> 重写即可，也可以自定义 <code>Network</code> 和 <code>RequestQueue</code>,<code>Volley</code> 的高扩展性充分体现。接下来则创建一个 <code>Network</code> 对象，然后实例化 <code>RequestQueue</code>,首先创建了一个用于缓存的文件夹，然后创建了一个磁盘缓存，将文件缓存到指定目录的硬盘上，默认大小是5M，但是大小可以配置。接下来调用 <code>RequestQueue</code> 的 <code>start()</code>方法进行启动，我们进入这个方法查看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stop(); </span><br><span class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher =</span><br><span class="line">            <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始启动的时候先停止所有的请求线程和网络缓存线程，然后实例化一个缓存线程并运行，然后一个循环开启<code>DEFAULT_NETWORK_THREAD_POOL_SIZE</code>（4）个网络请求线程并运行，一共就是5个线程在后台运行，不断的等待网络请求的到来。</p><p>构造了 <code>RequestQueue</code> 之后，我们调用 <code>add()</code> 方法将相应的 <code>Request</code> 传入就开始执行网络请求了，我们看看这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将请求队列和请求关联起来</span></span><br><span class="line">    request.setRequestQueue(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//添加到正在请求中但是还未完成的集合中</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">        mCurrentRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置请求的一个序列号，通过原子变量的incrementAndGet方法，</span></span><br><span class="line">    <span class="comment">//以原子方式给当前值加1并获取新值实现请求的优先级</span></span><br><span class="line">    request.setSequence(getSequenceNumber());</span><br><span class="line">    <span class="comment">//添加一个调试信息</span></span><br><span class="line">    request.addMarker(<span class="string">"add-to-queue"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不需要缓存则直接加到网络的请求队列，默认每一个请求都是缓存的，</span></span><br><span class="line">    <span class="comment">//如果不需要缓存需要调用Request的setShouldCache方法来修改</span></span><br><span class="line">    <span class="keyword">if</span> (!request.shouldCache()) &#123;</span><br><span class="line">        mNetworkQueue.add(request);</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加到缓存的请求队列</span></span><br><span class="line">    mCacheQueue.add(request);</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键地方都写了注释，主要作用就是将请求加到请求队列，执行网络请求或者从缓存中获取结果。网络和缓存的请求都是一个优先级阻塞队列，按照优先级出队。上面几个关键步骤，添加到请求集合里面还有设置优先级以及添加到缓存和请求队列都是线程安全的，要么加锁，要么使用线程安全的队列或者原子操作。</p><p>接下来我们看看添加到 <code>CacheDispatcher</code> 缓存请求队列的 <code>run</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//初始化DiskBasedCache的缓存类</span></span><br><span class="line">    mCache.initialize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processRequest();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            VolleyLog.e(</span><br><span class="line">                <span class="string">"Ignoring spurious interrupt of CacheDispatcher thread; "</span></span><br><span class="line">                + <span class="string">"use quit() to terminate it"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的重点是看看 <code>processRequest()</code> 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//从缓存队列取出请求</span></span><br><span class="line">    <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</span><br><span class="line">    processRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">final</span> Request&lt;?&gt; request)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    request.addMarker(<span class="string">"cache-queue-take"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求被取消，我们可以通过RequestQueue的回调接口来监听</span></span><br><span class="line">    <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">        request.finish(<span class="string">"cache-discard-canceled"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存中获取Cache.Entry</span></span><br><span class="line">    Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">    <span class="comment">//没有取到缓存</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.addMarker(<span class="string">"cache-miss"</span>);</span><br><span class="line">        <span class="comment">// 缓存未命中，对于可缓存的请求先去检查是否有相同的请求是否已经在运行中，</span></span><br><span class="line">        <span class="comment">//如果有的话先加入请求等待队列，等待请求完成，返回true；如果返回false则表示第一次请求</span></span><br><span class="line">        <span class="keyword">if</span> (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">            <span class="comment">//加入到网络请求的阻塞队列</span></span><br><span class="line">            mNetworkQueue.put(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存完全过期，处理过程跟上面类似</span></span><br><span class="line">    <span class="keyword">if</span> (entry.isExpired()) &#123;</span><br><span class="line">        request.addMarker(<span class="string">"cache-hit-expired"</span>);</span><br><span class="line">        <span class="comment">//设置请求缓存的entry到这个request中</span></span><br><span class="line">        request.setCacheEntry(entry);</span><br><span class="line">        <span class="keyword">if</span> (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">            mNetworkQueue.put(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存命中，将数据解析并返回到request的抽象方法中</span></span><br><span class="line">    request.addMarker(<span class="string">"cache-hit"</span>);</span><br><span class="line">    Response&lt;?&gt; response =</span><br><span class="line">        request.parseNetworkResponse(</span><br><span class="line">        <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">    request.addMarker(<span class="string">"cache-hit-parsed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断请求结果是否需要刷新</span></span><br><span class="line">    <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</span><br><span class="line">        <span class="comment">// 未过期的缓存命中，通过ExecutorDelivery回调给我们的request子类的接口中，</span></span><br><span class="line">        <span class="comment">// 我们在使用的时候就可以通过StringRequest、JsonRequest等拿到结果，</span></span><br><span class="line">        <span class="comment">// 切换到主线程也是在这个类里执行的</span></span><br><span class="line">        mDelivery.postResponse(request, response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</span><br><span class="line">        request.setCacheEntry(entry);</span><br><span class="line">        <span class="comment">// 将这个响应标记为中间值，即这个响应是新鲜的，那么第二个响应正在请求随时到来</span></span><br><span class="line">        response.intermediate = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">            <span class="comment">//发起网络请求，这里为什么直接调用上面的mNetworkQueue.put(request);呢，</span></span><br><span class="line">            <span class="comment">//主要是为了添加一个已经分发的标记，在响应分发的时候不再回调给用户，</span></span><br><span class="line">            <span class="comment">//不然就回调了两次</span></span><br><span class="line">            mDelivery.postResponse(</span><br><span class="line">                request,</span><br><span class="line">                response,</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            mNetworkQueue.put(request);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="comment">// Restore the interrupted status</span></span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//这里第三个参数传递null，不用再去分发，因为已经有相同的请求已经在执行，</span></span><br><span class="line">            <span class="comment">//直接添加到了等待请求的列表中，然后返回的时候从已经执行的请求收到响应</span></span><br><span class="line">            mDelivery.postResponse(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分主要是对请求的缓存判断，是否过期以及需要刷新缓存。我们调用取消所有请求或者取消某个请求实质上就是对 <code>mCanceled</code> 这个变量赋值，然后在缓存线程或者网络线程里面都回去判断这个值，就完成了取消。上面的 <code>isExpired</code> 和 <code>refreshNeeded</code>，两个区别就是，前者如果过期就直接请求最新的内容，后者就是还在新鲜的时间内，但是把内容返回给用户还是会发起请求，两者一个与 <code>ttl</code> 值相比，另一个与 <code>softTtl</code> 相比。</p><p>其中有一个 <code>WaitingRequestManager</code>，如果有相同的请求那么就需要一个暂存的地方，这个类就是做的这个操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitingRequestManager</span> <span class="keyword">implements</span> <span class="title">Request</span>.<span class="title">NetworkRequestCompleteListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有等待请求的集合，键是缓存的key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CacheDispatcher mCacheDispatcher;</span><br><span class="line"></span><br><span class="line">    WaitingRequestManager(CacheDispatcher cacheDispatcher) &#123;</span><br><span class="line">        mCacheDispatcher = cacheDispatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求接受到一个有效的响应，后面等待的相同请求就可以使用这个响应</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponseReceived</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果缓存为空或者已经过期，那么就释放等待的请求</span></span><br><span class="line">        <span class="keyword">if</span> (response.cacheEntry == <span class="keyword">null</span> || response.cacheEntry.isExpired()) &#123;</span><br><span class="line">            onNoUsableResponseReceived(request);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String cacheKey = request.getCacheKey();</span><br><span class="line">        <span class="comment">//等待的请求的集合</span></span><br><span class="line">        List&lt;Request&lt;?&gt;&gt; waitingRequests;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//从map里面移除这个请求的集合</span></span><br><span class="line">            waitingRequests = mWaitingRequests.remove(cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (waitingRequests != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                VolleyLog.v(</span><br><span class="line">                    <span class="string">"Releasing %d waiting requests for cacheKey=%s."</span>,</span><br><span class="line">                    waitingRequests.size(), cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 里面所有的请求都分发到相应的回调执行，下面会讲解</span></span><br><span class="line">            <span class="keyword">for</span> (Request&lt;?&gt; waiting : waitingRequests) &#123;</span><br><span class="line">                mCacheDispatcher.mDelivery.postResponse(waiting, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有收到相应，则需要释放请求</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onNoUsableResponseReceived</span><span class="params">(Request&lt;?&gt; request)</span> </span>&#123;</span><br><span class="line">        String cacheKey = request.getCacheKey();</span><br><span class="line">        List&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (waitingRequests != <span class="keyword">null</span> &amp;&amp; !waitingRequests.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                VolleyLog.v(</span><br><span class="line">                    <span class="string">"%d waiting requests for cacheKey=%s; resend to network"</span>,</span><br><span class="line">                    waitingRequests.size(), cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下面这个请求执会重新执行，将这个移除添加到</span></span><br><span class="line">            Request&lt;?&gt; nextInLine = waitingRequests.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//将剩下的请求放到等待请求的map中</span></span><br><span class="line">            mWaitingRequests.put(cacheKey, waitingRequests);</span><br><span class="line">            <span class="comment">//在request里面注册一个回调接口，因为重新开始请求，需要重新注册一个监听，</span></span><br><span class="line">            <span class="comment">//后面请求成功失败以及取消都可以收到回调</span></span><br><span class="line">            nextInLine.setNetworkRequestCompleteListener(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//从上面if判断方法可以得出：waitingRequests != null &amp;&amp; !waitingRequests.isEmpty()</span></span><br><span class="line">                <span class="comment">//排除了第一次请求失败、取消的情况，后面的那个条件则表示这个等待请求队列必须要有一个请求，</span></span><br><span class="line">                <span class="comment">//同时满足才会执行这里面的代码，一般只要这里面的请求执行成功一次后续所有的请求都会被移除，</span></span><br><span class="line">                <span class="comment">//所以这里对多个请求的情况，失败一次，那么后续的请求会继续执行</span></span><br><span class="line">                mCacheDispatcher.mNetworkQueue.put(nextInLine);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException iex) &#123;</span><br><span class="line">                VolleyLog.e(<span class="string">"Couldn't add request to queue. %s"</span>, iex.toString());</span><br><span class="line">                <span class="comment">// Restore the interrupted status of the calling thread (i.e. NetworkDispatcher)</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="comment">// Quit the current CacheDispatcher thread.</span></span><br><span class="line">                mCacheDispatcher.quit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//对于可以缓存的请求，相同缓存的请求已经在运行中就添加到一个发送队列，</span></span><br><span class="line"> <span class="comment">//等待运行中的队列请求完成，返回true表示已经有请求在运行，false则是第一次执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">maybeAddToWaitingRequests</span><span class="params">(Request&lt;?&gt; request)</span> </span>&#123;</span><br><span class="line">        String cacheKey = request.getCacheKey();</span><br><span class="line">        <span class="comment">// 存在相同的请求则把请求加入到相同缓存键的集合中</span></span><br><span class="line">        <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class="line">            <span class="comment">// There is already a request in flight. Queue up.</span></span><br><span class="line">            List&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class="line">            <span class="comment">//如果包含相同的请求但是有可能是第二次请求，前面第一次请求插入null了</span></span><br><span class="line">            <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</span><br><span class="line">                stagedRequests = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            request.addMarker(<span class="string">"waiting-for-response"</span>);</span><br><span class="line">            stagedRequests.add(request);</span><br><span class="line">            mWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                VolleyLog.d(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//第一次请求那么则插入一个null，表示当前有一个请求正在运行</span></span><br><span class="line">            mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//注册一个接口监听</span></span><br><span class="line">            request.setNetworkRequestCompleteListener(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                VolleyLog.d(<span class="string">"new request, sending to network %s"</span>, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类主要是避免相同的请求多次请求，而且在 <code>NetworkDispatcher</code> 里面也会通过这个接口回调相应的值在这里执行，最终比如在网络请求返回304、请求取消或者异常那么都会在这里来处理，如果收到响应则会把值回调给用户，后面的请求也不会再去请求，如果无效的响应则会做一些释放等待的请求操作，请求完成也会将后面相同的请求回调给用户，三个方法都在不同的地方发挥作用。</p><p>我们接下来看看 <code>NetworkDispatcher</code> 网络请求队列的 <code>run</code> 方法中的 <code>processRequest</code> 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request&lt;?&gt; request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimeMs = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        request.addMarker(<span class="string">"network-queue-take"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求被取消了，就不执行网络请求,</span></span><br><span class="line">        <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">            request.finish(<span class="string">"network-discard-cancelled"</span>);</span><br><span class="line">            request.notifyListenerResponseNotUsable();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addTrafficStatsTag(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里就是执行网络请求的地方</span></span><br><span class="line">        NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">        request.addMarker(<span class="string">"network-http-complete"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果服务器返回304响应，即没有修改过，</span></span><br><span class="line">        <span class="comment">//缓存依然是有效的并且是在需要刷新的有效期内，那么则不需要解析响应</span></span><br><span class="line">        <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">            request.finish(<span class="string">"not-modified"</span>);</span><br><span class="line">            <span class="comment">//没有收到来自网络的有效响应，释放请求</span></span><br><span class="line">            request.notifyListenerResponseNotUsable();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在工作线程中解析这些响应</span></span><br><span class="line">        Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">        request.addMarker(<span class="string">"network-parse-complete"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将缓存写入到应用</span></span><br><span class="line">        <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">            request.addMarker(<span class="string">"network-cache-written"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记此请求已将分发</span></span><br><span class="line">        request.markDelivered();</span><br><span class="line">        <span class="comment">//将请求的响应回调给用户</span></span><br><span class="line">        mDelivery.postResponse(request, response);</span><br><span class="line">        <span class="comment">//请求接受到了一个响应，其他相同的请求可以使用这个响应</span></span><br><span class="line">        request.notifyListenerResponseReceived(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里才是网络请求的真正执行以及解析分发的地方，重点看两个地方的代码，执行和解析，我们先看看执行网络请求这个代码，执行的地方是 <code>BasicNetwork.performRequest</code>，下面看看这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        HttpResponse httpResponse = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;Header&gt; responseHeaders = Collections.emptyList();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 构造缓存的头部，添加If-None-Match和If-Modified-Since，都是http/1.1中控制协商缓存的两个字段，     </span></span><br><span class="line">            <span class="comment">// If-None-Match：客服端再次发起请求时，携带上次请求返回的唯一标识Etag值，</span></span><br><span class="line">            <span class="comment">//服务端用携带的值和最后修改的值作对比，最后修改时间大于携带的字段值则返回200，否则304；</span></span><br><span class="line">            <span class="comment">// If-Modified-Since：客服端再次发起请求时，携带上次请求返回的Last-Modified值，</span></span><br><span class="line">            <span class="comment">//服务端用携带的值和服务器的Etag值作对比，一致则返回304</span></span><br><span class="line">            Map&lt;String, String&gt; additionalRequestHeaders =</span><br><span class="line">                getCacheHeaders(request.getCacheEntry());</span><br><span class="line">            <span class="comment">//因为现在一般的sdk都是大于9的，那么这里执行的就是HurlStack的executeRequest方法，</span></span><br><span class="line">            <span class="comment">//执行网络请求，和我们平时使用HttpURLConnection请求网络大致相同</span></span><br><span class="line">            httpResponse = mBaseHttpStack.executeRequest(request, additionalRequestHeaders);</span><br><span class="line">            <span class="keyword">int</span> statusCode = httpResponse.getStatusCode();</span><br><span class="line"></span><br><span class="line">            responseHeaders = httpResponse.getHeaders();</span><br><span class="line">            <span class="comment">// 服务端返回304时，那么就表示资源无更新，可以继续使用缓存的值</span></span><br><span class="line">            <span class="keyword">if</span> (statusCode == HttpURLConnection.HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">                Entry entry = request.getCacheEntry();</span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(</span><br><span class="line">                        HttpURLConnection.HTTP_NOT_MODIFIED,</span><br><span class="line">                        <span class="comment">/* data= */</span> <span class="keyword">null</span>,</span><br><span class="line">                        <span class="comment">/* notModified= */</span> <span class="keyword">true</span>,</span><br><span class="line">                        SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                        responseHeaders);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将缓存头和响应头组合在一起，一次响应就完成了</span></span><br><span class="line">                List&lt;Header&gt; combinedHeaders = combineHeaders(responseHeaders, entry);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(</span><br><span class="line">                    HttpURLConnection.HTTP_NOT_MODIFIED,</span><br><span class="line">                    entry.data,</span><br><span class="line">                    <span class="comment">/* notModified= */</span> <span class="keyword">true</span>,</span><br><span class="line">                    SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                    combinedHeaders);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果返回204，执行成功，没有数据，这里需要检查</span></span><br><span class="line">            InputStream inputStream = httpResponse.getContent();</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                responseContents =</span><br><span class="line">                    inputStreamToBytes(inputStream, httpResponse.getContentLength());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//返回204，就返回一个空的byte数组</span></span><br><span class="line">                responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if the request is slow, log it.</span></span><br><span class="line">            <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">            logSlowRequests(requestLifetime, request, responseContents, statusCode);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(</span><br><span class="line">                statusCode,</span><br><span class="line">                responseContents,</span><br><span class="line">                <span class="comment">/* notModified= */</span> <span class="keyword">false</span>,</span><br><span class="line">                SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                responseHeaders);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">            <span class="comment">//异常进行重新请求等...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要执行了添加缓存头并发起网络请求，然后将返回值组装成一个 <code>NetworkResponse</code> 值返回，接下来我们看看是如何解析这个值的，解析是由 <code>Request</code> 的子类去实现的，我们就看系统提供的 <code>StringRequest</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"DefaultCharset"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Response&lt;String&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">    String parsed;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsed = <span class="keyword">new</span> String(response.data, HttpHeaderParser.parseCharset(response.headers));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// Since minSdkVersion = 8, we can't call</span></span><br><span class="line">        <span class="comment">// new String(response.data, Charset.defaultCharset())</span></span><br><span class="line">        <span class="comment">// So suppress the warning instead.</span></span><br><span class="line">        parsed = <span class="keyword">new</span> String(response.data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到将值组装成一个String，然后组装成一个 <code>Response</code> 返回，接下来看看这里如何将这个值回调给用户的这个方法<code>mDelivery.postResponse(request, response)</code>，这里我们先重点看看这个类 <code>ExecutorDelivery</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorDelivery</span> <span class="keyword">implements</span> <span class="title">ResponseDelivery</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造执行已提交的Runnable任务对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor mResponsePoster;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//这里在RequestQueue构造参数中初始化，new ExecutorDelivery(new Handler(Looper.getMainLooper()))，</span></span><br><span class="line">   <span class="comment">//那么这里runnable就通过绑定主线程的Looper的Handler对象投递到主线程中执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make an Executor that just wraps the handler.</span></span><br><span class="line">        mResponsePoster =</span><br><span class="line">                <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">                        handler.post(command);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        mResponsePoster = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法就是我们NetworkDispatcher里面调用的方法，调用下面这个三个参数的构造方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123;</span><br><span class="line">        postResponse(request, response, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">        request.markDelivered();</span><br><span class="line">        request.addMarker(<span class="string">"post-response"</span>);</span><br><span class="line">        <span class="comment">//构造了一个ResponseDeliveryRunnable类，传入execute，现在这个runnable就是在主线程里执行</span></span><br><span class="line">        mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span> </span>&#123;</span><br><span class="line">        request.addMarker(<span class="string">"post-error"</span>);</span><br><span class="line">        Response&lt;?&gt; response = Response.error(error);</span><br><span class="line">        mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A Runnable used for delivering network responses to a listener on the main thread. */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDeliveryRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Request mRequest;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Response mResponse;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Runnable mRunnable;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ResponseDeliveryRunnable</span><span class="params">(Request request, Response response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">            mRequest = request;</span><br><span class="line">            mResponse = response;</span><br><span class="line">            mRunnable = runnable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//请求取消，那么就不分发给用户</span></span><br><span class="line">            <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</span><br><span class="line">                mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据isSuccess这个值来提供相应的回调给用户，调用Response会通过error的值是否为null来确定这个值，</span></span><br><span class="line">            <span class="comment">//我们调用VolleyError这个构造函数的时候就为这个值就为false</span></span><br><span class="line">            <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">                mRequest.deliverResponse(mResponse.result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mRequest.deliverError(mResponse.error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果这是一个在新鲜的时间内的请求的响应，就添加一个标记，否则就结束</span></span><br><span class="line">            <span class="keyword">if</span> (mResponse.intermediate) &#123;</span><br><span class="line">                mRequest.addMarker(<span class="string">"intermediate-response"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mRequest.finish(<span class="string">"done"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在CacheDispatcher里面当请求第一次请求时直接调用三个参数的构造方法，通过这个runnable就执行run方法</span></span><br><span class="line">            <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mRunnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法主要是将值回调给用户，那么整个网络请求大致就完成了，其中还涉及很多细节的东西，但是大致流程是走通了，不得不说这个库有很多值得我们学习的地方。</p><h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>现在我们看官网的一张图，总结一下整个流程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/.io//volley.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>蓝色是主线程</li><li>绿色是缓存线程</li><li>黄色是网络线程  </li></ul><p>我们可以看到首先是请求添加到 <code>RequestQueue</code> 里，首先是添加到缓存队列，然后查看是否已经缓存，如果有并且在有效期内的缓存直接回调给用户，如果没有查找到，那么则需要添加到网络请求队列重新请求并且解析响应、写入缓存在发送到主线程给用户回调。</p><h4 id="参考以及相关链接"><a href="#参考以及相关链接" class="headerlink" title="参考以及相关链接"></a>参考以及相关链接</h4><ul><li><a href="https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA" target="_blank" rel="noopener">【第1250期】彻底理解浏览器的缓存机制</a></li><li><a href="https://blog.csdn.net/guolin_blog/article/details/17656437" target="_blank" rel="noopener">Android Volley完全解析(四)，带你从源码的角度理解Volley</a></li><li><a href="https://github.com/wangzhengyi/Volley" target="_blank" rel="noopener">Volley 源码解析</a></li><li><a href="http://codekk.com/open-source-project-analysis/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="noopener">Volley 源码解析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;code&gt;Volley&lt;/code&gt;源码分析三部曲&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://juejin.im/post/5c1c58b35188251f1f320e70&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;V
      
    
    </summary>
    
      <category term="源码解析" scheme="https://wvisible.github.io/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Volley" scheme="https://wvisible.github.io/tags/Volley/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 Lambda 指南</title>
    <link href="https://wvisible.github.io/2018/10/07/Java-8-Lambda-%E6%8C%87%E5%8D%97/"/>
    <id>https://wvisible.github.io/2018/10/07/Java-8-Lambda-指南/</id>
    <published>2018-10-07T09:31:03.000Z</published>
    <updated>2020-03-06T08:53:35.417Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>2014年3月，Java 8发布，Lambda表达式作为一个重要的特性。不过在 Android 中最先使用 Retrolambda 插件来使用 Lambda 表达式，随着 Android Studio 的更新，在3.0版本之后通过配置就可以使用 Java8 的所有特性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;2014年3月，Java 8发布，Lambda表达式作为一个重要的特性。不过在 Android 中最先使用 Retrolam
      
    
    </summary>
    
      <category term="Java8" scheme="https://wvisible.github.io/categories/Java8/"/>
    
    
      <category term="Java8 Lambda" scheme="https://wvisible.github.io/tags/Java8-Lambda/"/>
    
      <category term="Lambda 原理" scheme="https://wvisible.github.io/tags/Lambda-%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
