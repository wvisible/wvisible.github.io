<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>哆啦A梦Doraemon</title>
  
  <subtitle>So we beat on, boats against the current, borne back ceaselessly into the past.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wvisible.github.io/"/>
  <updated>2020-03-06T08:08:08.623Z</updated>
  <id>https://wvisible.github.io/</id>
  
  <author>
    <name>哆啦A梦Doraemon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Volley 源码解析之缓存机制</title>
    <link href="https://wvisible.github.io/2020/03/05/Volley-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://wvisible.github.io/2020/03/05/Volley-源码解析之缓存机制/</id>
    <published>2020-03-05T15:45:42.000Z</published>
    <updated>2020-03-06T08:08:08.623Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>前面我们分析了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 二、 源码分析</span><br><span class="line">我们首先看看```Cache```这个缓存接口：</span><br></pre></td></tr></table></figure></p><p>public interface Cache {<br>    //通过key获取指定请求的缓存实体<br>    Entry get(String key);</p><pre><code>//存入指定的缓存实体void put(String key, Entry entry);//初始化缓存void initialize();//使缓存中的指定请求实体过期void invalidate(String key, boolean fullExpire);//移除指定的请求缓存实体void remove(String key);//清空缓存void clear();class Entry {    //请求返回的数据    public byte[] data;    //用于缓存验证的http请求头Etag    public String etag;    //Http 请求响应产生的时间    public long serverDate;    //最后修改时间    public long lastModified;    //过期时间    public long ttl;    //新鲜度时间    public long softTtl;    public Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();    public List&lt;Header&gt; allResponseHeaders;    //返回true则过期    public boolean isExpired() {        return this.ttl &lt; System.currentTimeMillis();    }    //需要从原始数据源刷新，则为true    public boolean refreshNeeded() {        return this.softTtl &lt; System.currentTimeMillis();    }}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存储的实体就是响应，以字节数组作为数据的请求URL为键的缓存接口。  </span><br><span class="line">接下来我们看看```HttpHeaderParser```中用于解析```http```头的方法：</span><br></pre></td></tr></table></figure><p>public static Cache.Entry parseCacheHeaders(NetworkResponse response) {<br>        long now = System.currentTimeMillis();</p><pre><code>    Map&lt;String, String&gt; headers = response.headers;    long serverDate = 0;    long lastModified = 0;    long serverExpires = 0;    long softExpire = 0;    long finalExpire = 0;    long maxAge = 0;    long staleWhileRevalidate = 0;    boolean hasCacheControl = false;    boolean mustRevalidate = false;    String serverEtag = null;    String headerValue;    //表示收到响应的时间    headerValue = headers.get(&quot;Date&quot;);    if (headerValue != null) {        serverDate = parseDateAsEpoch(headerValue);    }    //Cache-Control用于定义资源的缓存策略，在HTTP/1.1中，Cache-Control是    最重要的规则，取代了 Expires    headerValue = headers.get(&quot;Cache-Control&quot;);    if (headerValue != null) {        hasCacheControl = true;        String[] tokens = headerValue.split(&quot;,&quot;, 0);        for (int i = 0; i &lt; tokens.length; i++) {            String token = tokens[i].trim();            //no-cache：客户端缓存内容，每次都要向服务器重新验证资源是否            被更改，但是是否使用缓存则需要经过协商缓存来验证决定，            no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存            这两种情况不缓存返回null            if (token.equals(&quot;no-cache&quot;) || token.equals(&quot;no-store&quot;)) {                return null;            //max-age：设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)            } else if (token.startsWith(&quot;max-age=&quot;)) {                try {                    maxAge = Long.parseLong(token.substring(8));                } catch (Exception e) {                }            //stale-while-revalidate：表明客户端愿意接受陈旧的响应，同时            在后台异步检查新的响应。秒值指示客户愿意接受陈旧响应的时间长度            } else if (token.startsWith(&quot;stale-while-revalidate=&quot;)) {                try {                    staleWhileRevalidate = Long.parseLong(token.substring(23));                } catch (Exception e) {                }            //must-revalidate：缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。            并不是说「每次都要验证」，它意味着某个资源在本地已缓存时长短于 max-age 指定时            长时，可以直接使用，否则就要发起验证            proxy-revalidate：与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。            } else if (token.equals(&quot;must-revalidate&quot;) || token.equals(&quot;proxy-revalidate&quot;)) {                mustRevalidate = true;            }        }    }    //Expires 是 HTTP/1.0的控制手段，其值为服务器返回该请求结果    缓存的到期时间    headerValue = headers.get(&quot;Expires&quot;);    if (headerValue != null) {        serverExpires = parseDateAsEpoch(headerValue);    }    // Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间    headerValue = headers.get(&quot;Last-Modified&quot;);    if (headerValue != null) {        lastModified = parseDateAsEpoch(headerValue);    }    //Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)    serverEtag = headers.get(&quot;ETag&quot;);    // Cache-Control 优先 Expires 字段,请求头包含 Cache-Control，计算缓存的ttl和softTtl    if (hasCacheControl) {        //新鲜度时间只跟maxAge有关        softExpire = now + maxAge * 1000;        // 最终过期时间分两种情况：如果mustRevalidate为true，即需要验证新鲜度，        那么直接跟新鲜度时间一样的，另一种情况是新鲜度时间 + 陈旧的响应时间 * 1000        finalExpire = mustRevalidate ? softExpire : softExpire + staleWhileRevalidate * 1000;    // 如果不包含Cache-Control头    } else if (serverDate &gt; 0 &amp;&amp; serverExpires &gt;= serverDate) {        // 缓存失效时间的计算        softExpire = now + (serverExpires - serverDate);        // 最终过期时间跟新鲜度时间一致        finalExpire = softExpire;    }    Cache.Entry entry = new Cache.Entry();    entry.data = response.data;    entry.etag = serverEtag;    entry.softTtl = softExpire;    entry.ttl = finalExpire;    entry.serverDate = serverDate;    entry.lastModified = lastModified;    entry.responseHeaders = headers;    entry.allResponseHeaders = response.allHeaders;    return entry;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这里主要是对请求头的缓存字段进行解析，并对缓存的相关字段赋值，特别是过期时间的计算要考虑到不同缓存头部的区别，以及每个缓存请求头的含义；  </span><br><span class="line">上面讲到的```stale-while-revalidate```这个字段举个例子：</span><br><span class="line">&gt;Cache-Control: max-age=600, stale-while-revalidate=30  </span><br><span class="line"></span><br><span class="line">这个响应表明当前响应内容新鲜时间为 600 秒，以及额外的 30 秒可以用来容忍过期缓存，服务器会将 max-age 和 stale-while-revalidate 的时间加在一起作为潜在最长可容忍的新鲜度时间，所有的响应都由缓存提供;不过在容忍过期缓存时间内,先直接从缓存中获取响应返回给调用者，然后在静默的在后台向原始服务器发起一次异步请求,然后在后台静默的更新缓存内容。</span><br><span class="line"></span><br><span class="line">这部分代码都是关于HTTP缓存的相关知识，我下面给出一些我参考引用的链接，大家可以去学习相关知识。  </span><br><span class="line"></span><br><span class="line">我们接下来继续看缓存的实现类```DiskBasedCache```，将缓存文件直接缓存到指定目录下的硬盘上，我们首先看看构造方法：</span><br></pre></td></tr></table></figure><p>public DiskBasedCache(File rootDirectory, int maxCacheSizeInBytes) {<br>        mRootDirectory = rootDirectory;<br>        mMaxCacheSizeInBytes = maxCacheSizeInBytes;<br>    }</p><p>public DiskBasedCache(File rootDirectory) {<br>    this(rootDirectory, DEFAULT_DISK_USAGE_BYTES);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">构造方法做了两件事，指定硬盘缓存的文件夹以及缓存的大小，默认5M。  </span><br><span class="line">我们首先看看初始化方法：</span><br></pre></td></tr></table></figure></p><p>public synchronized void initialize() {<br>        //如果缓存文件夹不存在则创建文件夹<br>        if (!mRootDirectory.exists()) {<br>            if (!mRootDirectory.mkdirs()) {<br>                VolleyLog.e(“Unable to create cache dir %s”, mRootDirectory.getAbsolutePath());<br>            }<br>            return;<br>        }<br>        File[] files = mRootDirectory.listFiles();<br>        if (files == null) {<br>            return;<br>        }<br>        for (File file : files) {<br>            try {<br>                long entrySize = file.length();<br>                CountingInputStream cis =<br>                        new CountingInputStream(<br>                                new BufferedInputStream(createInputStream(file)), entrySize);<br>                try {<br>                    CacheHeader entry = CacheHeader.readHeader(cis);<br>                    // 初始化的时候更新缓存大小为文件大小<br>                    entry.size = entrySize;<br>                    // 将已经存在的缓存存入到映射表中<br>                    putEntry(entry.key, entry);<br>                } finally {<br>                    // Any IOException thrown here is handled by the below catch block by design.<br>                    //noinspection ThrowFromFinallyBlock<br>                    cis.close();<br>                }<br>            } catch (IOException e) {<br>                //noinspection ResultOfMethodCallIgnored<br>                file.delete();<br>            }<br>        }<br>    }<br>//将 key 和 CacheHeader 存入到 map 对象当中，然后更新当前字节数<br>private void putEntry(String key, CacheHeader entry) {<br>    if (!mEntries.containsKey(key)) {<br>        mTotalSize += entry.size;<br>    } else {<br>        CacheHeader oldEntry = mEntries.get(key);<br>        mTotalSize += (entry.size - oldEntry.size);<br>    }<br>    mEntries.put(key, entry);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始化这里首先判断了缓存文件夹是否存在，不存在就要新建文件夹，这个很好理解。如果存在了就会将原来的已经存在的文件夹依次读取并存入一个缓存映射表中，方便后续判断有无缓存，不用直接从磁盘缓存中去查找文件名判断有无缓存。一般每个请求都会有一个```CacheHeader```，然后将存在的缓存头里的```size```重新赋值，初始化时大小为文件大小，存入数据为数据的大小。这里提一下```CacheHeader```是一个静态内部类，跟```Cache```的```Entry```有点像，少了一个```byte[] data```数组，其中维护了缓存头部的相关字段，这样设计的原因是方便快速读取，合理利用内存空间，因为缓存的相关信息需要频繁读取，内存占用小，可以缓存到内存中，但是网络请求的响应数据是非常占地方的，很容易就占满空间了，需要单独存储到硬盘中。   </span><br><span class="line">我们看下存入的方法：</span><br></pre></td></tr></table></figure></p><p>@Override<br>public synchronized void put(String key, Entry entry) {<br>    //首先进行缓存剩余空间的大小判断<br>    pruneIfNeeded(entry.data.length);<br>    File file = getFileForKey(key);<br>    try {<br>        BufferedOutputStream fos = new BufferedOutputStream(createOutputStream(file));<br>        CacheHeader e = new CacheHeader(key, entry);<br>        //CacheHeader 写入到磁盘<br>        boolean success = e.writeHeader(fos);<br>        if (!success) {<br>            fos.close();<br>            VolleyLog.d(“Failed to write header for %s”, file.getAbsolutePath());<br>            throw new IOException();<br>        }<br>        //网络请求的响应数据写入到磁盘<br>        fos.write(entry.data);<br>        fos.close();<br>        //头部信息等存储到到映射表<br>        putEntry(key, e);<br>        return;<br>    } catch (IOException e) {<br>    }<br>    boolean deleted = file.delete();<br>    if (!deleted) {<br>        VolleyLog.d(“Could not clean up file %s”, file.getAbsolutePath());<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个方法比较简单就是将响应数据以及缓存的头部信息写入到磁盘并且将头部缓存到内存中，我们看下当缓存空间不足，是怎么考虑缓存替换的：</span><br></pre></td></tr></table></figure></p><p> private void pruneIfNeeded(int neededSpace) {<br>    //缓存当前已经使用的空间总字节数 + 待存入的文件字节数是否大于缓存的最大大小，<br>    默认为5M，也可以自己指定，如果大于就要进行删除以前的缓存<br>    if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes) {<br>        return;<br>    }</p><pre><code>long before = mTotalSize;// 删除的文件数量int prunedFiles = 0;long startTime = SystemClock.elapsedRealtime();Iterator&lt;Map.Entry&lt;String, CacheHeader&gt;&gt; iterator = mEntries.entrySet().iterator();//遍历mEntries中所有的缓存while (iterator.hasNext()) {    Map.Entry&lt;String, CacheHeader&gt; entry = iterator.next();    CacheHeader e = entry.getValue();    //因为mEntries是一个访问有序的LinkedHashMap，经常访问的会被移动到末尾，    所以这里的思想就是 LRU 缓存算法    boolean deleted = getFileForKey(e.key).delete();    if (deleted) {        //删除成功过后减少当前空间的总字节数        mTotalSize -= e.size;    } else {        VolleyLog.d(                &quot;Could not delete cache entry for key=%s, filename=%s&quot;,                e.key, getFilenameForKey(e.key));    }    iterator.remove();    prunedFiles++;    //最后判断当前的空间是否满足新存入申请的空间大小，满足就跳出循环    if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) {        break;    }}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里的缓存替换策略也很好理解，如果不加以限制，那么岂不是一直写入数据到磁盘，有很多不用的数据很快就把磁盘写满了，所以使用了```LRU```缓存替换算法。 </span><br><span class="line">接下来我们看看存储的```key```，即缓存文件名生成方法：</span><br></pre></td></tr></table></figure></p><p>private String getFilenameForKey(String key) {<br>    int firstHalfLength = key.length() / 2;<br>    String localFilename = String.valueOf(key.substring(0, firstHalfLength).hashCode());<br>    localFilename += String.valueOf(key.substring(firstHalfLength).hashCode());<br>    return localFilename;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先将请求的```url```分成两部分，然后两部分分别求```hashCode```，最后拼接起来。如果我们使用```volley```来请求数据，那么通常是同一个地址中后面的不一样，很多字符一样，那么这样做可以避免```hashCode```重复造成文件名重复，创造更多的差异，因为```hash```在```Java```中不是那么可靠,关于这个问题我们可以在这篇文章中找到解答[面试后的总结](https://www.kymjs.com/code/2016/03/08/01/)   </span><br><span class="line">然后我们看下```get```方法：</span><br></pre></td></tr></table></figure></p><p>@Override<br>    public synchronized Entry get(String key) {<br>        CacheHeader entry = mEntries.get(key);<br>        // 如果entry不存在，则返回null<br>        if (entry == null) {<br>            return null;<br>        }<br>        //获取缓存的文件<br>        File file = getFileForKey(key);<br>        try {<br>            //这个类的作用是通过bytesRead记录已经读取的字节数<br>            CountingInputStream cis =<br>                    new CountingInputStream(<br>                            new BufferedInputStream(createInputStream(file)), file.length());<br>            try {<br>                //从磁盘获取缓存的CacheHeader<br>                CacheHeader entryOnDisk = CacheHeader.readHeader(cis);<br>                //如果传递进来的key和磁盘缓存中CacheHeader的key不相等，那么从内存缓存中<br>                移除这个缓存<br>                if (!TextUtils.equals(key, entryOnDisk.key)) {<br>                    removeEntry(key);<br>                    return null;<br>                }<br>                //读取缓存文件中的http响应体内容，然后创建一个entry返回<br>                byte[] data = streamToBytes(cis, cis.bytesRemaining());<br>                return entry.toCacheEntry(data);<br>            } finally {<br>                cis.close();<br>            }<br>        } catch (IOException e) {<br>            remove(key);<br>            return null;<br>        }<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">取数据首先从内存缓存中取出```CacheHeader```，如果为```null```那么直接返回，接下来如果取到了缓存，那么直接从磁盘里读取```CacheHeader```，如果存在两个```key```映射一个文件，那么就从内存缓存中移除这个缓存，最后将读取的文件组装成一个```entry```返回。这里有个疑问就是什么时候存在两个```key```映射一个文件呢？我们知道每个内存缓存中的```key```是我们请求的```url```，而磁盘缓存的文件名则是根据```key```的```hash```值计算得出，那么个人猜测有可能算出的文件名重复了，那么就会出现两个```key```对应一个文件，那么为了避免这种情况，需要先判断，出现了先从内存缓存移除，一般来说这种情况很少。   </span><br><span class="line"></span><br><span class="line">我们看看从```CountingInputStream```读取字节的方法</span><br></pre></td></tr></table></figure></p><p> static byte[] streamToBytes(CountingInputStream cis, long length) throws IOException {<br>        long maxLength = cis.bytesRemaining();<br>        // 读取的字节数不能为负数，不能大于当前剩余的字节数，还有不能整型溢出<br>        if (length &lt; 0 || length &gt; maxLength || (int) length != length) {<br>            throw new IOException(“streamToBytes length=” + length + “, maxLength=” + maxLength);<br>        }<br>        byte[] bytes = new byte[(int) length];<br>        new DataInputStream(cis).readFully(bytes);<br>        return bytes;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个方法是从```CountingInputStream```读取响应头还有响应体，怎么实现分开读取的呢，因为文件缓存首先是缓存的```CacheHeader```，接下来会从总的字节数减去已经读取的字节数，那么剩下的字节数就是响应体了。读取响应头是依次读取的，首先会先读取魔数判断是否是写入的缓存，然后依次读取各个```CacheHeader```字段，最后剩下的就是响应体了，读取和写入的顺序要一致。</span><br><span class="line"></span><br><span class="line">看一看缓存的清除方法：</span><br></pre></td></tr></table></figure></p><p>@Override<br>public synchronized void clear() {<br>    File[] files = mRootDirectory.listFiles();<br>    if (files != null) {<br>        for (File file : files) {<br>            file.delete();<br>        }<br>    }<br>    mEntries.clear();<br>    mTotalSize = 0;<br>    VolleyLog.d(“Cache cleared.”);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">遍历磁盘的每一个缓存文件并删除，清除内存缓存，更新使```size```为0。   </span><br><span class="line">接下来看看使某一个缓存```key```无效的方法</span><br></pre></td></tr></table></figure></p><p>@Override<br>public synchronized void invalidate(String key, boolean fullExpire) {<br>    Entry entry = get(key);<br>    if (entry != null) {<br>        entry.softTtl = 0;<br>        if (fullExpire) {<br>            entry.ttl = 0;<br>        }<br>        put(key, entry);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里主要对传入的```key```使缓存新鲜度无效，然后根据传入的第二个值是否为```true```，如果为```true```那么所有缓存都过期，否则只是缓存新鲜度过期，这里对```softTtl```和```ttl```值置为0，判断缓存过期的时候自然就小于当前时间返回```true```，达到了过期的目的，最后存入内存缓存和磁盘缓存当中。</span><br><span class="line"></span><br><span class="line">接下来我们看看一个特殊的类```NoCache```：</span><br></pre></td></tr></table></figure></p><p>public class NoCache implements Cache {<br>    @Override<br>    public void clear() {}</p><pre><code>@Overridepublic Entry get(String key) {    return null;}@Overridepublic void put(String key, Entry entry) {}@Overridepublic void invalidate(String key, boolean fullExpire) {}@Overridepublic void remove(String key) {}@Overridepublic void initialize() {}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实现 Cache 接口，不做任何操作的缓存实现类，可将它作为```RequestQueue```的参数实现一个默认不缓存的请求队列，后续取到的缓存都为```null```。</span><br><span class="line">#### 三、缓存的使用</span><br><span class="line">我们梳理下整个流程，看这几个方法的调用时期：</span><br></pre></td></tr></table></figure></p><p>private static RequestQueue newRequestQueue(Context context, Network network) {<br>    File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);<br>    RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);<br>    queue.start();<br>    return queue;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先这里调用了```DiskBasedCache```的构造方法，缓存默认大小是5M，缓存文件夹为```volley```。</span><br><span class="line">然后在```CacheDispatcher```的```run```方法里面实现了调用：</span><br></pre></td></tr></table></figure></p><p> @Override<br>public void run() {<br>    if (DEBUG) VolleyLog.v(“start new dispatcher”);<br>    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</p><pre><code>// Make a blocking call to initialize the cache.mCache.initialize();while (true) {    try {        processRequest();    } catch (InterruptedException e) {        // We may have been interrupted because it was time to quit.        if (mQuit) {            Thread.currentThread().interrupt();            return;        }        VolleyLog.e(                &quot;Ignoring spurious interrupt of CacheDispatcher thread; &quot;                        + &quot;use quit() to terminate it&quot;);    }}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个类前面我们分析过，发起网络请求的时候会启动五个线程，一个缓存请求线程，四个网络请求分发的线程。首先在缓存线程里执行了缓存的初始化，如果关闭了应用那么重新发起请求的时候原来的缓存会重新缓存到到内存中。</span><br><span class="line"></span><br><span class="line">然后在```CacheDispatcher```里发起请求之前首先会从磁盘缓存获取缓存的内容：</span><br></pre></td></tr></table></figure></p><p>Cache.Entry entry = mCache.get(request.getCacheKey());<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后在```NetworkDispatcher```的请求到数据并缓存到根据```url```生成的缓存键的磁盘缓存中，缓存键默认是```url```。</span><br></pre></td></tr></table></figure></p><p>if (request.shouldCache() &amp;&amp; response.cacheEntry != null) {<br>    mCache.put(request.getCacheKey(), response.cacheEntry);<br>    request.addMarker(“network-cache-written”);<br>}<br><code>`</code></p><h4 id="四、-总结"><a href="#四、-总结" class="headerlink" title="四、 总结"></a>四、 总结</h4><p><code>volley</code> 的缓存机制分析完毕了，可以看出<code>volley</code>缓存设计考虑了很多细节，对各种缓存头的解析，将请求的响应和缓存头的相关信息缓存到磁盘缓存，缓存头的信息也缓存到内存缓存，将二者很好的联系起来，便于读取和查找缓存等一系列操作。缓存命中率、缓存的替换算法、缓存文件名的计算、使用接口抽象等设计都值得我们认真学习。</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://github.com/wangzhengyi/Volley/blob/master/VOLLEY_CACHE.md" target="_blank" rel="noopener">Volley的缓存机制</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">Cache-Control</a><br><a href="https://www.zcfy.cc/article/caching-best-practices-amp-max-age-gotchas-jakearchibald-com" target="_blank" rel="noopener">缓存最佳实践及 max-age 注意事项</a><br><a href="https://xesam.github.io/computer/2017/05/08/http-cache-control-extensions-for-stale.html" target="_blank" rel="noopener">Cache-Control扩展</a><br><a href="https://www.kymjs.com/code/2016/03/08/01/" target="_blank" rel="noopener">面试后的总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h4&gt;&lt;p&gt;前面我们分析了&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
      <category term="源码解析" scheme="https://wvisible.github.io/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Volley" scheme="https://wvisible.github.io/tags/Volley/"/>
    
  </entry>
  
  <entry>
    <title>Volley 源码解析之图片请求</title>
    <link href="https://wvisible.github.io/2020/03/05/Volley-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%9B%BE%E7%89%87%E8%AF%B7%E6%B1%82/"/>
    <id>https://wvisible.github.io/2020/03/05/Volley-源码解析之图片请求/</id>
    <published>2020-03-05T15:45:28.000Z</published>
    <updated>2020-03-06T08:08:02.111Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章<a href="https://juejin.im/post/5c1c58b35188251f1f320e70" target="_blank" rel="noopener">Volley 源码解析之网络请求</a>。Volley 不仅仅对请求网络数据作了良好的封装，还封装了对图片的加载等操作，虽然比不上<figure class="highlight plain"><figcaption><span>，不过可以满足我们的日常使用，从学习者的角度看看是怎么封装的。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章[Volley 源码解析之网络请求](https://juejin.im/post/5c1c58b35188251f1f320e70)。Volley 不仅仅对请求网络数据作了良好的封装，还封装了对图片的加载等操作，虽然比不上```Glide```、```Fresco```，不过可以满足我们的日常使用，从学习者的角度看看是怎么封装的。</span><br><span class="line">#### 二、简单使用</span><br><span class="line">1. 使用```ImageRequest```加载图片，用法跟请求网络的用法差不多，只是构造request的参数不太一样：</span><br></pre></td></tr></table></figure></p><pre><code> String imageUrl = &quot;https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;; RequestQueue queue = Volley.newRequestQueue(this); ImageRequest imageRequest = new ImageRequest(imageUrl,                    response -&gt; imageView.setImageBitmap(response),                    0, 0, ImageView.ScaleType.CENTER_CROP, Bitmap.Config.ARGB_8888,                    error -&gt; {}); queue.add(imageRequest);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    - 第一个参数是图片地址没啥说的</span><br><span class="line">    - 第二个参数是成功的回调，返回一个bitmap</span><br><span class="line">    - 第三和第四个参数则是图片的最大的高度和宽度，0为默认图片大小，如果填写的图片最大的高度和宽度小于图片的实际尺寸则会进行压缩</span><br><span class="line">    - 第五个值就是对图片进行边界缩放</span><br><span class="line">    - 第六个参数是图片的格式，常用的就是```RGB_565```和```ARGB_8888```，前者每个像素占2个字节，后者每个像素占4个字节，后者成像质量高，有alpha通道，如果使用的是jpg，不需要alpha通道则可以使用前者； 还有个```ARGB_4444```，不过已经废弃了，在4.4以后默认转成```ARGB_8888```， ```ALPHA_8```只有透明度，没有颜色值，一般很少使用</span><br><span class="line">    - 最后个参数就是错误的回调</span><br><span class="line">2. 使用```ImageLoader```加载图片</span><br></pre></td></tr></table></figure></code></pre><p>   String imageUrl = “<a href="https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;" target="_blank" rel="noopener">https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;</a>;<br>   RequestQueue queue = Volley.newRequestQueue(this);<br>   ImageLoader imageLoader = new ImageLoader(queue, new BitmapCache());<br>   ImageLoader.ImageListener imageListener = ImageLoader.getImageListener(imageView,<br>        R.mipmap.ic_launcher, R.mipmap.ic_launcher_round);<br>   imageLoader.get(imageUrl,<br>        imageListener, 0, 0);<br>   private class BitmapCache implements ImageLoader.ImageCache{<br>        private LruCache&lt;String, Bitmap&gt; lruCache;</p><pre><code>public BitmapCache() {    int maxSize = 10 * 1024 * 1024;    lruCache = new LruCache&lt;String, Bitmap&gt;(maxSize) {        @Override        protected int sizeOf(String key, Bitmap bitmap) {            return bitmap.getRowBytes() * bitmap.getHeight();        }    };}@Overridepublic Bitmap getBitmap(String url) {    return lruCache.get(url);}@Overridepublic void putBitmap(String url, Bitmap bitmap) {    lruCache.put(url, bitmap);}</code></pre><p>   }<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 使用```NetworkImageView```加载图片</span><br></pre></td></tr></table></figure></p><p>   &lt;?xml version=”1.0” encoding=”utf-8”?&gt;<br>   &lt;android.support.constraint.ConstraintLayout<br>    xmlns:android=”<a href="http://schemas.android.com/apk/res/android&quot;" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android&quot;</a><br>    xmlns:tools=”<a href="http://schemas.android.com/tools&quot;" target="_blank" rel="noopener">http://schemas.android.com/tools&quot;</a><br>    xmlns:app=”<a href="http://schemas.android.com/apk/res-auto&quot;" target="_blank" rel="noopener">http://schemas.android.com/apk/res-auto&quot;</a><br>    android:layout_width=”match_parent”<br>    android:layout_height=”match_parent”<br>    tools:context=”.MainActivity”&gt;</p><pre><code>&lt;Button    android:id=&quot;@+id/button&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout_marginStart=&quot;8dp&quot;    android:layout_marginTop=&quot;88dp&quot;    android:layout_marginEnd=&quot;8dp&quot;    android:text=&quot;Button&quot;    app:layout_constraintEnd_toEndOf=&quot;parent&quot;    app:layout_constraintStart_toStartOf=&quot;parent&quot;    app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;com.android.volley.toolbox.NetworkImageView    android:id=&quot;@+id/imageView&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout_marginStart=&quot;8dp&quot;    android:layout_marginTop=&quot;32dp&quot;    android:layout_marginEnd=&quot;8dp&quot;    app:layout_constraintEnd_toEndOf=&quot;parent&quot;    app:layout_constraintStart_toStartOf=&quot;parent&quot;    app:layout_constraintTop_toBottomOf=&quot;@+id/textView&quot;    tools:srcCompat=&quot;@tools:sample/avatars&quot; /&gt;</code></pre><p>   &lt;/android.support.constraint.ConstraintLayout&gt;<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></p><pre><code>String imageUrl = &quot;https://pic1.zhimg.com/80/1a60ca062a1fe2f6d091cdd9749e9c68_hd.jpg&quot;;NetworkImageView networkImageView = findViewById(R.id.imageView);networkImageView.setDefaultImageResId(R.mipmap.ic_launcher);networkImageView.setErrorImageResId(R.mipmap.ic_launcher_round);networkImageView.setImageUrl(imageUrl, imageLoader);</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#### 三、源码分析</span><br><span class="line">##### 一、 ImageRequest 分析</span><br><span class="line">首先我们分析```ImageRequest```，直接分析这个类，代码不多，直接继承```Request```，那么不用说跟上一篇我们分析的网络请求的```request```大体相同，不同的是这个是请求图片，如果我们需要自定义大小那么这里就对图片进行了裁剪以满足我们的大小：</span><br></pre></td></tr></table></figure><p>public class ImageRequest extends Request<bitmap> {<br>    //图片请求的超时时间，单位毫秒<br>    public static final int DEFAULT_IMAGE_TIMEOUT_MS = 1000;</bitmap></p><pre><code>//图片请求的默认重试次数public static final int DEFAULT_IMAGE_MAX_RETRIES = 2;//发生冲突时的默认重传延迟增加数，和TCP协议有关系，退避算法，短时间的重复请求失败还会是失败public static final float DEFAULT_IMAGE_BACKOFF_MULT = 2f;//对mListener加锁，保证线程安全，避免取消的时候同时执行分发private final Object mLock = new Object();@GuardedBy(&quot;mLock&quot;)@Nullableprivate Response.Listener&lt;Bitmap&gt; mListener;private final Config mDecodeConfig;private final int mMaxWidth;private final int mMaxHeight;private final ScaleType mScaleType;//Bitmap 的同步解析锁，保证一个时间内只有一个Bitmap被加载到内存进行解析，避免多个同时解析oomprivate static final Object sDecodeLock = new Object();public ImageRequest(        String url,        Response.Listener&lt;Bitmap&gt; listener,        int maxWidth,        int maxHeight,        ScaleType scaleType,        Config decodeConfig,        @Nullable Response.ErrorListener errorListener) {    super(Method.GET, url, errorListener);    setRetryPolicy(            new DefaultRetryPolicy(                    DEFAULT_IMAGE_TIMEOUT_MS,                    DEFAULT_IMAGE_MAX_RETRIES,                    DEFAULT_IMAGE_BACKOFF_MULT));    mListener = listener;    mDecodeConfig = decodeConfig;    mMaxWidth = maxWidth;    mMaxHeight = maxHeight;    mScaleType = scaleType;}@Deprecatedpublic ImageRequest(        String url,        Response.Listener&lt;Bitmap&gt; listener,        int maxWidth,        int maxHeight,        Config decodeConfig,        Response.ErrorListener errorListener) {    this(            url,            listener,            maxWidth,            maxHeight,            ScaleType.CENTER_INSIDE,            decodeConfig,            errorListener);}@Overridepublic Priority getPriority() {    return Priority.LOW;}//根据ScaleType设置图片大小private static int getResizedDimension(        int maxPrimary,        int maxSecondary,        int actualPrimary,        int actualSecondary,        ScaleType scaleType) {    // 如果主要值和次要的值为0，就返回实际值，如果我们计算宽度的期望值，    那么主要值就是宽度，高度就是次要值，反之亦然    if ((maxPrimary == 0) &amp;&amp; (maxSecondary == 0)) {        return actualPrimary;    }    // 如果为ScaleType.FIT_XY，填充整个矩形，忽略比值；    即如果主要的值为0则返回实际值，否则返回传入的值    if (scaleType == ScaleType.FIT_XY) {        if (maxPrimary == 0) {            return actualPrimary;        }        return maxPrimary;    }    // 如果主要的值为0，则通过比例值计算出主要的值返回    if (maxPrimary == 0) {        double ratio = (double) maxSecondary / (double) actualSecondary;        return (int) (actualPrimary * ratio);    }    // 次要的值为0，下面的比例调整就是多余的，那么直接返回主要的值，    if (maxSecondary == 0) {        return maxPrimary;    }    // 图片真实尺寸大小的比例，通过这个比例我们可以计算出次要的最大值，通    过计算出的值和我们传递进来的值做比较    double ratio = (double) actualSecondary / (double) actualPrimary;    int resized = maxPrimary;    // 如果是ScaleType.CENTER_CROP，填充整个矩形，保持长宽比，这里的宽高值相等或者大于传入的宽高尺寸    if (scaleType == ScaleType.CENTER_CROP) {        // 小于传入的次要最大值，则返回通过比例计算的最大值，这里相当于把resized 值增大        if ((resized * ratio) &lt; maxSecondary) {            resized = (int) (maxSecondary / ratio);        }        return resized;    }    //  其它scaleType值，如果计算的值大于次要值，那么resized 值减小    if ((resized * ratio) &gt; maxSecondary) {        resized = (int) (maxSecondary / ratio);    }    return resized;}//解析response@Overrideprotected Response&lt;Bitmap&gt; parseNetworkResponse(NetworkResponse response) {    synchronized (sDecodeLock) {        try {            return doParse(response);        } catch (OutOfMemoryError e) {            VolleyLog.e(&quot;Caught OOM for %d byte image, url=%s&quot;, response.data.length, getUrl());            return Response.error(new ParseError(e));        }    }}//解析的地方private Response&lt;Bitmap&gt; doParse(NetworkResponse response) {    byte[] data = response.data;    BitmapFactory.Options decodeOptions = new BitmapFactory.Options();    Bitmap bitmap = null;    //如果最大宽度和最大高度都传入的为0，直接解析成一个bitmap    if (mMaxWidth == 0 &amp;&amp; mMaxHeight == 0) {        decodeOptions.inPreferredConfig = mDecodeConfig;        bitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);    } else {        //如果要调整图片的大小，首先获取图片真实的尺寸大小，首先设置inJustDecodeBounds为true，不加载到内存但是可以获取图像的宽高        decodeOptions.inJustDecodeBounds = true;        BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);        int actualWidth = decodeOptions.outWidth;        int actualHeight = decodeOptions.outHeight;        // 计算我们想要的尺寸        int desiredWidth =                getResizedDimension(                        mMaxWidth, mMaxHeight, actualWidth, actualHeight, mScaleType);        int desiredHeight =                getResizedDimension(                        mMaxHeight, mMaxWidth, actualHeight, actualWidth, mScaleType);        // 计算出采样值，2的倍数        decodeOptions.inJustDecodeBounds = false;        decodeOptions.inSampleSize =                findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight);        Bitmap tempBitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);        // 如果采样率计算出的值为1的话，那么就没有尺寸压缩，tempBitmap的宽高值就是图片的        真实值，那么这里就需要缩放到满足我们上面计算出来的值        if (tempBitmap != null                &amp;&amp; (tempBitmap.getWidth() &gt; desiredWidth                        || tempBitmap.getHeight() &gt; desiredHeight)) {            bitmap = Bitmap.createScaledBitmap(tempBitmap, desiredWidth, desiredHeight, true);            tempBitmap.recycle();        } else {            bitmap = tempBitmap;        }    }    //回调给用户    if (bitmap == null) {        return Response.error(new ParseError(response));    } else {        return Response.success(bitmap, HttpHeaderParser.parseCacheHeaders(response));    }}@Overridepublic void cancel() {    super.cancel();    synchronized (mLock) {        mListener = null;    }}@Overrideprotected void deliverResponse(Bitmap response) {    Response.Listener&lt;Bitmap&gt; listener;    synchronized (mLock) {        listener = mListener;    }    if (listener != null) {        listener.onResponse(response);    }}//计算合适的采样率@VisibleForTestingstatic int findBestSampleSize(        int actualWidth, int actualHeight, int desiredWidth, int desiredHeight) {    double wr = (double) actualWidth / desiredWidth;    double hr = (double) actualHeight / desiredHeight;    double ratio = Math.min(wr, hr);    float n = 1.0f;    while ((n * 2) &lt;= ratio) {        n *= 2;    }    return (int) n;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关键部分我都写了注释，下面我们看主要流程，对 ```Bitmap```的高效加载。首先我们获取到返回的```response```进行解析，然后根据传递的期望宽高以及图片格式生成```Bitmap```返回，对于我们传入的宽高会按比例裁剪，不是直接使用裁剪到合适的值，不然会有拉伸，最后再回调给用户。</span><br><span class="line">##### 二、ImageLoader 分析</span><br><span class="line">我们直接先看构造方法，看所有的关键地方，不重要的就不分析了</span><br></pre></td></tr></table></figure><p>public ImageLoader(RequestQueue queue, ImageCache imageCache) {<br>        mRequestQueue = queue;<br>        mCache = imageCache;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">没啥说的，就是赋值，一个是请求队列，一个是图片缓存的自己实现，这个是在内部把请求添加到请求队列，所以直接传递进去，第二个参数缓存，我们可以自己实现，一般使用```LruCache```实现。</span><br><span class="line">接下来我们接着看```getImageListener```:</span><br></pre></td></tr></table></figure></p><p>public static ImageListener getImageListener(<br>            final ImageView view, final int defaultImageResId, final int errorImageResId) {<br>        return new ImageListener() {<br>            @Override<br>            public void onErrorResponse(VolleyError error) {<br>                if (errorImageResId != 0) {<br>                    view.setImageResource(errorImageResId);<br>                }<br>            }</p><pre><code>    @Override    public void onResponse(ImageContainer response, boolean isImmediate) {        if (response.getBitmap() != null) {            view.setImageBitmap(response.getBitmap());        } else if (defaultImageResId != 0) {            view.setImageResource(defaultImageResId);        }    }};</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个方法比较简单，就是传入我们的```image view```进行设置图像，然后分别提供一个默认和请求失败的占位图，刚开始设置的时候还没有请求到```Bitmap```,所以最开始设置的事默认图。  </span><br><span class="line">首先看两个变量，后面需要用到：</span><br></pre></td></tr></table></figure></p><p>//相同URL正在请求中存储的map<br>private final HashMap&lt;String, BatchedImageRequest&gt; mInFlightRequests = new HashMap&lt;&gt;();<br>//相同URL请求结果存储的map<br>private final HashMap&lt;String, BatchedImageRequest&gt; mBatchedResponses = new HashMap&lt;&gt;();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来我们看看关键的一步</span><br></pre></td></tr></table></figure></p><pre><code>@MainThreadpublic ImageContainer get(        String requestUrl,        ImageListener imageListener,        int maxWidth,        int maxHeight,        ScaleType scaleType) {    // 检查当前线程是否在主线程，只满足从主线程发起的请求    Threads.throwIfNotOnMainThread();    //根据url、width、height、scaleType拼接的缓存key    final String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight, scaleType);    // 从缓存中查找bitmap    Bitmap cachedBitmap = mCache.getBitmap(cacheKey);    if (cachedBitmap != null) {        // 有相应的缓存那么则返回一个ImageContainer，包括其中的bitmap        ImageContainer container =                new ImageContainer(                        cachedBitmap, requestUrl, /* cacheKey= */ null, /* listener= */ null);        // 直接调用onResponse，把bitmap设置给imageView        imageListener.onResponse(container, true);        return container;    }    // 缓存中没有查找到，那么我们直接获取，首先new一个ImageContainer    ImageContainer imageContainer =            new ImageContainer(null, requestUrl, cacheKey, imageListener);    // 更新调用的地方，使用默认的图片先设置    imageListener.onResponse(imageContainer, true);    //检查是否有相同的cacheKey请求正在运行    BatchedImageRequest request = mInFlightRequests.get(cacheKey);    if (request != null) {        // 如果相同的请求正在运行，那么不需要重复请求，只需要将这个实例化        的imageContainer添加到BatchedImageRequest的mContainers中，然后请        求结束后对所有添加到集合中的imageContainer依次回调        request.addContainer(imageContainer);        return imageContainer;    }    // 如果这个请求尚未执行，发送一个新的请求到网络上，这里才是执行请求的地方    Request&lt;Bitmap&gt; newRequest =            makeImageRequest(requestUrl, maxWidth, maxHeight, scaleType, cacheKey);    //添加到请求队列    mRequestQueue.add(newRequest);    //添加到正在请求的集合中    mInFlightRequests.put(cacheKey, new BatchedImageRequest(newRequest, imageContainer));    return imageContainer;</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个方法是一个重点，主要流程是首先看看缓存里面有没有缓存的```Bitmap```,来源于我们自己实现的缓存策略，我们使用的是内存缓存的话这里就是一级缓存；如果有直接调用```onResponse```方法设置图片，如果没有，首先实例化``ImageContainer``，涉及到了几个类，接下来就看是否有相同的请求，如果有则添加到一个集合中，请求下来统一处理；如果没有那么则构造一个```Request```，通过```RequestQueue```去获取网络图片，可能是网络请求也有可能是磁盘缓存的，这里就是二级缓存，然后添加到正在请求的集合中。  </span><br><span class="line">接下来看一看```ImageContainer```这个类,这个类就是图像请求的一个容器对象</span><br></pre></td></tr></table></figure></p><p>public class ImageContainer {<br>        //imageview加载的Bitmap<br>        private Bitmap mBitmap;</p><pre><code>    //图片加载成功和失败的监听    private final ImageListener mListener;    //缓存的key    private final String mCacheKey;    //请求指定的URL    private final String mRequestUrl;    public ImageContainer(            Bitmap bitmap, String requestUrl, String cacheKey, ImageListener listener) {        mBitmap = bitmap;        mRequestUrl = requestUrl;        mCacheKey = cacheKey;        mListener = listener;    }    //取消请求    @MainThread    public void cancelRequest() {        Threads.throwIfNotOnMainThread();        if (mListener == null) {            return;        }        //从正在请求的集合获取一个批处理request        BatchedImageRequest request = mInFlightRequests.get(mCacheKey);        if (request != null) {            //如果取到request，那么首先从mContainers移除当前的这个ImageContainer，            如果移除后集合为空一个ImageContainer也没有了，那么则取消掉这个请求并返回 true            boolean canceled = request.removeContainerAndCancelIfNecessary(this);            if (canceled) {                //取消了请求则从正在请求的集合中移除BatchedImageRequest                mInFlightRequests.remove(mCacheKey);            }        } else {            // 如果已经请求完成添加到批处理中准备处理分发            request = mBatchedResponses.get(mCacheKey);            if (request != null) {                //首先从mContainers移除当前的这个ImageContainer                request.removeContainerAndCancelIfNecessary(this);                if (request.mContainers.size() == 0) {                    //如果集合中一个ImageContainer都没有，则从等待处理的                    response中移除掉这个BatchedImageRequest                    mBatchedResponses.remove(mCacheKey);                }            }        }    }    public Bitmap getBitmap() {        return mBitmap;    }    /** Returns the requested URL for this container. */    public String getRequestUrl() {        return mRequestUrl;    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个类主要包含是一个图片的容器对象，里面包括了bitmap、监听器、缓存的key以及请求的URL，每个请求都会先组装这个类，然后添加到一个BatchedImageRequest的mContainers中  </span><br><span class="line">接下来我们看看真正发起请求的地方：</span><br></pre></td></tr></table></figure><p>protected Request<bitmap> makeImageRequest(<br>            String requestUrl,<br>            int maxWidth,<br>            int maxHeight,<br>            ScaleType scaleType,<br>            final String cacheKey) {<br>        return new ImageRequest(<br>                requestUrl,<br>                new Listener<bitmap>() {<br>                    @Override<br>                    public void onResponse(Bitmap response) {<br>                        onGetImageSuccess(cacheKey, response);<br>                    }<br>                },<br>                maxWidth,<br>                maxHeight,<br>                scaleType,<br>                Config.RGB_565,<br>                new ErrorListener() {<br>                    @Override<br>                    public void onErrorResponse(VolleyError error) {<br>                        onGetImageError(cacheKey, error);<br>                    }<br>                });<br>    }</bitmap></bitmap></p><pre><code>//图片请求成功protected void onGetImageSuccess(String cacheKey, Bitmap response) {    // 添加到以及缓存中    mCache.putBitmap(cacheKey, response);    // 从正在运行的请求列表中删除这个请求    BatchedImageRequest request = mInFlightRequests.remove(cacheKey);    if (request != null) {        //更新BatchedImageRequest的bitmap        request.mResponseBitmap = response;        //发送一个批处理请求，将多个相同的请求进行分发        batchResponse(cacheKey, request);    }}//图片请求失败，跟上面成功处理大致类似protected void onGetImageError(String cacheKey, VolleyError error) {    BatchedImageRequest request = mInFlightRequests.remove(cacheKey);    if (request != null) {        //设置这个请求的错误        request.setError(error);        batchResponse(cacheKey, request);    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里执行网络请求还是调用我们上面分析的```ImageRequest```方法，而且在回调中分别对成功和失败在进行了一次处理。  </span><br><span class="line">接下来我们看看这个批量处理图片的```batchResponse```方法：</span><br></pre></td></tr></table></figure><p>private void batchResponse(String cacheKey, BatchedImageRequest request) {<br>        //首先添加到这个map中，表明现在进入了批处理中<br>        mBatchedResponses.put(cacheKey, request);<br>        // 如果还没有进行处理，那么我们则开始一个新的任务<br>        if (mRunnable == null) {<br>            mRunnable =<br>                    new Runnable() {<br>                        @Override<br>                        public void run() {<br>                            //循环mBatchedResponses的所有值<br>                            for (BatchedImageRequest bir : mBatchedResponses.values()) {<br>                                //循环BatchedImageRequest的mContainers的值<br>                                for (ImageContainer container : bir.mContainers) {<br>                                    //如果有的请求取消了，在收到请求的<br>                                    响应后还没有分发之前那么跳过循环下一个<br>                                    if (container.mListener == null) {<br>                                        continue;<br>                                    }<br>                                    // 如果不是请求错误则调用onResponse<br>                                    if (bir.getError() == null) {<br>                                        container.mBitmap = bir.mResponseBitmap;<br>                                        container.mListener.onResponse(container, false);<br>                                    } else {<br>                                       //请求报错则调用onErrorResponse设置一个错误的图片展示 container.mListener.onErrorResponse(bir.getError());<br>                                    }<br>                                }<br>                            }<br>                            //清除所有响应的BatchedImageRequest<br>                            mBatchedResponses.clear();<br>                            //置为null，通过是否为null判断当前是否正在处理<br>                            mRunnable = null;<br>                        }<br>                    };<br>            // 将这个post投递到主线程去执行<br>            mHandler.postDelayed(mRunnable, mBatchResponseDelayMs);<br>        }<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这段代码也很简单，不过有个地方有个比较奇怪的地方，为啥是使用双层循环，为啥不直接使用内层的循环；个人认为有可能是这样，首先这个```mBatchedResponses```刚开始进来添加了相同的key的请求的```BatchedImageRequest```，那么存在正在分发的时候又有不同的key的请求进来了，因为正在处理的时候```runnable```不为```null```，则后续添加的有可能不能分发，所以要遍历这个map中所有的请求。</span><br><span class="line">##### 三、 NetworkImageView 分析</span><br><span class="line">这是一个继承```ImageView```的自定义```view```：</span><br></pre></td></tr></table></figure></p><p>public class NetworkImageView extends ImageView {<br>    private String mUrl;<br>    //设置默认的图片<br>    private int mDefaultImageId;<br>    //设置请求错误的时候显示的图片<br>    private int mErrorImageId;</p><pre><code>private ImageLoader mImageLoader;private ImageContainer mImageContainer;public NetworkImageView(Context context) {    this(context, null);}public NetworkImageView(Context context, AttributeSet attrs) {    this(context, attrs, 0);}public NetworkImageView(Context context, AttributeSet attrs, int defStyle) {    super(context, attrs, defStyle);}//这个方法就是设置我们的url@MainThreadpublic void setImageUrl(String url, ImageLoader imageLoader) {    Threads.throwIfNotOnMainThread();    mUrl = url;    mImageLoader = imageLoader;    // 我们的url可能已经更改，那么我们则需要判断是否需要加载    loadImageIfNecessary(/* isInLayoutPass= */ false);}public void setDefaultImageResId(int defaultImage) {    mDefaultImageId = defaultImage;}public void setErrorImageResId(int errorImage) {    mErrorImageId = errorImage;}//如果视图尚未加载图像，那么我们则去加载它void loadImageIfNecessary(final boolean isInLayoutPass) {    int width = getWidth();    int height = getHeight();    ScaleType scaleType = getScaleType();    boolean wrapWidth = false, wrapHeight = false;    if (getLayoutParams() != null) {        wrapWidth = getLayoutParams().width == LayoutParams.WRAP_CONTENT;        wrapHeight = getLayoutParams().height == LayoutParams.WRAP_CONTENT;    }    //如果不知道视图的大小并且不是WRAP_CONTENT就暂停加载    boolean isFullyWrapContent = wrapWidth &amp;&amp; wrapHeight;    if (width == 0 &amp;&amp; height == 0 &amp;&amp; !isFullyWrapContent) {        return;    }    // 如果url为空的话则请取消所有的请求，包括以前的请求，假如请求两次    最后次的url为null，这时候还没请求完成，肯定以最后次为准    if (TextUtils.isEmpty(mUrl)) {        if (mImageContainer != null) {            mImageContainer.cancelRequest();            mImageContainer = null;        }        //设置默认的图片        setDefaultImageOrNull();        return;    }    // 检查是否取消以前的请求    if (mImageContainer != null &amp;&amp; mImageContainer.getRequestUrl() != null) {        if (mImageContainer.getRequestUrl().equals(mUrl)) {            // 如果请求和以前相同则没必要再次请求            return;        } else {            // 如果存在正在请求的url并且请求url不同，那么取消正在请求的url            mImageContainer.cancelRequest();            setDefaultImageOrNull();        }    }    // 计算最大宽高，如果设置WRAP_CONTENT那么则图片是多大就是多大，其它    情况则直接使用布局的宽高，如果设置了具体的值就有可能裁剪    int maxWidth = wrapWidth ? 0 : width;    int maxHeight = wrapHeight ? 0 : height;    // 使用ImageLoader来请求图像，上面已经分析了，最终返回一个ImageContainer    mImageContainer =            mImageLoader.get(                    mUrl,                    new ImageListener() {                        @Override                        public void onErrorResponse(VolleyError error) {                            if (mErrorImageId != 0) {                                setImageResource(mErrorImageId);                            }                        }                        @Override                        public void onResponse(                                final ImageContainer response, boolean isImmediate) {                            //isImmediate：在网络请求过程中调用的时候为true，可以用来                            区分是否是取的缓存图像还是网络图像加载                            isInLayoutPass：如果通过onLayout调用此函数，                            则为true，否则为false                            这个if的意思就是，如果是缓存图像并且是在布局中调用那么则发送                            到主线程并延迟设置图像，因为可能多次调用                            if (isImmediate &amp;&amp; isInLayoutPass) {                                post(                                        new Runnable() {                                            @Override                                            public void run() {                                                onResponse(response, /* isImmediate= */ false);                                            }                                        });                                return;                            }                            //请求成功加载图片                            if (response.getBitmap() != null) {                                setImageBitmap(response.getBitmap());                            } else if (mDefaultImageId != 0) {                                setImageResource(mDefaultImageId);                            }                        }                    },                    maxWidth,                    maxHeight,                    scaleType);}private void setDefaultImageOrNull() {    if (mDefaultImageId != 0) {        setImageResource(mDefaultImageId);    } else {        setImageBitmap(null);    }}@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) {    super.onLayout(changed, left, top, right, bottom);    loadImageIfNecessary(/* isInLayoutPass= */ true);}//当imageview销毁的时候，取消请求并且清除ImageContainer以便重新加载图像@Overrideprotected void onDetachedFromWindow() {    if (mImageContainer != null) {        // If the view was bound to an image request, cancel it and clear        // out the image from the view.        mImageContainer.cancelRequest();        setImageBitmap(null);        // also clear out the container so we can reload the image if necessary.        mImageContainer = null;    }    super.onDetachedFromWindow();}@Overrideprotected void drawableStateChanged() {    super.drawableStateChanged();    invalidate();}</code></pre><p>}</p><p><code>这个类没啥好分析的，就是利用前两个类来完成请求，只不过方便的是直接在xml中使用，使用</code>ImageLoader<code>请求的</code>Bitmap<code>设置给</code>NetworkImageView<code>`</code>。</p><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>三种不同的方式都可以完成图片的加载，不过后面的方式都比较依赖前面的<code>ImageRequest</code>，毕竟还是要这个类去完成网络请求操作；在使用中，根据不同的场景选择不同的方式使用。不过我建议使用<code>ImageLoader</code>来加载图片，可以自己设置缓存，两级缓存，一级内存缓存，一级<code>volley</code>请求时候的磁盘缓存。总体来讲封装的很不错，对一些细节处理的比较好，比如相同的请求、图片的裁剪等，值得我们学习的地方很多。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/guolin_blog/article/details/17482165" target="_blank" rel="noopener">Android Volley完全解析(二)，使用Volley加载网络图片</a><br><a href="https://github.com/wangzhengyi/Volley/blob/master/README.md" target="_blank" rel="noopener">Volley 源码解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h4&gt;&lt;p&gt;上篇文章我们分析了网络请求，这篇文章分析对图片的处理操作，如果没看上一篇，可以先看上一篇文章&lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="源码解析" scheme="https://wvisible.github.io/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Volley" scheme="https://wvisible.github.io/tags/Volley/"/>
    
  </entry>
  
  <entry>
    <title>Volley 源码解析之网络请求</title>
    <link href="https://wvisible.github.io/2020/03/05/Volley-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    <id>https://wvisible.github.io/2020/03/05/Volley-源码解析之网络请求/</id>
    <published>2020-03-05T15:36:09.000Z</published>
    <updated>2020-03-06T08:08:15.672Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Volley 源码解析之网络请求](https://juejin.im/post/5c1c58b35188251f1f320e70)  </span><br><span class="line">[Volley 源码解析之图片请求](https://juejin.im/post/5c1c84ade51d4535f05a192c)</span><br><span class="line">[Volley 源码解析之缓存机制](https://juejin.im/post/5c27a52de51d455fac46838d)</span><br><span class="line"></span><br><span class="line">&gt; Volley 是 Google 推出的一款网络通信框架，非常适合数据量小、通信频繁的网络请求，支持并发、缓存和容易扩展、调试等；不过不太适合下载大文件、大量数据的网络请求，因为volley在解析期间将响应放到内存中，我们可以使用okhttp或者系统提供的```DownloadManager```来下载文件。</span><br><span class="line"></span><br><span class="line">#### 一、简单使用</span><br><span class="line"></span><br><span class="line">首先在工程引入volley的library：</span><br><span class="line"></span><br><span class="line">```groovy</span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;com.android.volley:volley:1.1.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要我们打开网络权限，我这里直接贴出官网简单请求的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TextView mTextView = (TextView) findViewById(R.id.text);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate the RequestQueue.</span></span><br><span class="line">RequestQueue queue = Volley.newRequestQueue(<span class="keyword">this</span>);</span><br><span class="line">String url =<span class="string">"http://www.google.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Request a string response from the provided URL.</span></span><br><span class="line">StringRequest stringRequest = <span class="keyword">new</span> StringRequest(Request.Method.GET, url,</span><br><span class="line">            <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Display the first 500 characters of the response string.</span></span><br><span class="line">        mTextView.setText(<span class="string">"Response is: "</span>+ response.substring(<span class="number">0</span>,<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">        mTextView.setText(<span class="string">"That didn't work!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the request to the RequestQueue.</span></span><br><span class="line">queue.add(stringRequest);</span><br></pre></td></tr></table></figure><p>使用相对简单，回调直接在主线程，我们取消某个请求直接这样操作：</p><ol><li><p>定义一个标记添加到requests中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyTag"</span>;</span><br><span class="line">StringRequest stringRequest; <span class="comment">// Assume this exists.</span></span><br><span class="line">RequestQueue mRequestQueue;  <span class="comment">// Assume this exists.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the tag on the request.</span></span><br><span class="line">stringRequest.setTag(TAG);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the request to the RequestQueue.</span></span><br><span class="line">mRequestQueue.add(stringRequest);</span><br></pre></td></tr></table></figure></li><li><p>然后我们可以在 onStop() 中取消所有标记的请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    <span class="keyword">if</span> (mRequestQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRequestQueue.cancelAll(TAG);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h4><p>我们先从Volley这个类入手：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, BaseHttpStack stack)</span> </span>&#123;</span><br><span class="line">    BasicNetwork network;</span><br><span class="line">    <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">            network = <span class="keyword">new</span> BasicNetwork(<span class="keyword">new</span> HurlStack());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String userAgent = <span class="string">"volley/0"</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String packageName = context.getPackageName();</span><br><span class="line">                PackageInfo info =</span><br><span class="line">                    context.getPackageManager().getPackageInfo(packageName, <span class="comment">/* flags= */</span> <span class="number">0</span>);</span><br><span class="line">                userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            network =</span><br><span class="line">                <span class="keyword">new</span> BasicNetwork(</span><br><span class="line">                <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRequestQueue(context, network);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, Network network)</span> </span>&#123;</span><br><span class="line">    File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">    RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</span><br><span class="line">    queue.start();</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newRequestQueue(context, (BaseHttpStack) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们传递一个<figure class="highlight plain"><figcaption><span>```默认提供了基于```HttpURLCollection```的```HurlStack```和基于```HttpClient```的```HttpClientStack```。Android6.0移除了```HttpClient```，Google官方推荐使用```HttpURLCollection```类作为替换。所以这里在API大于9的版本是用的是```HurlStack```,为什么这样选择，详情可见这篇博客[Android访问网络，使用HttpURLConnection还是HttpClient？](https://blog.csdn.net/guolin_blog/article/details/12452307)。我们使用的是默认的构造，```BaseHttpStack```传入为null，如果我们想使用自定义的okhttp替换底层，我们直接继承```HttpStack```重写即可，也可以自定义```Network```和```RequestQueue```,```Volley```的高扩展性充分体现。接下来则创建一个```Network```对象，然后实例化```RequestQueue```,首先创建了一个用于缓存的文件夹，然后创建了一个磁盘缓存，将文件缓存到指定目录的硬盘上，默认大小是5M，但是大小可以配置。接下来调用```RequestQueue```的```start()```方法进行启动，我们进入这个方法查看一下：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">public void start() &#123;</span><br><span class="line">    stop(); </span><br><span class="line">    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher =</span><br><span class="line">            new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>开始启动的时候先停止所有的请求线程和网络缓存线程，然后实例化一个缓存线程并运行，然后一个循环开启<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">构造了```RequestQueue```之后，我们调用```add()```方法将相应的```Request```传入就开始执行网络请求了，我们看看这个方法：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) &#123;</span><br><span class="line">    //将请求队列和请求关联起来</span><br><span class="line">    request.setRequestQueue(this);</span><br><span class="line">    //添加到正在请求中但是还未完成的集合中</span><br><span class="line">    synchronized (mCurrentRequests) &#123;</span><br><span class="line">        mCurrentRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">    //设置请求的一个序列号，通过原子变量的incrementAndGet方法，</span><br><span class="line">    //以原子方式给当前值加1并获取新值实现请求的优先级</span><br><span class="line">    request.setSequence(getSequenceNumber());</span><br><span class="line">    //添加一个调试信息</span><br><span class="line">    request.addMarker(&quot;add-to-queue&quot;);</span><br><span class="line"></span><br><span class="line">    //如果不需要缓存则直接加到网络的请求队列，默认每一个请求都是缓存的，</span><br><span class="line">    //如果不需要缓存需要调用Request的setShouldCache方法来修改</span><br><span class="line">    if (!request.shouldCache()) &#123;</span><br><span class="line">        mNetworkQueue.add(request);</span><br><span class="line">        return request;</span><br><span class="line">    &#125;</span><br><span class="line">    //加到缓存的请求队列</span><br><span class="line">    mCacheQueue.add(request);</span><br><span class="line">    return request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键地方都写了注释，主要作用就是将请求加到请求队列，执行网络请求或者从缓存中获取结果。网络和缓存的请求都是一个优先级阻塞队列，按照优先级出队。上面几个关键步骤，添加到请求集合里面还有设置优先级以及添加到缓存和请求队列都是线程安全的，要么加锁，要么使用线程安全的队列或者原子操作。</p><p>接下来我们看看添加到<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);</span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line"></span><br><span class="line">   //初始化DiskBasedCache的缓存类</span><br><span class="line">    mCache.initialize();</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            processRequest();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            if (mQuit) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            VolleyLog.e(</span><br><span class="line">                &quot;Ignoring spurious interrupt of CacheDispatcher thread; &quot;</span><br><span class="line">                + &quot;use quit() to terminate it&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来的重点是看看<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">private void processRequest() throws InterruptedException &#123;</span><br><span class="line">    //从缓存队列取出请求</span><br><span class="line">    final Request&lt;?&gt; request = mCacheQueue.take();</span><br><span class="line">    processRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@VisibleForTesting</span><br><span class="line">void processRequest(final Request&lt;?&gt; request) throws InterruptedException &#123;</span><br><span class="line">    request.addMarker(&quot;cache-queue-take&quot;);</span><br><span class="line"></span><br><span class="line">    // 如果请求被取消，我们可以通过RequestQueue的回调接口来监听</span><br><span class="line">    if (request.isCanceled()) &#123;</span><br><span class="line">        request.finish(&quot;cache-discard-canceled&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从缓存中获取Cache.Entry</span><br><span class="line">    Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">    //没有取到缓存</span><br><span class="line">    if (entry == null) &#123;</span><br><span class="line">        request.addMarker(&quot;cache-miss&quot;);</span><br><span class="line">        // 缓存未命中，对于可缓存的请求先去检查是否有相同的请求是否已经在运行中，</span><br><span class="line">        //如果有的话先加入请求等待队列，等待请求完成，返回true；如果返回false则表示第一次请求</span><br><span class="line">        if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">            //加入到网络请求的阻塞队列</span><br><span class="line">            mNetworkQueue.put(request);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果缓存完全过期，处理过程跟上面类似</span><br><span class="line">    if (entry.isExpired()) &#123;</span><br><span class="line">        request.addMarker(&quot;cache-hit-expired&quot;);</span><br><span class="line">        //设置请求缓存的entry到这个request中</span><br><span class="line">        request.setCacheEntry(entry);</span><br><span class="line">        if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">            mNetworkQueue.put(request);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //缓存命中，将数据解析并返回到request的抽象方法中</span><br><span class="line">    request.addMarker(&quot;cache-hit&quot;);</span><br><span class="line">    Response&lt;?&gt; response =</span><br><span class="line">        request.parseNetworkResponse(</span><br><span class="line">        new NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">    request.addMarker(&quot;cache-hit-parsed&quot;);</span><br><span class="line"></span><br><span class="line">    //判断请求结果是否需要刷新</span><br><span class="line">    if (!entry.refreshNeeded()) &#123;</span><br><span class="line">        // 未过期的缓存命中，通过ExecutorDelivery回调给我们的request子类的接口中，</span><br><span class="line">        // 我们在使用的时候就可以通过StringRequest、JsonRequest等拿到结果，</span><br><span class="line">        // 切换到主线程也是在这个类里执行的</span><br><span class="line">        mDelivery.postResponse(request, response);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        request.addMarker(&quot;cache-hit-refresh-needed&quot;);</span><br><span class="line">        request.setCacheEntry(entry);</span><br><span class="line">        // 将这个响应标记为中间值，即这个响应是新鲜的，那么第二个响应正在请求随时到来</span><br><span class="line">        response.intermediate = true;</span><br><span class="line"></span><br><span class="line">        if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">            //发起网络请求，这里为什么直接调用上面的mNetworkQueue.put(request);呢，</span><br><span class="line">            //主要是为了添加一个已经分发的标记，在响应分发的时候不再回调给用户，</span><br><span class="line">            //不然就回调了两次</span><br><span class="line">            mDelivery.postResponse(</span><br><span class="line">                request,</span><br><span class="line">                response,</span><br><span class="line">                new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            mNetworkQueue.put(request);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            // Restore the interrupted status</span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //这里第三个参数传递null，不用再去分发，因为已经有相同的请求已经在执行，</span><br><span class="line">            //直接添加到了等待请求的列表中，然后返回的时候从已经执行的请求收到响应</span><br><span class="line">            mDelivery.postResponse(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这部分主要是对请求的缓存判断，是否过期以及需要刷新缓存。我们调用取消所有请求或者取消某个请求实质上就是对<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中有一个WaitingRequestManager，如果有相同的请求那么就需要一个暂存的地方，这个类就是做的这个操作</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">private static class WaitingRequestManager implements Request.NetworkRequestCompleteListener &#123;</span><br><span class="line">    //所有等待请求的集合，键是缓存的key</span><br><span class="line">    private final Map&lt;String, List&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private final CacheDispatcher mCacheDispatcher;</span><br><span class="line"></span><br><span class="line">    WaitingRequestManager(CacheDispatcher cacheDispatcher) &#123;</span><br><span class="line">        mCacheDispatcher = cacheDispatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //请求接受到一个有效的响应，后面等待的相同请求就可以使用这个响应</span><br><span class="line">    @Override</span><br><span class="line">    public void onResponseReceived(Request&lt;?&gt; request, Response&lt;?&gt; response) &#123;</span><br><span class="line">        //如果缓存为空或者已经过期，那么就释放等待的请求</span><br><span class="line">        if (response.cacheEntry == null || response.cacheEntry.isExpired()) &#123;</span><br><span class="line">            onNoUsableResponseReceived(request);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String cacheKey = request.getCacheKey();</span><br><span class="line">        //等待的请求的集合</span><br><span class="line">        List&lt;Request&lt;?&gt;&gt; waitingRequests;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            //从map里面移除这个请求的集合</span><br><span class="line">            waitingRequests = mWaitingRequests.remove(cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">        if (waitingRequests != null) &#123;</span><br><span class="line">            if (VolleyLog.DEBUG) &#123;</span><br><span class="line">                VolleyLog.v(</span><br><span class="line">                    &quot;Releasing %d waiting requests for cacheKey=%s.&quot;,</span><br><span class="line">                    waitingRequests.size(), cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">            // 里面所有的请求都分发到相应的回调执行，下面会讲解</span><br><span class="line">            for (Request&lt;?&gt; waiting : waitingRequests) &#123;</span><br><span class="line">                mCacheDispatcher.mDelivery.postResponse(waiting, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //没有收到相应，则需要释放请求</span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void onNoUsableResponseReceived(Request&lt;?&gt; request) &#123;</span><br><span class="line">        String cacheKey = request.getCacheKey();</span><br><span class="line">        List&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</span><br><span class="line">        if (waitingRequests != null &amp;&amp; !waitingRequests.isEmpty()) &#123;</span><br><span class="line">            if (VolleyLog.DEBUG) &#123;</span><br><span class="line">                VolleyLog.v(</span><br><span class="line">                    &quot;%d waiting requests for cacheKey=%s; resend to network&quot;,</span><br><span class="line">                    waitingRequests.size(), cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">            //下面这个请求执会重新执行，将这个移除添加到</span><br><span class="line">            Request&lt;?&gt; nextInLine = waitingRequests.remove(0);</span><br><span class="line">            //将剩下的请求放到等待请求的map中</span><br><span class="line">            mWaitingRequests.put(cacheKey, waitingRequests);</span><br><span class="line">            //在request里面注册一个回调接口，因为重新开始请求，需要重新注册一个监听，</span><br><span class="line">            //后面请求成功失败以及取消都可以收到回调</span><br><span class="line">            nextInLine.setNetworkRequestCompleteListener(this);</span><br><span class="line">            try &#123;</span><br><span class="line">                //从上面if判断方法可以得出：waitingRequests != null &amp;&amp; !waitingRequests.isEmpty()</span><br><span class="line">                //排除了第一次请求失败、取消的情况，后面的那个条件则表示这个等待请求队列必须要有一个请求，</span><br><span class="line">                //同时满足才会执行这里面的代码，一般只要这里面的请求执行成功一次后续所有的请求都会被移除，</span><br><span class="line">                //所以这里对多个请求的情况，失败一次，那么后续的请求会继续执行</span><br><span class="line">                mCacheDispatcher.mNetworkQueue.put(nextInLine);</span><br><span class="line">            &#125; catch (InterruptedException iex) &#123;</span><br><span class="line">                VolleyLog.e(&quot;Couldn&apos;t add request to queue. %s&quot;, iex.toString());</span><br><span class="line">                // Restore the interrupted status of the calling thread (i.e. NetworkDispatcher)</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                // Quit the current CacheDispatcher thread.</span><br><span class="line">                mCacheDispatcher.quit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //对于可以缓存的请求，相同缓存的请求已经在运行中就添加到一个发送队列，</span><br><span class="line"> //等待运行中的队列请求完成，返回true表示已经有请求在运行，false则是第一次执行</span><br><span class="line">    private synchronized boolean maybeAddToWaitingRequests(Request&lt;?&gt; request) &#123;</span><br><span class="line">        String cacheKey = request.getCacheKey();</span><br><span class="line">        // 存在相同的请求则把请求加入到相同缓存键的集合中</span><br><span class="line">        if (mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class="line">            // There is already a request in flight. Queue up.</span><br><span class="line">            List&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class="line">            //如果包含相同的请求但是有可能是第二次请求，前面第一次请求插入null了</span><br><span class="line">            if (stagedRequests == null) &#123;</span><br><span class="line">                stagedRequests = new ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            request.addMarker(&quot;waiting-for-response&quot;);</span><br><span class="line">            stagedRequests.add(request);</span><br><span class="line">            mWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class="line">            if (VolleyLog.DEBUG) &#123;</span><br><span class="line">                VolleyLog.d(&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //第一次请求那么则插入一个null，表示当前有一个请求正在运行</span><br><span class="line">            mWaitingRequests.put(cacheKey, null);</span><br><span class="line">            //注册一个接口监听</span><br><span class="line">            request.setNetworkRequestCompleteListener(this);</span><br><span class="line">            if (VolleyLog.DEBUG) &#123;</span><br><span class="line">                VolleyLog.d(&quot;new request, sending to network %s&quot;, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个类主要是避免相同的请求多次请求，而且在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们接下来看看```NetworkDispatcher```网络请求队列的```run```方法中的```processRequest```方法:</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@VisibleForTesting</span><br><span class="line">void processRequest(Request&lt;?&gt; request) &#123;</span><br><span class="line">    long startTimeMs = SystemClock.elapsedRealtime();</span><br><span class="line">    try &#123;</span><br><span class="line">        request.addMarker(&quot;network-queue-take&quot;);</span><br><span class="line"></span><br><span class="line">        // 请求被取消了，就不执行网络请求,</span><br><span class="line">        if (request.isCanceled()) &#123;</span><br><span class="line">            request.finish(&quot;network-discard-cancelled&quot;);</span><br><span class="line">            request.notifyListenerResponseNotUsable();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addTrafficStatsTag(request);</span><br><span class="line"></span><br><span class="line">        // 这里就是执行网络请求的地方</span><br><span class="line">        NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">        request.addMarker(&quot;network-http-complete&quot;);</span><br><span class="line"></span><br><span class="line">        // 如果服务器返回304响应，即没有修改过，</span><br><span class="line">        //缓存依然是有效的并且是在需要刷新的有效期内，那么则不需要解析响应</span><br><span class="line">        if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">            request.finish(&quot;not-modified&quot;);</span><br><span class="line">            //没有收到来自网络的有效响应，释放请求</span><br><span class="line">            request.notifyListenerResponseNotUsable();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 在工作线程中解析这些响应</span><br><span class="line">        Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">        request.addMarker(&quot;network-parse-complete&quot;);</span><br><span class="line"></span><br><span class="line">        // 将缓存写入到应用</span><br><span class="line">        if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</span><br><span class="line">            mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">            request.addMarker(&quot;network-cache-written&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 标记此请求已将分发</span><br><span class="line">        request.markDelivered();</span><br><span class="line">        //将请求的响应回调给用户</span><br><span class="line">        mDelivery.postResponse(request, response);</span><br><span class="line">        //请求接受到了一个响应，其他相同的请求可以使用这个响应</span><br><span class="line">        request.notifyListenerResponseReceived(response);</span><br><span class="line">    &#125; catch (VolleyError volleyError) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里才是网络请求的真正执行以及解析分发的地方，重点看两个地方的代码，执行和解析，我们先看看执行网络请求这个代码，执行的地方是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Override</span><br><span class="line">public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123;</span><br><span class="line">    long requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        HttpResponse httpResponse = null;</span><br><span class="line">        byte[] responseContents = null;</span><br><span class="line">        List&lt;Header&gt; responseHeaders = Collections.emptyList();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 构造缓存的头部，添加If-None-Match和If-Modified-Since，都是http/1.1中控制协商缓存的两个字段，     </span><br><span class="line">            // If-None-Match：客服端再次发起请求时，携带上次请求返回的唯一标识Etag值，</span><br><span class="line">            //服务端用携带的值和最后修改的值作对比，最后修改时间大于携带的字段值则返回200，否则304；</span><br><span class="line">            // If-Modified-Since：客服端再次发起请求时，携带上次请求返回的Last-Modified值，</span><br><span class="line">            //服务端用携带的值和服务器的Etag值作对比，一致则返回304</span><br><span class="line">            Map&lt;String, String&gt; additionalRequestHeaders =</span><br><span class="line">                getCacheHeaders(request.getCacheEntry());</span><br><span class="line">            //因为现在一般的sdk都是大于9的，那么这里执行的就是HurlStack的executeRequest方法，</span><br><span class="line">            //执行网络请求，和我们平时使用HttpURLConnection请求网络大致相同</span><br><span class="line">            httpResponse = mBaseHttpStack.executeRequest(request, additionalRequestHeaders);</span><br><span class="line">            int statusCode = httpResponse.getStatusCode();</span><br><span class="line"></span><br><span class="line">            responseHeaders = httpResponse.getHeaders();</span><br><span class="line">            // 服务端返回304时，那么就表示资源无更新，可以继续使用缓存的值</span><br><span class="line">            if (statusCode == HttpURLConnection.HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">                Entry entry = request.getCacheEntry();</span><br><span class="line">                if (entry == null) &#123;</span><br><span class="line">                    return new NetworkResponse(</span><br><span class="line">                        HttpURLConnection.HTTP_NOT_MODIFIED,</span><br><span class="line">                        /* data= */ null,</span><br><span class="line">                        /* notModified= */ true,</span><br><span class="line">                        SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                        responseHeaders);</span><br><span class="line">                &#125;</span><br><span class="line">                // 将缓存头和响应头组合在一起，一次响应就完成了</span><br><span class="line">                List&lt;Header&gt; combinedHeaders = combineHeaders(responseHeaders, entry);</span><br><span class="line">                return new NetworkResponse(</span><br><span class="line">                    HttpURLConnection.HTTP_NOT_MODIFIED,</span><br><span class="line">                    entry.data,</span><br><span class="line">                    /* notModified= */ true,</span><br><span class="line">                    SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                    combinedHeaders);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果返回204，执行成功，没有数据，这里需要检查</span><br><span class="line">            InputStream inputStream = httpResponse.getContent();</span><br><span class="line">            if (inputStream != null) &#123;</span><br><span class="line">                responseContents =</span><br><span class="line">                    inputStreamToBytes(inputStream, httpResponse.getContentLength());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //返回204，就返回一个空的byte数组</span><br><span class="line">                responseContents = new byte[0];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // if the request is slow, log it.</span><br><span class="line">            long requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">            logSlowRequests(requestLifetime, request, responseContents, statusCode);</span><br><span class="line"></span><br><span class="line">            if (statusCode &lt; 200 || statusCode &gt; 299) &#123;</span><br><span class="line">                throw new IOException();</span><br><span class="line">            &#125;</span><br><span class="line">            return new NetworkResponse(</span><br><span class="line">                statusCode,</span><br><span class="line">                responseContents,</span><br><span class="line">                /* notModified= */ false,</span><br><span class="line">                SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                responseHeaders);</span><br><span class="line">        &#125; catch (SocketTimeoutException e) &#123;</span><br><span class="line">            //异常进行重新请求等...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里主要执行了添加缓存头并发起网络请求，然后将返回值组装成一个<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Override</span><br><span class="line">@SuppressWarnings(&quot;DefaultCharset&quot;)</span><br><span class="line">protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) &#123;</span><br><span class="line">    String parsed;</span><br><span class="line">    try &#123;</span><br><span class="line">        parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers));</span><br><span class="line">    &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">        // Since minSdkVersion = 8, we can&apos;t call</span><br><span class="line">        // new String(response.data, Charset.defaultCharset())</span><br><span class="line">        // So suppress the warning instead.</span><br><span class="line">        parsed = new String(response.data);</span><br><span class="line">    &#125;</span><br><span class="line">    return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到将值组装成一个String，然后组装成一个<figure class="highlight plain"><figcaption><span>response)```，这里我们先重点看看这个类```ExecutorDelivery```:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java </span><br><span class="line">public class ExecutorDelivery implements ResponseDelivery &#123;</span><br><span class="line">    //构造执行已提交的Runnable任务对象</span><br><span class="line">    private final Executor mResponsePoster;</span><br><span class="line"></span><br><span class="line">   //这里在RequestQueue构造参数中初始化，new ExecutorDelivery(new Handler(Looper.getMainLooper()))，</span><br><span class="line">   //那么这里runnable就通过绑定主线程的Looper的Handler对象投递到主线程中执行</span><br><span class="line">    public ExecutorDelivery(final Handler handler) &#123;</span><br><span class="line">        // Make an Executor that just wraps the handler.</span><br><span class="line">        mResponsePoster =</span><br><span class="line">                new Executor() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void execute(Runnable command) &#123;</span><br><span class="line">                        handler.post(command);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ExecutorDelivery(Executor executor) &#123;</span><br><span class="line">        mResponsePoster = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这个方法就是我们NetworkDispatcher里面调用的方法，调用下面这个三个参数的构造方法</span><br><span class="line">    @Override</span><br><span class="line">    public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response) &#123;</span><br><span class="line">        postResponse(request, response, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) &#123;</span><br><span class="line">        request.markDelivered();</span><br><span class="line">        request.addMarker(&quot;post-response&quot;);</span><br><span class="line">        //构造了一个ResponseDeliveryRunnable类，传入execute，现在这个runnable就是在主线程里执行</span><br><span class="line">        mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postError(Request&lt;?&gt; request, VolleyError error) &#123;</span><br><span class="line">        request.addMarker(&quot;post-error&quot;);</span><br><span class="line">        Response&lt;?&gt; response = Response.error(error);</span><br><span class="line">        mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, null));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** A Runnable used for delivering network responses to a listener on the main thread. */</span><br><span class="line">    @SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="line">    private static class ResponseDeliveryRunnable implements Runnable &#123;</span><br><span class="line">        private final Request mRequest;</span><br><span class="line">        private final Response mResponse;</span><br><span class="line">        private final Runnable mRunnable;</span><br><span class="line"></span><br><span class="line">        public ResponseDeliveryRunnable(Request request, Response response, Runnable runnable) &#123;</span><br><span class="line">            mRequest = request;</span><br><span class="line">            mResponse = response;</span><br><span class="line">            mRunnable = runnable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //请求取消，那么就不分发给用户</span><br><span class="line">            if (mRequest.isCanceled()) &#123;</span><br><span class="line">                mRequest.finish(&quot;canceled-at-delivery&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 根据isSuccess这个值来提供相应的回调给用户，调用Response会通过error的值是否为null来确定这个值，</span><br><span class="line">            //我们调用VolleyError这个构造函数的时候就为这个值就为false</span><br><span class="line">            if (mResponse.isSuccess()) &#123;</span><br><span class="line">                mRequest.deliverResponse(mResponse.result);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mRequest.deliverError(mResponse.error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果这是一个在新鲜的时间内的请求的响应，就添加一个标记，否则就结束</span><br><span class="line">            if (mResponse.intermediate) &#123;</span><br><span class="line">                mRequest.addMarker(&quot;intermediate-response&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mRequest.finish(&quot;done&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 在CacheDispatcher里面当请求第一次请求时直接调用三个参数的构造方法，通过这个runnable就执行run方法</span><br><span class="line">            if (mRunnable != null) &#123;</span><br><span class="line">                mRunnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面方法主要是将值回调给用户，那么整个网络请求大致就完成了，其中还涉及很多细节的东西，但是大致流程是走通了，不得不说这个库有很多值得我们学习的地方。</p><h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>现在我们看官网的一张图，总结一下整个流程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/.io//volley.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>蓝色是主线程</li><li>绿色是缓存线程</li><li>黄色是网络线程  </li></ul><p>我们可以看到首先是请求添加到<code>RequestQueue</code>里，首先是添加到缓存队列，然后查看是否已经缓存，如果有并且在有效期内的缓存直接回调给用户，如果没有查找到，那么则需要添加到网络请求队列重新请求并且解析响应、写入缓存在发送到主线程给用户回调。</p><h4 id="参考以及相关链接"><a href="#参考以及相关链接" class="headerlink" title="参考以及相关链接"></a>参考以及相关链接</h4><ul><li><a href="https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA" target="_blank" rel="noopener">【第1250期】彻底理解浏览器的缓存机制</a></li><li><a href="https://blog.csdn.net/guolin_blog/article/details/17656437" target="_blank" rel="noopener">Android Volley完全解析(四)，带你从源码的角度理解Volley</a></li><li><a href="https://github.com/wangzhengyi/Volley" target="_blank" rel="noopener">Volley 源码解析</a></li><li><a href="[http://codekk.com/open-source-project-analysis/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90](http://codekk.com/open-source-project-analysis/detail/Android/grumoon/Volley 源码解析">Volley 源码解析</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="源码解析" scheme="https://wvisible.github.io/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Volley" scheme="https://wvisible.github.io/tags/Volley/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 Lambda 指南</title>
    <link href="https://wvisible.github.io/2018/10/07/Java-8-Lambda-%E6%8C%87%E5%8D%97/"/>
    <id>https://wvisible.github.io/2018/10/07/Java-8-Lambda-指南/</id>
    <published>2018-10-07T09:31:03.000Z</published>
    <updated>2020-03-06T07:56:25.965Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>2014年3月，Java 8发布，Lambda表达式作为一个重要的特性。不过在 Android 中最先使用 Retrolambda 插件来使用 Lambda 表达式，随着 Android Studio 的更新，在3.0版本之后通过配置就可以使用 Java8 的所有特性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;2014年3月，Java 8发布，Lambda表达式作为一个重要的特性。不过在 Android 中最先使用 Retrolam
      
    
    </summary>
    
      <category term="Java8" scheme="https://wvisible.github.io/categories/Java8/"/>
    
    
      <category term="Java8 Lambda" scheme="https://wvisible.github.io/tags/Java8-Lambda/"/>
    
      <category term="Lambda 原理" scheme="https://wvisible.github.io/tags/Lambda-%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
